<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="de" xml:lang="de"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.551">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Lukas Arnold">
<meta name="author" content="Simone Arnold">
<meta name="author" content="Florian Bagemihl">
<meta name="author" content="Matthias Baitsch">
<meta name="author" content="Marc Fehr">
<meta name="author" content="Maik Poetzsch">
<meta name="author" content="Sebastian Seipel">

<title>Anwendungsbaustein Energiedatenanalyse</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script><script src="Energiedatenauswertung_files/libs/clipboard/clipboard.min.js"></script>
<script src="Energiedatenauswertung_files/libs/quarto-html/quarto.js"></script>
<script src="Energiedatenauswertung_files/libs/quarto-html/popper.min.js"></script>
<script src="Energiedatenauswertung_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="Energiedatenauswertung_files/libs/quarto-html/anchor.min.js"></script>
<link href="Energiedatenauswertung_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="Energiedatenauswertung_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="Energiedatenauswertung_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="Energiedatenauswertung_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="Energiedatenauswertung_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" integrity="sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==" crossorigin="anonymous"></script>

<script type="application/javascript">define('jquery', [],function() {return window.jQuery;})</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body>

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Inhaltsverzeichnis</h2>
   
  <ul>
  <li><a href="#voraussetzungen" id="toc-voraussetzungen" class="nav-link active" data-scroll-target="#voraussetzungen"><span class="header-section-number">1</span> Voraussetzungen</a></li>
  <li><a href="#lernziele" id="toc-lernziele" class="nav-link" data-scroll-target="#lernziele"><span class="header-section-number">2</span> Lernziele</a></li>
  <li><a href="#hintergrund" id="toc-hintergrund" class="nav-link" data-scroll-target="#hintergrund"><span class="header-section-number">3</span> Hintergrund</a></li>
  <li><a href="#daten-einlesen" id="toc-daten-einlesen" class="nav-link" data-scroll-target="#daten-einlesen"><span class="header-section-number">4</span> Daten einlesen</a></li>
  <li><a href="#daten-organisieren" id="toc-daten-organisieren" class="nav-link" data-scroll-target="#daten-organisieren"><span class="header-section-number">5</span> Daten organisieren</a></li>
  <li><a href="#beschreibende-datenanalyse" id="toc-beschreibende-datenanalyse" class="nav-link" data-scroll-target="#beschreibende-datenanalyse"><span class="header-section-number">6</span> Beschreibende Datenanalyse</a>
  <ul class="collapse">
  <li><a href="#ablesen-ist-pfui-visualisieren-ist-hui-arbeitstitel" id="toc-ablesen-ist-pfui-visualisieren-ist-hui-arbeitstitel" class="nav-link" data-scroll-target="#ablesen-ist-pfui-visualisieren-ist-hui-arbeitstitel"><span class="header-section-number">6.1</span> Ablesen ist pfui, visualisieren ist hui (Arbeitstitel)</a>
  <ul class="collapse">
  <li><a href="#erzeugung-speicherung-einspeisung" id="toc-erzeugung-speicherung-einspeisung" class="nav-link" data-scroll-target="#erzeugung-speicherung-einspeisung">Erzeugung, Speicherung, Einspeisung</a></li>
  </ul></li>
  <li><a href="#sec-aufgabe-beschreibende-Datenanalyse" id="toc-sec-aufgabe-beschreibende-Datenanalyse" class="nav-link" data-scroll-target="#sec-aufgabe-beschreibende-Datenanalyse"><span class="header-section-number">6.2</span> Aufgabe beschreibende Datenanalyse</a>
  <ul class="collapse">
  <li><a href="#optionen-für-abschnitt-beschreibende-statistik" id="toc-optionen-für-abschnitt-beschreibende-statistik" class="nav-link" data-scroll-target="#optionen-für-abschnitt-beschreibende-statistik">Optionen für Abschnitt beschreibende Statistik</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#sec-explorative-datenanalyse" id="toc-sec-explorative-datenanalyse" class="nav-link" data-scroll-target="#sec-explorative-datenanalyse"><span class="header-section-number">7</span> Explorative Datenanalyse</a>
  <ul class="collapse">
  <li><a href="#hintergrund-grenzstromanalyse" id="toc-hintergrund-grenzstromanalyse" class="nav-link" data-scroll-target="#hintergrund-grenzstromanalyse"><span class="header-section-number">7.1</span> Hintergrund: Grenzstromanalyse</a></li>
  <li><a href="#hintergrund-einspeisevorrang-erneuerbarer-energien" id="toc-hintergrund-einspeisevorrang-erneuerbarer-energien" class="nav-link" data-scroll-target="#hintergrund-einspeisevorrang-erneuerbarer-energien"><span class="header-section-number">7.2</span> Hintergrund: Einspeisevorrang erneuerbarer Energien</a></li>
  <li><a href="#residual--und-restlast-bestimmen" id="toc-residual--und-restlast-bestimmen" class="nav-link" data-scroll-target="#residual--und-restlast-bestimmen"><span class="header-section-number">7.3</span> Residual- und Restlast bestimmen</a></li>
  <li><a href="#jahresgang-grafisch-darstellen" id="toc-jahresgang-grafisch-darstellen" class="nav-link" data-scroll-target="#jahresgang-grafisch-darstellen"><span class="header-section-number">7.4</span> Jahresgang grafisch darstellen</a></li>
  <li><a href="#hintergrund-grund--mittel-und-spitzenlast" id="toc-hintergrund-grund--mittel-und-spitzenlast" class="nav-link" data-scroll-target="#hintergrund-grund--mittel-und-spitzenlast"><span class="header-section-number">7.5</span> Hintergrund: Grund-, Mittel und Spitzenlast</a></li>
  <li><a href="#sec-Pumpspeicherinhalt" id="toc-sec-Pumpspeicherinhalt" class="nav-link" data-scroll-target="#sec-Pumpspeicherinhalt"><span class="header-section-number">7.6</span> Bestimmung des in den Pumpspeichern gespeicherten Stroms</a></li>
  <li><a href="#aufgabe-explorative-datenanalyse" id="toc-aufgabe-explorative-datenanalyse" class="nav-link" data-scroll-target="#aufgabe-explorative-datenanalyse"><span class="header-section-number">7.7</span> Aufgabe explorative Datenanalyse</a></li>
  </ul></li>
  <li><a href="#schließende-datenanalyse" id="toc-schließende-datenanalyse" class="nav-link" data-scroll-target="#schließende-datenanalyse"><span class="header-section-number">8</span> Schließende Datenanalyse</a>
  <ul class="collapse">
  <li><a href="#hintergrund-ausbaupfad-erneuerbarer-energien" id="toc-hintergrund-ausbaupfad-erneuerbarer-energien" class="nav-link" data-scroll-target="#hintergrund-ausbaupfad-erneuerbarer-energien"><span class="header-section-number">8.1</span> Hintergrund: Ausbaupfad erneuerbarer Energien</a></li>
  <li><a href="#hintergrund-stromspeicher" id="toc-hintergrund-stromspeicher" class="nav-link" data-scroll-target="#hintergrund-stromspeicher"><span class="header-section-number">8.2</span> Hintergrund: Stromspeicher</a></li>
  <li><a href="#speichergröße-berechnen" id="toc-speichergröße-berechnen" class="nav-link" data-scroll-target="#speichergröße-berechnen"><span class="header-section-number">8.3</span> Speichergröße berechnen</a>
  <ul class="collapse">
  <li><a href="#überschuss-oder-defizit-erneuerbarer-energien" id="toc-überschuss-oder-defizit-erneuerbarer-energien" class="nav-link" data-scroll-target="#überschuss-oder-defizit-erneuerbarer-energien">Überschuss oder Defizit erneuerbarer Energien</a></li>
  <li><a href="#zyklik" id="toc-zyklik" class="nav-link" data-scroll-target="#zyklik">Zyklik</a></li>
  <li><a href="#kappung" id="toc-kappung" class="nav-link" data-scroll-target="#kappung">Kappung</a></li>
  </ul></li>
  <li><a href="#anteil-erneuerbarer-stromerzeugung-bestimmen" id="toc-anteil-erneuerbarer-stromerzeugung-bestimmen" class="nav-link" data-scroll-target="#anteil-erneuerbarer-stromerzeugung-bestimmen"><span class="header-section-number">8.4</span> Anteil erneuerbarer Stromerzeugung bestimmen</a></li>
  <li><a href="#aufgabe-schließende-datenanalyse" id="toc-aufgabe-schließende-datenanalyse" class="nav-link" data-scroll-target="#aufgabe-schließende-datenanalyse"><span class="header-section-number">8.5</span> Aufgabe schließende Datenanalyse</a></li>
  <li><a href="#zusammenfassung" id="toc-zusammenfassung" class="nav-link" data-scroll-target="#zusammenfassung"><span class="header-section-number">8.6</span> Zusammenfassung</a></li>
  </ul></li>
  <li><a href="#informationen-zu-speichern" id="toc-informationen-zu-speichern" class="nav-link" data-scroll-target="#informationen-zu-speichern"><span class="header-section-number">9</span> Informationen zu Speichern</a></li>
  <li><a href="#das-wichtigste" id="toc-das-wichtigste" class="nav-link" data-scroll-target="#das-wichtigste"><span class="header-section-number">10</span> Das Wichtigste</a></li>
  <li><a href="#übungen" id="toc-übungen" class="nav-link" data-scroll-target="#übungen"><span class="header-section-number">11</span> Übungen</a></li>
  </ul>
<div class="quarto-alternate-formats"><h2>Andere Formate</h2><ul><li><a href="Energiedatenauswertung.pdf"><i class="bi bi-file-pdf"></i>PDF</a></li></ul></div></nav>
</div>
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Anwendungsbaustein Energiedatenanalyse</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Autor:innen</div>
    <div class="quarto-title-meta-contents">
             <p>Lukas Arnold </p>
             <p>Simone Arnold </p>
             <p>Florian Bagemihl </p>
             <p>Matthias Baitsch </p>
             <p>Marc Fehr </p>
             <p>Maik Poetzsch </p>
             <p>Sebastian Seipel </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Veröffentlichungsdatum</div>
    <div class="quarto-title-meta-contents">
      <p class="date">19. Juli 2024</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<div id="Lizenz" class="border">
<div>

</div>
<div class="quarto-layout-panel" data-layout="[20, 80]">
<div class="quarto-layout-row">
<div class="quarto-layout-cell" style="flex-basis: 20.0%;justify-content: center;">
<p><img src="skript/00-bilder/CC-BY.svg" class="img-fluid"></p>
</div>
<div class="quarto-layout-cell" style="flex-basis: 80.0%;justify-content: flex-start;">
<p>Bausteine Computergestützter Datenanalyse von Lukas Arnold, Simone Arnold, Florian Bagemihl, Matthias Baitsch, Marc Fehr, Maik Poetzsch und Sebastian Seipel. Anwendungsbaustein Energiedatenanalyse von Maik Poetzsch ist lizensiert unter <a href="https://creativecommons.org/licenses/by/4.0/deed.de">CC BY 4.0</a>. Das Werk ist abrufbar auf <a href="https://github.com/bausteine-der-datenanalyse/bcd-styleguide">GitHub</a>. Ausgenommen von der Lizenz sind alle Logos und anders gekennzeichneten Inhalte. 2024</p>
</div>
</div>
</div>
<p>Zitiervorschlag</p>
<p>Arnold, Lukas, Simone Arnold, Matthias Baitsch, Marc Fehr, Maik Poetzsch, und Sebastian Seipel. 2024. „Bausteine Computergestützter Datenanalyse. Anwendungsbaustein Energiedatenanalyse“. <a href="https://github.com/bausteine-der-datenanalyse/a-energiedatenanalyse" class="uri">https://github.com/bausteine-der-datenanalyse/a-energiedatenanalyse</a>.</p>
<p>BibTeX-Vorlage</p>
<pre><code>@misc{BCD-a-ernergiedatenanalyse-2024,
 title={Bausteine Computergestützter Datenanalyse. Anwendungsbaustein Energiedatenanalyse},
 author={Arnold, Lukas and Arnold, Simone and Baitsch, Matthias and Fehr, Marc and Poetzsch, Maik and Seipel, Sebastian},
 year={2024},
 url={https://github.com/bausteine-der-datenanalyse/a-energiedatenanalyse}} </code></pre>
</div>
<div style="page-break-after: always;"></div>
<section id="voraussetzungen" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> Voraussetzungen</h1>
<p>Die Bearbeitungszeit dieses Bausteins beträgt circa <strong>Platzhalter</strong>. Für die Bearbeitung dieses Bausteins werden folgende Bausteine vorausgesetzt und die genannten Bibliotheken verwendet:</p>
<ul>
<li><p>Werkzeugbaustein Python <strong>4 Links, 4 verschiedene Quellen</strong></p>
<ul>
<li><p>Modul <a href="https://docs.python.org/3/library/random.html">random</a></p></li>
<li><p>Modul <a href="https://pypi.org/project/pandas/">Pandas</a></p></li>
<li><p>Modul <a href="https://numpy.org/">NumPy</a></p></li>
<li><p>Modul <a href="https://matplotlib.org/3.5.3/api/_as_gen/matplotlib.pyplot.html">matplotlib.pyplot</a></p></li>
</ul></li>
<li><p>Methodenbaustein Einlesen strukturierter Datensätze</p></li>
</ul>
<p>Querverweis auf:</p>
<ul>
<li>Methodenbaustein Grundlagen der Statistik (Kapitel 2 einzelne Merkmale)</li>
</ul>
<p>Im Baustein werden Strommarktdaten für das Jahr 2023 verwendet. Daten für Deutschland werden von der Bundesnetzagentur bereitgestellt und sind unter <a href="https://www.smard.de/home/downloadcenter/download-marktdaten/">https://www.smard.de/</a> abrufbar. Daten für Österreich werden von der Austrian Power Grid AG bereitgestellt und sind unter <a href="https://markttransparenz.apg.at/de/markt/Markttransparenz/erzeugung/Erzeugung-pro-Typ">https://markttransparenz.apg.at/</a> abrufbar.</p>
</section>
<section id="lernziele" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> Lernziele</h1>
<p><strong>TO DO: ergänzen</strong></p>
<p>In diesen Baustein lernen Sie Methoden und Werkzeuge für die Energiedatenanalyse kennen. Die behandelten Methoden sind:</p>
<ul>
<li><p>beschreibende Datenananlyse</p></li>
<li><p>explorative Datenanalyse</p></li>
<li><p>schließende Datenanalyse</p></li>
</ul>
<p>Zu den vorgestellten Instrumenten gehören:</p>
<ul>
<li><p>Berechnung und Visualisierung einer sortierten Jahresdauerlinie</p></li>
<li><p>Berechnung der Residual- und Restlast</p></li>
<li><p>Grenzstromananalyse</p></li>
</ul>
<p>Einen inhaltlichen Schwerpunkt bilden Grundprinzipien und Verfahren zur Auslegung eines Stromspeichers.</p>
<ul>
<li>Einspeisung glätten (Speicherbedarf für jede EE bestimmen, damit diese konstant einspeisen)</li>
</ul>
<p><strong>Simones Skript als Quelle benennen und zitieren - ist Lukas auch Autor?</strong><br>
<span class="citation" data-cites="Arnold-2023-Strommarktdatenanalyse">(<a href="#ref-Arnold-2023-Strommarktdatenanalyse" role="doc-biblioref">Arnold 2023</a>)</span></p>
</section>
<section id="hintergrund" class="level1" data-number="3">
<h1 data-number="3"><span class="header-section-number">3</span> Hintergrund</h1>
<p>Elektrischer Strom wird in Kraftwerken erzeugt und über das Stromnetz zu den Stromverbrauchern transportiert. Stromerzeugung und -verbrauch müssen dabei immer ausgeglichen sein. Der Anteil wetterabhängiger erneuerbarer Einspeisung steigt, Strom kann bislang aber nicht (kostengünstig) großtechnisch gespeichert werden. 2023 speisten die Pumpspeicherkraftwerke in Deutschland bei einer Kapazität von 37,4 GWh <span class="citation" data-cites="Heimerl-Kohler-2017-Pumpspeicher-in-Deutschland">(<a href="#ref-Heimerl-Kohler-2017-Pumpspeicher-in-Deutschland" role="doc-biblioref">Heimerl und Kohler 2017, 77</a>)</span> 11,1 TWh Strom ein, was 2,4 Prozent des deutschen Stromverbrauchs von 458,3 TWh entsprach <span class="citation" data-cites="energy-charts-strom">(<a href="#ref-energy-charts-strom" role="doc-biblioref">Fraunhofer Institut für Solare Energiesysteme ISE o.&nbsp;J.</a>)</span>. Die Kraftwerkseinsatzplanung und Speicherauslegung auf Basis von Erzeugungs- und Verbrauchsdaten ist deshalb ein relevantes Anwendungsfeld für die Datenanalyse.<br>
Die Bundesnetzagentur veröffentlicht auf <a href="https://www.smard.de/home/downloadcenter/download-marktdaten/">https://www.smard.de/</a> unter anderem Daten zu Stromerzeugung, -verbrauch und Großhandelspreisen. (Hinweis: Kraftwerksdaten liegen für Erzeugungseinheiten mit einer installierten Erzeugungsleistung von mindestens 100 MW vor.)</p>
<p><strong>idealerweise werden die Konzepte anhand der Daten der FH gezeigt, und mit den SMARD-Daten beübt</strong></p>
</section>
<section id="daten-einlesen" class="level1" data-number="4">
<h1 data-number="4"><span class="header-section-number">4</span> Daten einlesen</h1>
<p>Die Strommarktdaten der Bundesnetzagentur müssen manuell auf <a href="https://www.smard.de/home/downloadcenter/download-marktdaten/">https://www.smard.de/</a> heruntergeladen werden. In diesem Skript werden Daten für das Jahr 2023 benutzt.</p>
<div style="font-size: 90%;">
<table class="table">
<colgroup>
<col style="width: 50%">
<col style="width: 50%">
</colgroup>
<thead>
<tr class="header">
<th>Daten</th>
<th>Dateiname</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Installierte Erzeugungsleistung 2023</td>
<td>Installierte_Erzeugungsleistung_202301010000_202401010000_Jahr.csv</td>
</tr>
<tr class="even">
<td>Realisierte Stromerzeugung 2023</td>
<td>Realisierte_Erzeugung_202301010000_202401010000_Viertelstunde.csv</td>
</tr>
<tr class="odd">
<td>Realisierter Stromverbrauch 2023</td>
<td>Realisierter_Stromverbrauch_202301010000_202401010000_Viertelstunde.csv</td>
</tr>
</tbody>
</table>
</div>
<div id="wrn-SMARD" class="callout callout-style-simple callout-warning callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-1-contents" aria-controls="callout-1" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Warning&nbsp;1: SMARD Daten herunterladen
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-1" class="callout-1-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<div>

</div>
<div class="quarto-layout-panel" data-layout="[[50, 50], [50, 50], [1]]">
<div class="quarto-layout-row">
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: flex-start;">
<p>Beim der Auswahl des Zeitraums auf Akzeptieren klicken.</p>
</div>
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: flex-start;">
<p>Daten zur installierten Leistung in Originalauflösung (Jahresbasis) auswählen.</p>
</div>
</div>
<div class="quarto-layout-row">
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="skript/00-bilder/smard-accept.png" class="img-fluid figure-img"></p>
<figcaption>&nbsp;</figcaption>
</figure>
</div>
</div>
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="skript/00-bilder/smard-installed-capacity-de.png" class="img-fluid figure-img"></p>
<figcaption>&nbsp;</figcaption>
</figure>
</div>
</div>
</div>
<div class="quarto-layout-row">
<div class="quarto-layout-cell" style="flex-basis: 100.0%;justify-content: flex-start;">
<p>Das Datumsformat der Dateien ist abhängig von der auf der Internetseite eingestellten Sprache (Deutsch/English).</p>
</div>
</div>
</div>
</div>
</div>
</div>
<p>Die semikolonseparierten Dateien werden als DataFrame mit dem Python Modul Pandas eingelesen, das mit dem Kürzel <code>pd</code> importiert wird. Dazu wird die Funktion <code>pd.read_csv()</code> verwendet. Dabei werden:</p>
<ul>
<li><p>das Wert-, Tausender- und Dezimaltrennzeichen spezifiziert.<br>
<code>sep = ";", thousands = ".", decimal = ","</code></p></li>
<li><p>die Spalten mit Datums- und Zeitangaben sowie das Datumsformat bestimmt.<br>
<code>parse_dates = [0, 1], date_format = "%d.%m.%Y %H:%M"</code></p></li>
</ul>
<div id="f6b7960d" class="cell" data-results="hold" data-execution_count="1">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>pd.set_option(<span class="st">"display.precision"</span>, <span class="dv">2</span>) <span class="co"># places after decimal for floats</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>installierte_leistung0 <span class="op">=</span> pd.read_csv(filepath_or_buffer <span class="op">=</span> <span class="op">\</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="st">"skript/01-daten/Installierte_Erzeugungsleistung_202301010000_202401010000_Jahr.csv"</span>, <span class="op">\</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>sep <span class="op">=</span> <span class="st">";"</span>, thousands <span class="op">=</span> <span class="st">"."</span>, decimal <span class="op">=</span> <span class="st">","</span>, <span class="op">\</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>parse_dates <span class="op">=</span> [<span class="dv">0</span>, <span class="dv">1</span>], date_format <span class="op">=</span> <span class="st">"</span><span class="sc">%d</span><span class="st">.%m.%Y"</span>)</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>erzeugung0 <span class="op">=</span> pd.read_csv(filepath_or_buffer <span class="op">=</span> <span class="op">\</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a><span class="st">"skript/01-daten/Realisierte_Erzeugung_202301010000_202401010000_Viertelstunde.csv"</span>, <span class="op">\</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>sep <span class="op">=</span> <span class="st">";"</span>, thousands <span class="op">=</span> <span class="st">"."</span>, decimal <span class="op">=</span> <span class="st">","</span>, <span class="op">\</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>parse_dates <span class="op">=</span> [<span class="dv">0</span>, <span class="dv">1</span>], date_format <span class="op">=</span> <span class="st">"</span><span class="sc">%d</span><span class="st">.%m.%Y %H:%M"</span>)</span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>verbrauch0 <span class="op">=</span> pd.read_csv(filepath_or_buffer <span class="op">=</span> <span class="op">\</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a><span class="st">"skript/01-daten/Realisierter_Stromverbrauch_202301010000_202401010000_Viertelstunde.csv"</span>, <span class="op">\</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>sep <span class="op">=</span> <span class="st">";"</span>, thousands <span class="op">=</span> <span class="st">"."</span>, decimal <span class="op">=</span> <span class="st">","</span>, <span class="op">\</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>parse_dates <span class="op">=</span> [<span class="dv">0</span>, <span class="dv">1</span>], date_format <span class="op">=</span> <span class="st">"</span><span class="sc">%d</span><span class="st">.%m.%Y %H:%M"</span>)</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Sehen Sie sich die Zeichenkette zur Spezifikation des Datumsformats an: <code>"%d.%m.%Y %H:%M"</code>. Können Sie anhand der <a href="https://docs.python.org/3/library/datetime.html#strftime-and-strptime-behavior">Dokumentation</a> bestimmen, welches Format die Datumsangaben in der Datei haben? Welches Format hat der 14. April 2023 um Viertel nach zwei nachmittags?</p>
<textarea id="“date-format”" name="“date-format”" rows="4" cols="80">Hier können Sie Ihre Antwort eingeben. Die Lösung finden Sie im Aufklapper.</textarea>
<p><strong>Aufgabe eher für m-Baustein Einlesen strukturierter Datensätze geeignet. Als Folgeaufgabe könnte man mit Hilfe der Dokumentation die englische Datei ‘Actual_generation_202301010000_202401010000_Quarterhour’ einlesen lassen.</strong></p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-3-contents" aria-controls="callout-3" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
english version
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-3" class="callout-3-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>english version</p>
<div id="a52dad42" class="cell" data-results="hold" data-execution_count="2">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>erzeugung0_en <span class="op">=</span> pd.read_csv(filepath_or_buffer <span class="op">=</span> <span class="op">\</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="st">"skript/01-daten/english/Actual_generation_202301010000_202401010000_Quarterhour.csv"</span>, <span class="op">\</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>sep <span class="op">=</span> <span class="st">";"</span>, thousands <span class="op">=</span> <span class="st">","</span>, decimal <span class="op">=</span> <span class="st">"."</span>, <span class="op">\</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>parse_dates <span class="op">=</span>  [<span class="dv">0</span>, <span class="dv">1</span>], date_format <span class="op">=</span> <span class="st">"%b </span><span class="sc">%d</span><span class="st">, %Y %I:%M %p"</span>) <span class="co"># leading zero is optional for formats %d, %m, %H, %I, %M, %S, %j, %U, %W, and %V</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>pd.concat([erzeugung0_en.head(<span class="dv">2</span>), erzeugung0_en.tail(<span class="dv">2</span>)])</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="2">
<div>
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">Start date</th>
<th data-quarto-table-cell-role="th">End date</th>
<th data-quarto-table-cell-role="th">Biomass [MWh] Original resolutions</th>
<th data-quarto-table-cell-role="th">Hydropower [MWh] Original resolutions</th>
<th data-quarto-table-cell-role="th">Wind offshore [MWh] Original resolutions</th>
<th data-quarto-table-cell-role="th">Wind onshore [MWh] Original resolutions</th>
<th data-quarto-table-cell-role="th">Photovoltaics [MWh] Original resolutions</th>
<th data-quarto-table-cell-role="th">Other renewable [MWh] Original resolutions</th>
<th data-quarto-table-cell-role="th">Nuclear [MWh] Original resolutions</th>
<th data-quarto-table-cell-role="th">Lignite [MWh] Original resolutions</th>
<th data-quarto-table-cell-role="th">Hard coal [MWh] Original resolutions</th>
<th data-quarto-table-cell-role="th">Fossil gas [MWh] Original resolutions</th>
<th data-quarto-table-cell-role="th">Hydro pumped storage [MWh] Original resolutions</th>
<th data-quarto-table-cell-role="th">Other conventional [MWh] Original resolutions</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>2023-01-01 00:00:00</td>
<td>2023-01-01 00:15:00</td>
<td>1094.25</td>
<td>320.0</td>
<td>684.25</td>
<td>7145.75</td>
<td>0.50</td>
<td>32.25</td>
<td>615.25</td>
<td>962.75</td>
<td>517.00</td>
<td>429.75</td>
<td>13.50</td>
<td>307.25</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>2023-01-01 00:15:00</td>
<td>2023-01-01 00:30:00</td>
<td>1091.25</td>
<td>317.5</td>
<td>743.50</td>
<td>7158.25</td>
<td>0.25</td>
<td>32.25</td>
<td>614.75</td>
<td>963.25</td>
<td>518.00</td>
<td>429.50</td>
<td>9.75</td>
<td>307.25</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">35038</td>
<td>2023-12-31 23:30:00</td>
<td>2023-12-31 23:45:00</td>
<td>1053.25</td>
<td>412.5</td>
<td>1479.25</td>
<td>7544.25</td>
<td>0.50</td>
<td>24.00</td>
<td>0.00</td>
<td>845.25</td>
<td>444.50</td>
<td>683.00</td>
<td>122.75</td>
<td>348.50</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">35039</td>
<td>2023-12-31 23:45:00</td>
<td>2024-01-01 00:00:00</td>
<td>1051.50</td>
<td>404.0</td>
<td>1469.00</td>
<td>7480.50</td>
<td>0.50</td>
<td>24.00</td>
<td>0.00</td>
<td>840.75</td>
<td>442.25</td>
<td>679.00</td>
<td>58.25</td>
<td>348.00</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
</div>
<div id="tip-date-format" class="callout callout-style-default callout-tip callout-titled" title="Solution date format">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-2-contents" aria-controls="callout-2" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip&nbsp;1: Solution date format
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-2" class="callout-2-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<table class="table">
<colgroup>
<col style="width: 50%">
<col style="width: 50%">
</colgroup>
<thead>
<tr class="header">
<th>Directive</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>%b</td>
<td>Month as locale’s abbreviated name (Jan, Feb, …) with delimiter ” ”</td>
</tr>
<tr class="even">
<td>%d</td>
<td>Day with delimiter “,&nbsp;”</td>
</tr>
<tr class="odd">
<td>%Y</td>
<td>Year as four digit decimal with delimiter ” ”</td>
</tr>
<tr class="even">
<td>%I:</td>
<td>Hour as two digit decimal (leading zero is optional) with delimiter “:”</td>
</tr>
<tr class="odd">
<td>%M</td>
<td>Minute as two digit decimal with delimiter ” ”</td>
</tr>
<tr class="even">
<td>%p</td>
<td>AM or PM</td>
</tr>
</tbody>
</table>
<p><strong>Solution:</strong> Apr 14, 2023 2:00 PM</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="tip-datumsformat" class="callout callout-style-default callout-tip callout-titled" title="Lösung Datumsformat">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-4-contents" aria-controls="callout-4" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip&nbsp;2: Lösung Datumsformat
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-4" class="callout-4-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<!-- Das Format ist in den englischen Dateien unterschiedlich! -->
<table class="table">
<thead>
<tr class="header">
<th>Kürzel</th>
<th>Bedeutung</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>%d.</td>
<td>Tag als zweistellige Ganzzahl mit Trennzeichen “.”</td>
</tr>
<tr class="even">
<td>%m.</td>
<td>Monat (ggf. mit führender Null) mit Trennzeichen “.”</td>
</tr>
<tr class="odd">
<td>%Y</td>
<td>Jahr als vierstellige Ganzzahl mit Trennzeichen ” ”</td>
</tr>
<tr class="even">
<td>%H:</td>
<td>Stunde als zweistellige Ganzzahl mit Trennzeichen “:”</td>
</tr>
<tr class="odd">
<td>%M</td>
<td>Minute als zweistellige Ganzzahl</td>
</tr>
</tbody>
</table>
<p><strong>Lösung</strong>: 14.04.2023 14:15</p>
</div>
</div>
</div>
</section>
<section id="daten-organisieren" class="level1" data-number="5">
<h1 data-number="5"><span class="header-section-number">5</span> Daten organisieren</h1>
<p>Vor der Datenanalyse sollte überprüft werden, ob die Daten korrekt eingelesen wurden. Dies bedeutet zum einen, zu kontrollieren, ob der Datentyp aller Spalten richtig erkannt wurde. Ob die Spaltentypen einer Datei korrekt eingelesen wurden, können Sie in Python mit dem Befehl <code>df.dtypes</code> überprüfen. Hier der Output des Befehls für den DataFrame <code>erzeugung0</code>.</p>
<div id="8771a1ef" class="cell" data-results="hold" data-execution_count="3">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Spalten:</span><span class="ch">\n</span><span class="sc">{</span>erzeugung0<span class="sc">.</span>dtypes<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Spalten:
Datum von                                            datetime64[ns]
Datum bis                                            datetime64[ns]
Biomasse [MWh] Originalauflösungen                          float64
Wasserkraft [MWh] Originalauflösungen                       float64
Wind Offshore [MWh] Originalauflösungen                     float64
Wind Onshore [MWh] Originalauflösungen                      float64
Photovoltaik [MWh] Originalauflösungen                      float64
Sonstige Erneuerbare [MWh] Originalauflösungen              float64
Kernenergie [MWh] Originalauflösungen                       float64
Braunkohle [MWh] Originalauflösungen                        float64
Steinkohle [MWh] Originalauflösungen                        float64
Erdgas [MWh] Originalauflösungen                            float64
Pumpspeicher [MWh] Originalauflösungen                      float64
Sonstige Konventionelle [MWh] Originalauflösungen           float64
dtype: object</code></pre>
</div>
</div>
<p>&nbsp;</p>
<p>Viele der Spaltennamen enthalten die Zeichenkette ” Originalauflösungen”, die der Übersichtlichkeit wegen entfernt werden kann (führendes Leerzeichen beachten). Auf diese Weise könnte auch die Einheitenangabe [MWh] entfernt werden, falls diese als störend empfunden wird.</p>
<div id="e181d395" class="cell" data-results="hold" data-execution_count="4">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Zeichenkette " Originalauflösungen" entfernen</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>installierte_leistung0.columns <span class="op">=</span> installierte_leistung0.columns.<span class="bu">str</span>.replace(pat <span class="op">=</span> <span class="st">" Originalauflösungen"</span>, repl <span class="op">=</span> <span class="st">""</span>)</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>erzeugung0.columns <span class="op">=</span> erzeugung0.columns.<span class="bu">str</span>.replace(pat <span class="op">=</span> <span class="st">" Originalauflösungen"</span>, repl <span class="op">=</span> <span class="st">""</span>)</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Spalten:</span><span class="ch">\n</span><span class="sc">{</span>erzeugung0<span class="sc">.</span>dtypes<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>verbrauch0.columns <span class="op">=</span> verbrauch0.columns.<span class="bu">str</span>.replace(pat <span class="op">=</span> <span class="st">" Originalauflösungen"</span>, repl <span class="op">=</span> <span class="st">""</span>)</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Spalten:
Datum von                        datetime64[ns]
Datum bis                        datetime64[ns]
Biomasse [MWh]                          float64
Wasserkraft [MWh]                       float64
Wind Offshore [MWh]                     float64
Wind Onshore [MWh]                      float64
Photovoltaik [MWh]                      float64
Sonstige Erneuerbare [MWh]              float64
Kernenergie [MWh]                       float64
Braunkohle [MWh]                        float64
Steinkohle [MWh]                        float64
Erdgas [MWh]                            float64
Pumpspeicher [MWh]                      float64
Sonstige Konventionelle [MWh]           float64
dtype: object</code></pre>
</div>
</div>
<p>&nbsp;</p>
<p>Zum anderen sollten die eingelesenen Daten betrachtet werden, um Fehler etwa bei der Umwandlung von Dezimal- und Tausendertrennzeichen, des Datumsformats oder eine unerwartete Anzahl fehlender Werte und sonstige Auffälligkeiten zu identifizieren. Dazu sollten nicht nur die ersten Zeilen des Datensatzes, sondern auch Ausschnitte aus der Mitte und dem Ende kontrolliert werden. Dafür ist der Befehl <code>pd.concat([a, b, c])</code> nützlich, dem eine Liste von Indexbereichen übergeben werden kann (siehe zweiter und dritter Reiter im folgenden Panel).</p>
<div class="tabset-margin-container"></div><div class="panel-tabset">
<ul class="nav nav-tabs" role="tablist"><li class="nav-item" role="presentation"><a class="nav-link active" id="tabset-1-1-tab" data-bs-toggle="tab" data-bs-target="#tabset-1-1" role="tab" aria-controls="tabset-1-1" aria-selected="true" href="">installierte Leistung</a></li><li class="nav-item" role="presentation"><a class="nav-link" id="tabset-1-2-tab" data-bs-toggle="tab" data-bs-target="#tabset-1-2" role="tab" aria-controls="tabset-1-2" aria-selected="false" href="">realisierte Erzeugung</a></li><li class="nav-item" role="presentation"><a class="nav-link" id="tabset-1-3-tab" data-bs-toggle="tab" data-bs-target="#tabset-1-3" role="tab" aria-controls="tabset-1-3" aria-selected="false" href="">realisierter Verbrauch</a></li></ul>
<div class="tab-content">
<div id="tabset-1-1" class="tab-pane active" role="tabpanel" aria-labelledby="tabset-1-1-tab">
<div id="5f295791" class="cell" data-results="hold" data-execution_count="5">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co"># der DataFrame installierte_leistung0 hat nur 1 Zeile</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>installierte_leistung0</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="5">
<div>
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">Datum von</th>
<th data-quarto-table-cell-role="th">Datum bis</th>
<th data-quarto-table-cell-role="th">Biomasse [MW]</th>
<th data-quarto-table-cell-role="th">Wasserkraft [MW]</th>
<th data-quarto-table-cell-role="th">Wind Offshore [MW]</th>
<th data-quarto-table-cell-role="th">Wind Onshore [MW]</th>
<th data-quarto-table-cell-role="th">Photovoltaik [MW]</th>
<th data-quarto-table-cell-role="th">Sonstige Erneuerbare [MW]</th>
<th data-quarto-table-cell-role="th">Kernenergie [MW]</th>
<th data-quarto-table-cell-role="th">Braunkohle [MW]</th>
<th data-quarto-table-cell-role="th">Steinkohle [MW]</th>
<th data-quarto-table-cell-role="th">Erdgas [MW]</th>
<th data-quarto-table-cell-role="th">Pumpspeicher [MW]</th>
<th data-quarto-table-cell-role="th">Sonstige Konventionelle [MW]</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>2023-01-01</td>
<td>2024-01-01</td>
<td>8467.0</td>
<td>5049.0</td>
<td>8129.0</td>
<td>57590.0</td>
<td>63066.0</td>
<td>440.0</td>
<td>4056.0</td>
<td>17692.0</td>
<td>18127.0</td>
<td>31808.0</td>
<td>9379.0</td>
<td>8958.0</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
</div>
</div>
<div id="tabset-1-2" class="tab-pane" role="tabpanel" aria-labelledby="tabset-1-2-tab">
<div id="12bcb8d8" class="cell" data-results="hold" data-execution_count="6">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>pd.concat([erzeugung0.head(<span class="dv">2</span>), <span class="op">\</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>erzeugung0.iloc[<span class="bu">len</span>(erzeugung0)<span class="op">//</span><span class="dv">2</span>:(<span class="bu">len</span>(erzeugung0)<span class="op">//</span><span class="dv">2</span><span class="op">+</span><span class="dv">2</span>)], <span class="op">\</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>erzeugung0.tail(<span class="dv">2</span>)])</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="6">
<div>
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">Datum von</th>
<th data-quarto-table-cell-role="th">Datum bis</th>
<th data-quarto-table-cell-role="th">Biomasse [MWh]</th>
<th data-quarto-table-cell-role="th">Wasserkraft [MWh]</th>
<th data-quarto-table-cell-role="th">Wind Offshore [MWh]</th>
<th data-quarto-table-cell-role="th">Wind Onshore [MWh]</th>
<th data-quarto-table-cell-role="th">Photovoltaik [MWh]</th>
<th data-quarto-table-cell-role="th">Sonstige Erneuerbare [MWh]</th>
<th data-quarto-table-cell-role="th">Kernenergie [MWh]</th>
<th data-quarto-table-cell-role="th">Braunkohle [MWh]</th>
<th data-quarto-table-cell-role="th">Steinkohle [MWh]</th>
<th data-quarto-table-cell-role="th">Erdgas [MWh]</th>
<th data-quarto-table-cell-role="th">Pumpspeicher [MWh]</th>
<th data-quarto-table-cell-role="th">Sonstige Konventionelle [MWh]</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>2023-01-01 00:00:00</td>
<td>2023-01-01 00:15:00</td>
<td>1094.25</td>
<td>320.0</td>
<td>684.25</td>
<td>7145.75</td>
<td>0.50</td>
<td>32.25</td>
<td>615.25</td>
<td>962.75</td>
<td>517.00</td>
<td>429.75</td>
<td>13.50</td>
<td>307.25</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>2023-01-01 00:15:00</td>
<td>2023-01-01 00:30:00</td>
<td>1091.25</td>
<td>317.5</td>
<td>743.50</td>
<td>7158.25</td>
<td>0.25</td>
<td>32.25</td>
<td>614.75</td>
<td>963.25</td>
<td>518.00</td>
<td>429.50</td>
<td>9.75</td>
<td>307.25</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">17520</td>
<td>2023-07-02 13:00:00</td>
<td>2023-07-02 13:15:00</td>
<td>955.25</td>
<td>317.5</td>
<td>736.00</td>
<td>4228.50</td>
<td>6832.75</td>
<td>25.25</td>
<td>0.00</td>
<td>795.00</td>
<td>216.75</td>
<td>546.00</td>
<td>0.75</td>
<td>264.75</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">17521</td>
<td>2023-07-02 13:15:00</td>
<td>2023-07-02 13:30:00</td>
<td>956.75</td>
<td>321.5</td>
<td>693.75</td>
<td>3885.25</td>
<td>6961.25</td>
<td>25.25</td>
<td>0.00</td>
<td>791.00</td>
<td>215.00</td>
<td>545.00</td>
<td>0.00</td>
<td>266.00</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">35038</td>
<td>2023-12-31 23:30:00</td>
<td>2023-12-31 23:45:00</td>
<td>1053.25</td>
<td>412.5</td>
<td>1479.25</td>
<td>7544.25</td>
<td>0.50</td>
<td>24.00</td>
<td>0.00</td>
<td>845.25</td>
<td>444.50</td>
<td>683.00</td>
<td>122.75</td>
<td>348.50</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">35039</td>
<td>2023-12-31 23:45:00</td>
<td>2024-01-01 00:00:00</td>
<td>1051.50</td>
<td>404.0</td>
<td>1469.00</td>
<td>7480.50</td>
<td>0.50</td>
<td>24.00</td>
<td>0.00</td>
<td>840.75</td>
<td>442.25</td>
<td>679.00</td>
<td>58.25</td>
<td>348.00</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
</div>
</div>
<div id="tabset-1-3" class="tab-pane" role="tabpanel" aria-labelledby="tabset-1-3-tab">
<div id="89493a5a" class="cell" data-results="hold" data-execution_count="7">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>pd.concat([verbrauch0.head(<span class="dv">2</span>), <span class="op">\</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>verbrauch0.iloc[<span class="bu">len</span>(verbrauch0)<span class="op">//</span><span class="dv">2</span>:(<span class="bu">len</span>(verbrauch0)<span class="op">//</span><span class="dv">2</span><span class="op">+</span><span class="dv">2</span>)], <span class="op">\</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>verbrauch0.tail(<span class="dv">2</span>)])</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="7">
<div>
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">Datum von</th>
<th data-quarto-table-cell-role="th">Datum bis</th>
<th data-quarto-table-cell-role="th">Gesamt (Netzlast) [MWh]</th>
<th data-quarto-table-cell-role="th">Residuallast [MWh]</th>
<th data-quarto-table-cell-role="th">Pumpspeicher [MWh]</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>2023-01-01 00:00:00</td>
<td>2023-01-01 00:15:00</td>
<td>9720.75</td>
<td>1890.25</td>
<td>424.75</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>2023-01-01 00:15:00</td>
<td>2023-01-01 00:30:00</td>
<td>9641.25</td>
<td>1739.25</td>
<td>443.50</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">17520</td>
<td>2023-07-02 13:00:00</td>
<td>2023-07-02 13:15:00</td>
<td>11564.00</td>
<td>-233.25</td>
<td>1147.75</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">17521</td>
<td>2023-07-02 13:15:00</td>
<td>2023-07-02 13:30:00</td>
<td>11536.25</td>
<td>-4.00</td>
<td>1223.25</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">35038</td>
<td>2023-12-31 23:30:00</td>
<td>2023-12-31 23:45:00</td>
<td>10495.75</td>
<td>1471.75</td>
<td>470.00</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">35039</td>
<td>2023-12-31 23:45:00</td>
<td>2024-01-01 00:00:00</td>
<td>10289.25</td>
<td>1339.25</td>
<td>528.00</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
</div>
</div>
</div>
</div>
<p>&nbsp;</p>
<p>Schließlich ist eine Plausibilitätskontrolle der Daten sinnvoll. Einleitend wurde der deutsche Gesamtstromverbrauch im Jahr 2023 genannt, der 458,3 TWh beträgt. Der Stromverbrauch und die Summe der Stromerzeugung sollten diesem Wert ungefähr entsprechen.</p>
<div id="d3b36097" class="cell" data-execution_count="8">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="co"># exclude columns with datetime</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Stromverbrauch in Millionen MWh:</span><span class="ch">\n</span><span class="st">"</span>, <span class="op">\</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>verbrauch0.<span class="bu">sum</span>(numeric_only <span class="op">=</span> <span class="va">True</span>) <span class="op">//</span> (<span class="dv">1000</span> <span class="op">*</span> <span class="dv">1000</span>), sep <span class="op">=</span> <span class="st">""</span>)</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">Stromerzeugung in Millionen MWh"</span>, <span class="op">\</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>erzeugung0.<span class="bu">sum</span>(numeric_only <span class="op">=</span> <span class="va">True</span>).<span class="bu">sum</span>() <span class="op">//</span> (<span class="dv">1000</span> <span class="op">*</span> <span class="dv">1000</span>))</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Stromverbrauch in Millionen MWh:
Gesamt (Netzlast) [MWh]    458.0
Residuallast [MWh]         260.0
Pumpspeicher [MWh]          14.0
dtype: float64

Stromerzeugung in Millionen MWh 448.0</code></pre>
</div>
</div>
<p>&nbsp;</p>
<p>Wenn alle Dateien korrekt eingelesen wurden, können Arbeitsdateien mit dem Befehl <code>df.copy()</code> angelegt werden. Dadurch bleiben die Rohdaten immer verfügbar und können bei Bedarf, beispielsweise nach einem versehentlichen Überschreiben der Arbeitsdateien, erneut geladen werden.</p>
<div id="637781a3" class="cell" data-results="hold" data-execution_count="9">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>erzeugung <span class="op">=</span> erzeugung0.copy()</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>verbrauch <span class="op">=</span> verbrauch0.copy()</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>installierte_leistung <span class="op">=</span> installierte_leistung0.copy()</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="beschreibende-datenanalyse" class="level1" data-number="6">
<h1 data-number="6"><span class="header-section-number">6</span> Beschreibende Datenanalyse</h1>
<p>Mit Methoden der beschreibenden Statistik kann ein Überblick über die Datensätze und die Daten gewonnen werden. Dieser Schritt dient insbesondere auch dazu, mögliche Fehler und Auffälligkeiten im Datensatz zu identifizieren. Hierbei gewonnene Befunde können im der folgenden explorativen und schließenden Datenanalyse vertieft werden.</p>
<p>Einen ersten Überblick über die Daten liefert die Methode <code>pd.DataFrame.describe()</code>. Durch das Argument <code>include = [np.number]</code> kann die Ausgabe auf Spalten mit numerischen Daten beschränkt werden, das heißt, die Spalten mit Datumsinformationen werden ausgeschlossen.</p>
<div id="129adcb0" class="cell" data-results="hold" data-execution_count="10">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Der DataFrame erzeugung hat </span><span class="sc">{</span>erzeugung<span class="sc">.</span>shape[<span class="dv">0</span>]<span class="sc">}</span><span class="ss"> Zeilen und </span><span class="sc">{</span>erzeugung<span class="sc">.</span>shape[<span class="dv">1</span>]<span class="sc">}</span><span class="ss"> Spalten.</span><span class="ch">\n</span><span class="ss">"</span>)</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>erzeugung.describe(include <span class="op">=</span> [np.number])</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Der DataFrame erzeugung hat 35040 Zeilen und 14 Spalten.
</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="10">
<div>
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">Biomasse [MWh]</th>
<th data-quarto-table-cell-role="th">Wasserkraft [MWh]</th>
<th data-quarto-table-cell-role="th">Wind Offshore [MWh]</th>
<th data-quarto-table-cell-role="th">Wind Onshore [MWh]</th>
<th data-quarto-table-cell-role="th">Photovoltaik [MWh]</th>
<th data-quarto-table-cell-role="th">Sonstige Erneuerbare [MWh]</th>
<th data-quarto-table-cell-role="th">Kernenergie [MWh]</th>
<th data-quarto-table-cell-role="th">Braunkohle [MWh]</th>
<th data-quarto-table-cell-role="th">Steinkohle [MWh]</th>
<th data-quarto-table-cell-role="th">Erdgas [MWh]</th>
<th data-quarto-table-cell-role="th">Pumpspeicher [MWh]</th>
<th data-quarto-table-cell-role="th">Sonstige Konventionelle [MWh]</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">count</td>
<td>35040.00</td>
<td>35040.00</td>
<td>35040.00</td>
<td>35040.00</td>
<td>35040.00</td>
<td>35040.00</td>
<td>35040.00</td>
<td>35040.00</td>
<td>35040.00</td>
<td>35040.00</td>
<td>35040.00</td>
<td>35040.00</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">mean</td>
<td>1079.50</td>
<td>411.50</td>
<td>671.23</td>
<td>3389.91</td>
<td>1590.11</td>
<td>33.32</td>
<td>192.37</td>
<td>2221.58</td>
<td>1134.42</td>
<td>1431.02</td>
<td>318.19</td>
<td>330.81</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">std</td>
<td>80.16</td>
<td>83.08</td>
<td>457.65</td>
<td>2627.46</td>
<td>2470.00</td>
<td>7.69</td>
<td>305.80</td>
<td>939.80</td>
<td>838.85</td>
<td>682.72</td>
<td>425.94</td>
<td>39.99</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">min</td>
<td>892.50</td>
<td>249.75</td>
<td>0.00</td>
<td>30.25</td>
<td>0.25</td>
<td>21.75</td>
<td>0.00</td>
<td>634.25</td>
<td>170.25</td>
<td>373.00</td>
<td>0.00</td>
<td>208.50</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">25%</td>
<td>1017.50</td>
<td>334.00</td>
<td>259.00</td>
<td>1237.25</td>
<td>0.50</td>
<td>25.50</td>
<td>0.00</td>
<td>1396.25</td>
<td>506.75</td>
<td>893.25</td>
<td>38.00</td>
<td>304.50</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">50%</td>
<td>1066.75</td>
<td>420.50</td>
<td>612.25</td>
<td>2657.00</td>
<td>24.88</td>
<td>32.50</td>
<td>0.00</td>
<td>2111.25</td>
<td>814.75</td>
<td>1300.00</td>
<td>110.75</td>
<td>337.00</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">75%</td>
<td>1133.25</td>
<td>481.00</td>
<td>1040.56</td>
<td>5017.19</td>
<td>2466.50</td>
<td>39.25</td>
<td>535.00</td>
<td>3000.31</td>
<td>1501.00</td>
<td>1810.75</td>
<td>443.00</td>
<td>356.00</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">max</td>
<td>1293.25</td>
<td>618.25</td>
<td>1910.00</td>
<td>12039.50</td>
<td>10361.25</td>
<td>51.25</td>
<td>771.00</td>
<td>4121.75</td>
<td>3814.00</td>
<td>4169.25</td>
<td>2399.00</td>
<td>512.50</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
</div>
<p><strong>To Do: value.counts</strong></p>
<p>&nbsp;</p>
<p>Aus der beschreibenden Statistik der Daten kann beispielsweise entnommen werden, dass Onshore Wind den größten Beitrag zur Stromerzeugung lieferte. Ebenfalls ist auffällig, dass weder Onshore Wind noch Photovoltaik eine minimale Erzeugung von 0 aufweisen, was jedoch für Wind Offshore und Kernenergie der Fall ist.<br>
<strong>Warum ist das bei Photovoltaik so? – Simone fragt nach. In Österreich ist das nicht der Fall!</strong></p>
<section id="ablesen-ist-pfui-visualisieren-ist-hui-arbeitstitel" class="level2" data-number="6.1">
<h2 data-number="6.1" class="anchored" data-anchor-id="ablesen-ist-pfui-visualisieren-ist-hui-arbeitstitel"><span class="header-section-number">6.1</span> Ablesen ist pfui, visualisieren ist hui (Arbeitstitel)</h2>
<p>Die Auswertung der beschreibenden Statistik für 12 verschiedene Erzeugungsformen erfordert jedoch Konzentration. Komplexe Informationen sollten deshalb grafisch aufbereitet werden.</p>
<p>Einen schnellen Überblick beispielsweise über die Verteilung der Gesamterzeugungsleistung nach Erzeugungsart verschafft ein Kreis- bzw. Ringdiagramm. Allerdings hat dieser Diagrammtyp, wie im <strong>Methodenbaustein Grundlagen der Statistik (Kapitel 2 einzelne Merkmale)</strong> erläutert, den Nachteil, dass dieser mit steigender Anzahl von Merkmalsausprägungen (bzw. hier darzustellenden Merkmalen) schnell unübersichtlich wird und Winkel kaum exakt abgelesen werden können.</p>
<p>Im folgenden, mit der Methode <code>pd.DataFrame.plot.pie()</code> erstellten Ringdiagramm wurde deshalb zum einen die automatische Annotation der Anteilswerte mit dem entsprechenden Formatierungsstring <code>autopct='%1.1f%%'</code> aktiviert. Zum anderen wurde die Reihenfolge der Spalten im DataFrame getauscht, da sich die Prozentangaben und Beschriftungen kleiner Kreissegmente andernfalls überlappen. Außerdem wurde für die Beschriftung der Segmente die Zeichkette ” [MWh]” aus den Spaltennamen gekürzt. Dies verbessert zwar die Lesbarkeit des Diagramms. Das ist aber nicht der Grund, weshalb die Zeichenkette entfernt wurde. <strong>Was denken Sie, was der Grund dafür ist?</strong></p>
<div id="tip-Ringdiagramm" class="callout callout-style-default callout-tip callout-titled" title="Lösung Kreisdiagramm">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-5-contents" aria-controls="callout-5" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip&nbsp;3: Lösung Kreisdiagramm
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-5" class="callout-5-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>Das Kreis- bzw. Ringdiagramm stellt Anteilswerte dar und ist deshalb einheitenlos.</p>
</div>
</div>
</div>
<p>Die Details der Ploterstellung können Sie dem zweiten Reiter entnehmen.</p>
<div class="tabset-margin-container"></div><div class="panel-tabset">
<ul class="nav nav-tabs" role="tablist"><li class="nav-item" role="presentation"><a class="nav-link active" id="tabset-2-1-tab" data-bs-toggle="tab" data-bs-target="#tabset-2-1" role="tab" aria-controls="tabset-2-1" aria-selected="true" href="">Plotten mit Pandas</a></li><li class="nav-item" role="presentation"><a class="nav-link" id="tabset-2-2-tab" data-bs-toggle="tab" data-bs-target="#tabset-2-2" role="tab" aria-controls="tabset-2-2" aria-selected="false" href="">Code für Pandas</a></li></ul>
<div class="tab-content">
<div id="tabset-2-1" class="tab-pane active" role="tabpanel" aria-labelledby="tabset-2-1-tab">
<div id="8376dfd8" class="cell" data-results="hold" data-execution_count="11">
<div class="cell-output cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="Energiedatenauswertung_files/figure-html/cell-12-output-1.png" width="462" height="389" class="figure-img"></p>
<figcaption>Anteil an der Stromerzeugung</figcaption>
</figure>
</div>
</div>
</div>
</div>
<div id="tabset-2-2" class="tab-pane" role="tabpanel" aria-labelledby="tabset-2-2-tab">
<div id="d3164e4f" class="cell" data-results="hold" data-execution_count="12">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="co"># plot the pie first try - Sonstige Erneuerbare [MWh] overlaps wih Kernenergie [MWh] and Pumpsicher [MWh]</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="co"># erzeugung.sum(numeric_only = True).plot.pie(colormap = "Blues", startangle = 90, rotatelabels = True, explode = explosion)</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a><span class="co"># rearrange columns, remove " [MWh]"</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>plotting_data <span class="op">=</span> erzeugung.copy()</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>column_to_move <span class="op">=</span> plotting_data.pop(<span class="st">"Kernenergie [MWh]"</span>)</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>plotting_data.insert(<span class="dv">4</span>, <span class="st">"Kernenergie [MWh]"</span>, column_to_move)</span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>column_to_move <span class="op">=</span> plotting_data.pop(<span class="st">"Pumpspeicher [MWh]"</span>)</span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>plotting_data.insert(<span class="dv">10</span>, <span class="st">"Pumpspeicher [MWh]"</span>, column_to_move)</span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a>plotting_data.columns <span class="op">=</span> plotting_data.columns.<span class="bu">str</span>.replace(pat <span class="op">=</span> <span class="st">" [MWh]"</span>, repl <span class="op">=</span> <span class="st">""</span>)</span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a><span class="co"># plot the pie</span></span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> plotting_data.<span class="bu">sum</span>(numeric_only <span class="op">=</span> <span class="va">True</span>).plot.pie(colormap <span class="op">=</span> <span class="st">"Blues"</span>, startangle <span class="op">=</span> <span class="dv">90</span>, rotatelabels <span class="op">=</span> <span class="va">False</span>, autopct<span class="op">=</span><span class="st">'</span><span class="sc">%1.1f%%</span><span class="st">'</span>, pctdistance <span class="op">=</span> <span class="fl">0.6</span>, textprops <span class="op">=</span> <span class="bu">dict</span>(size <span class="op">=</span> <span class="dv">7</span>, color <span class="op">=</span> <span class="st">'black'</span>), wedgeprops <span class="op">=</span> {<span class="st">"linewidth"</span>: <span class="fl">0.5</span>, <span class="st">"edgecolor"</span>: <span class="st">"white"</span>})</span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true" tabindex="-1"></a><span class="co"># make a donut</span></span>
<span id="cb16-18"><a href="#cb16-18" aria-hidden="true" tabindex="-1"></a>my_axis <span class="op">=</span> plt.gca() <span class="co"># plt.gca = get current axis</span></span>
<span id="cb16-19"><a href="#cb16-19" aria-hidden="true" tabindex="-1"></a>circle <span class="op">=</span> plt.Circle((<span class="dv">0</span>, <span class="dv">0</span>), radius <span class="op">=</span> <span class="fl">0.7</span>, color <span class="op">=</span> <span class="st">"white"</span>)</span>
<span id="cb16-20"><a href="#cb16-20" aria-hidden="true" tabindex="-1"></a>ax.add_patch(circle)</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
</div>
</div>
<p><strong>wird <code>my_axis = plt.gca()</code> überhaupt benötigt?</strong> ### Daten aggregieren</p>
<p>Aufgrund der zahlreichen Merkmale erschließt sich aus der deskriptiven und visuellen Beschreibung der Erzeugungsleistung nicht unbedingt ein prägnanter Befund. Eine Möglichkeit, um Daten besser zu verstehen, besteht darin, ähnliche Merkmale zusammenzufassen. Im Folgenden werden erneuerbare und konventionelle (mit fossilen Brennstoffen betriebene) Erzeugungsarten für die Darstellung der Anteilswerte in einem Ringdiagramm zusammengefasst. Beide Gruppen werden zusätzlich in einem Balkendiagramm dargestellt. Für die Darstellung wird das Modul <code>matplotlib.pyplot</code> verwendet. Die Details der Ploterstellung können Sie dem zweiten Reiter entnehmen. <strong>Marc fragen, ob er Erläuterungen zum Plot wünscht.</strong></p>
<div class="tabset-margin-container"></div><div class="panel-tabset">
<ul class="nav nav-tabs" role="tablist"><li class="nav-item" role="presentation"><a class="nav-link active" id="tabset-3-1-tab" data-bs-toggle="tab" data-bs-target="#tabset-3-1" role="tab" aria-controls="tabset-3-1" aria-selected="true" href="">Plotten mit matplotlib</a></li><li class="nav-item" role="presentation"><a class="nav-link" id="tabset-3-2-tab" data-bs-toggle="tab" data-bs-target="#tabset-3-2" role="tab" aria-controls="tabset-3-2" aria-selected="false" href="">Code für matplotlib</a></li></ul>
<div class="tab-content">
<div id="tabset-3-1" class="tab-pane active" role="tabpanel" aria-labelledby="tabset-3-1-tab">
<div id="4f1828a0" class="cell" data-results="hold" data-execution_count="13">
<div class="cell-output cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="Energiedatenauswertung_files/figure-html/cell-14-output-1.png" width="710" height="710" class="figure-img"></p>
<figcaption>Absolute Stromerzeugung und relative Anteile nach Erzeugungstyp</figcaption>
</figure>
</div>
</div>
</div>
</div>
<div id="tabset-3-2" class="tab-pane" role="tabpanel" aria-labelledby="tabset-3-2-tab">
<div id="381ee07a" class="cell" data-results="hold" data-execution_count="14">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Erneuerbare und Konventionelle bestimmen, jeweils summieren</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a><span class="co">## Erneuerbare</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>plotting_data <span class="op">=</span> erzeugung.copy()</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>plotting_data.drop(columns <span class="op">=</span> [<span class="st">'Datum von'</span>, <span class="st">'Datum bis'</span>, <span class="st">'Biomasse [MWh]'</span>, <span class="st">'Wasserkraft [MWh]'</span>, <span class="st">'Wind Offshore [MWh]'</span>,</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a><span class="st">'Wind Onshore [MWh]'</span>, <span class="st">'Photovoltaik [MWh]'</span>,</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a><span class="st">'Sonstige Erneuerbare [MWh]'</span>], inplace <span class="op">=</span> <span class="va">True</span>) <span class="co"># Datumsspalten entfernen, inplace = False liefert eine Kopie und tut deshalb ohne Objektzuweisung 'nichts'</span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>erneuerbare <span class="op">=</span> [<span class="st">'Biomasse [MWh]'</span>, <span class="st">'Wasserkraft [MWh]'</span>, <span class="st">'Wind Offshore [MWh]'</span>, <span class="st">'Wind Onshore [MWh]'</span>, <span class="st">'Photovoltaik [MWh]'</span>,</span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a><span class="st">'Sonstige Erneuerbare [MWh]'</span>]</span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>plotting_data[<span class="st">"Erneuerbare"</span>] <span class="op">=</span> erzeugung[erneuerbare].<span class="bu">sum</span>(axis <span class="op">=</span> <span class="st">'columns'</span>)</span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a><span class="co">## Konventionelle</span></span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a>plotting_data.drop(columns <span class="op">=</span> [<span class="st">'Braunkohle [MWh]'</span>,  <span class="st">'Steinkohle [MWh]'</span>, <span class="st">'Erdgas [MWh]'</span>, <span class="st">'Sonstige Konventionelle [MWh]'</span>], inplace <span class="op">=</span> <span class="va">True</span>)</span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a>konventionelle <span class="op">=</span> [<span class="st">'Braunkohle [MWh]'</span>,  <span class="st">'Steinkohle [MWh]'</span>, <span class="st">'Erdgas [MWh]'</span>, <span class="st">'Sonstige Konventionelle [MWh]'</span>]</span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a>plotting_data[<span class="st">"Konventionelle"</span>] <span class="op">=</span> erzeugung[konventionelle].<span class="bu">sum</span>(axis <span class="op">=</span> <span class="st">'columns'</span>)</span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true" tabindex="-1"></a><span class="co"># rearrange columns, remove " [MWh]"</span></span>
<span id="cb17-18"><a href="#cb17-18" aria-hidden="true" tabindex="-1"></a>plotting_data <span class="op">=</span> plotting_data[[<span class="st">'Erneuerbare'</span>, <span class="st">'Pumpspeicher [MWh]'</span>, <span class="st">'Konventionelle'</span>, <span class="st">'Kernenergie [MWh]'</span>]]</span>
<span id="cb17-19"><a href="#cb17-19" aria-hidden="true" tabindex="-1"></a>plotting_data.columns <span class="op">=</span> plotting_data.columns.<span class="bu">str</span>.replace(pat <span class="op">=</span> <span class="st">" [MWh]"</span>, repl <span class="op">=</span> <span class="st">""</span>)</span>
<span id="cb17-20"><a href="#cb17-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-21"><a href="#cb17-21" aria-hidden="true" tabindex="-1"></a><span class="co"># zur Kontrolle - axis = columns addiert die Spalten zeilenweise</span></span>
<span id="cb17-22"><a href="#cb17-22" aria-hidden="true" tabindex="-1"></a><span class="co">## print(erneuerbare)</span></span>
<span id="cb17-23"><a href="#cb17-23" aria-hidden="true" tabindex="-1"></a><span class="co">## print(erzeugung[erneuerbare].sum(axis = 'columns'))</span></span>
<span id="cb17-24"><a href="#cb17-24" aria-hidden="true" tabindex="-1"></a><span class="co">## print(plotting_data.columns)</span></span>
<span id="cb17-25"><a href="#cb17-25" aria-hidden="true" tabindex="-1"></a><span class="co">## print(plotting_data[0:3])</span></span>
<span id="cb17-26"><a href="#cb17-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-27"><a href="#cb17-27" aria-hidden="true" tabindex="-1"></a><span class="co"># Grafik mit drei subplots erzeugen</span></span>
<span id="cb17-28"><a href="#cb17-28" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize <span class="op">=</span> (<span class="fl">7.5</span>, <span class="fl">7.5</span>))</span>
<span id="cb17-29"><a href="#cb17-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-30"><a href="#cb17-30" aria-hidden="true" tabindex="-1"></a>nrows <span class="op">=</span> <span class="dv">4</span></span>
<span id="cb17-31"><a href="#cb17-31" aria-hidden="true" tabindex="-1"></a>ncols <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb17-32"><a href="#cb17-32" aria-hidden="true" tabindex="-1"></a>font_size <span class="op">=</span> <span class="dv">8</span></span>
<span id="cb17-33"><a href="#cb17-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-34"><a href="#cb17-34" aria-hidden="true" tabindex="-1"></a><span class="co"># value for shared x-axis on barplots</span></span>
<span id="cb17-35"><a href="#cb17-35" aria-hidden="true" tabindex="-1"></a>x_lim <span class="op">=</span> erzeugung.<span class="bu">sum</span>(numeric_only <span class="op">=</span> <span class="va">True</span>).<span class="bu">max</span>() <span class="op">*</span> <span class="fl">1.1</span></span>
<span id="cb17-36"><a href="#cb17-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-37"><a href="#cb17-37" aria-hidden="true" tabindex="-1"></a><span class="co"># array of colors</span></span>
<span id="cb17-38"><a href="#cb17-38" aria-hidden="true" tabindex="-1"></a>my_colors <span class="op">=</span> plt.get_cmap(<span class="st">'Blues'</span>)(np.linspace(<span class="fl">0.2</span>, <span class="dv">1</span>, <span class="bu">len</span>(plotting_data.<span class="bu">sum</span>())))</span>
<span id="cb17-39"><a href="#cb17-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-40"><a href="#cb17-40" aria-hidden="true" tabindex="-1"></a><span class="co"># plot the pie, use 4 out of 8 panels = middle 2 rows</span></span>
<span id="cb17-41"><a href="#cb17-41" aria-hidden="true" tabindex="-1"></a>ax <span class="op">=</span> plt.subplot(nrows, ncols, (<span class="dv">3</span>, <span class="dv">6</span>))</span>
<span id="cb17-42"><a href="#cb17-42" aria-hidden="true" tabindex="-1"></a>plt.pie(x <span class="op">=</span> plotting_data.<span class="bu">sum</span>(), colors <span class="op">=</span> my_colors, startangle <span class="op">=</span> <span class="dv">350</span>, labels <span class="op">=</span> <span class="bu">list</span>(plotting_data.columns), autopct<span class="op">=</span><span class="st">'</span><span class="sc">%1.1f%%</span><span class="st">'</span>, pctdistance <span class="op">=</span> <span class="fl">0.5</span>, textprops <span class="op">=</span> <span class="bu">dict</span>(size <span class="op">=</span> font_size <span class="op">+</span> <span class="dv">1</span>), wedgeprops <span class="op">=</span> {<span class="st">"linewidth"</span>: <span class="fl">0.5</span>, <span class="st">"edgecolor"</span>: <span class="st">"white"</span>})</span>
<span id="cb17-43"><a href="#cb17-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-44"><a href="#cb17-44" aria-hidden="true" tabindex="-1"></a><span class="co"># make a donut</span></span>
<span id="cb17-45"><a href="#cb17-45" aria-hidden="true" tabindex="-1"></a>my_axis <span class="op">=</span> plt.gca() <span class="co"># plt.gca = get current axis</span></span>
<span id="cb17-46"><a href="#cb17-46" aria-hidden="true" tabindex="-1"></a>circle <span class="op">=</span> plt.Circle((<span class="dv">0</span>, <span class="dv">0</span>), radius <span class="op">=</span> <span class="fl">0.65</span>, color <span class="op">=</span> <span class="st">"white"</span>)</span>
<span id="cb17-47"><a href="#cb17-47" aria-hidden="true" tabindex="-1"></a>ax.add_patch(circle)</span>
<span id="cb17-48"><a href="#cb17-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-49"><a href="#cb17-49" aria-hidden="true" tabindex="-1"></a><span class="co"># top row unstacked barplot </span></span>
<span id="cb17-50"><a href="#cb17-50" aria-hidden="true" tabindex="-1"></a>plt.subplot(nrows, ncols, (<span class="dv">1</span>, <span class="dv">2</span>))</span>
<span id="cb17-51"><a href="#cb17-51" aria-hidden="true" tabindex="-1"></a>erzeugung[erneuerbare].<span class="bu">sum</span>().sort_values(ascending <span class="op">=</span> <span class="va">False</span>).plot.barh(fontsize <span class="op">=</span> font_size, xlim <span class="op">=</span> (<span class="dv">0</span>, x_lim), color <span class="op">=</span> my_colors[<span class="dv">0</span>], edgecolor <span class="op">=</span> <span class="st">'darkgrey'</span>)</span>
<span id="cb17-52"><a href="#cb17-52" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Erneuerbare"</span>, fontsize <span class="op">=</span> font_size <span class="op">+</span> <span class="dv">2</span>)</span>
<span id="cb17-53"><a href="#cb17-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-54"><a href="#cb17-54" aria-hidden="true" tabindex="-1"></a><span class="co"># bottom row unstacked barplot </span></span>
<span id="cb17-55"><a href="#cb17-55" aria-hidden="true" tabindex="-1"></a>plt.subplot(nrows, ncols, (<span class="dv">7</span>, <span class="dv">8</span>))</span>
<span id="cb17-56"><a href="#cb17-56" aria-hidden="true" tabindex="-1"></a>erzeugung[konventionelle].<span class="bu">sum</span>().sort_values(ascending <span class="op">=</span> <span class="va">False</span>).plot.barh(fontsize <span class="op">=</span> font_size, xlim <span class="op">=</span> (<span class="dv">0</span>, x_lim), color <span class="op">=</span> my_colors[<span class="dv">2</span>], edgecolor <span class="op">=</span> <span class="st">'darkgrey'</span>)</span>
<span id="cb17-57"><a href="#cb17-57" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">"Konventionelle"</span>, fontsize <span class="op">=</span> font_size <span class="op">+</span> <span class="dv">2</span>)</span>
<span id="cb17-58"><a href="#cb17-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-59"><a href="#cb17-59" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span>
<span id="cb17-60"><a href="#cb17-60" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
</div>
</div>
<p>&nbsp;</p>
<p>Durch die Aggregation ähnlicher Stromerzeugungsarten wurde das Ringdiagramm auf vier Erzeugungsarten reduziert. Die mit nur geringen Anteilen an der Gesamtstromerzeugung beteiligten Erzeugungsarten Pumpspeicher und Kernenergie treten dadurch gegenüber der Einzeldarstellung aller Erzeugungsarten deutlich hervor. Auf dieser Grundlage kann diskutiert werden, ob die gezeigte Aggregation zweckmäßig ist. So könnte einerseits die Kernenergie den Konventionellen zugeschlagen werden, wenn für diese Gruppe nicht auf das Merkmal einer Erzeugung mit fossilen Brennstoffen, sondern auf das Prinzip thermischer Dampfexpansion abgestellt wird. Andererseits sollte die Erzeugung durch Pumpspeicher kritisch hinterfragt werden. Dieser Aspekt wird im folgenden Abschnitt diskutiert.</p>
<div id="wrn-komplexe-grafiken" class="callout callout-style-simple callout-warning callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Warning&nbsp;2: Hinweis
</div>
</div>
<div class="callout-body-container callout-body">
<p>Komplexe Grafiken, wie die hier gezeigte, sollten im Allgemeinen sparsam eingesetzt werden, da sie schwer zu erfassen und zu interpretieren sind. Die Zweck der Grafik und die wesentlichen Schlussfolgerungen sollten deshalb im Text erläutert werden.</p>
<p>Tipp: Stellen Sie sich vor, Sie würden die Grafik spontan einem:einer Freund:in zeigen, die Ihre Arbeit nicht gelesen hat. Wie würden Sie Ihrer:Ihrem Freund:in die Grafik erklären? Schreiben Sie es in Ihrer Arbeit auf.</p>
</div>
</div>
<section id="erzeugung-speicherung-einspeisung" class="level3">
<h3 class="anchored" data-anchor-id="erzeugung-speicherung-einspeisung">Erzeugung, Speicherung, Einspeisung</h3>
<p>Pumpspeicherkraftwerke sind Energiespeicher, die keine Primärenergie erzeugen, sondern den von anderen Erzeugern produzierten Strom speichern und bei Bedarf wieder ins Netz einspeisen. Die realisierte Netzeinspeisung von Pumpspeicherkraftwerken entspricht somit der um die Verluste beim Ein- und Ausspeichern (sowie ggf. Speicherverluste wie Verdunstung, Versickerung) verminderten Energieerzeugung anderer Stromerzeuger. Der Wirkungsgrad der Pumpspeicherkraftwerke kann mit den vorliegenden Daten für das Jahr 2023 berechnet werden. <strong>Wie hoch war der Wirkungsgrad der Pumpspeicherkraftwerke 2023?</strong><br>
Welche Erzeuger Strom zum Befüllen der Pumpspeicher lieferten, wird in <a href="#sec-explorative-datenanalyse" class="quarto-xref">Kapitel&nbsp;7</a> untersucht.</p>
<div id="tip-wirkungsgrad-pumpspeicher" class="callout callout-style-default callout-tip callout-titled" title="Lösung Wirkungsgrad Pumpspeicher">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-7-contents" aria-controls="callout-7" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip&nbsp;4: Lösung Wirkungsgrad Pumpspeicher
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-7" class="callout-7-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<div id="c26de3f6" class="cell" data-results="hold" data-execution_count="15">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Summe Erzeugung Pumpspeicher: </span><span class="sc">{</span>erzeugung[<span class="st">"Pumpspeicher [MWh]"</span>]<span class="sc">.</span><span class="bu">sum</span>()<span class="sc">:,.2f}</span><span class="ch">\n</span><span class="ss">"</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>      <span class="ss">f"Summe Verbrauch Pumpspeicher: </span><span class="sc">{</span>verbrauch[<span class="st">"Pumpspeicher [MWh]"</span>]<span class="sc">.</span><span class="bu">sum</span>()<span class="sc">:,.2f}</span><span class="ch">\n</span><span class="ss">"</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>      <span class="ss">f"</span><span class="sc">{</span><span class="dv">41</span> <span class="op">*</span> <span class="st">"="</span><span class="sc">}</span><span class="ch">\n</span><span class="ss">"</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>      <span class="ss">f"Wirkungsgrad in Prozent: </span><span class="ch">\t\t\t</span><span class="sc">{</span>( erzeugung[<span class="st">"Pumpspeicher [MWh]"</span>].<span class="bu">sum</span>() <span class="op">/</span> verbrauch[<span class="st">"Pumpspeicher [MWh]"</span>].<span class="bu">sum</span>() ) <span class="op">*</span> <span class="dv">100</span><span class="sc">:,.2f}</span><span class="ss">"</span>)</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Summe Erzeugung Pumpspeicher: 11,149,398.50
Summe Verbrauch Pumpspeicher: 14,095,632.75
=========================================
Wirkungsgrad in Prozent:            79.10</code></pre>
</div>
</div>
</div>
</div>
</div>
<p>Die tatsächlich realisierte Stromerzeugung ist deshalb die von der Bundesnetzagentur veröffentlichte kumulierte Stromerzeugung der Pumpspeicherkraftwerke zuzüglich der Speicherverluste. Die Bundesnetzagentur führt diesen Wert im Datensatz Stromverbrauch. Im folgenden Programmcode wird der “Walross”-Operator <code>:=</code> benutzt, der Objektzuweisungen innerhalb von Anweisungen erlaubt. Mit dem Walross-Operator durchgeführte Zuweisungen müssen in runde Klammern eingefasst werden:</p>
<div id="97582311" class="cell" data-results="hold" data-execution_count="16">
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Speicherverluste:</span><span class="ch">\t\t\t</span><span class="sc">{</span> (speicherverluste <span class="op">:=</span> ( verbrauch[<span class="st">"Pumpspeicher [MWh]"</span>].<span class="bu">sum</span>() <span class="op">-</span> erzeugung[<span class="st">"Pumpspeicher [MWh]"</span>].<span class="bu">sum</span>() ) <span class="op">/</span> (<span class="dv">1000</span> <span class="op">*</span> <span class="dv">1000</span>) )<span class="sc">:&gt;6.2f}</span><span class="ss"> TWh</span><span class="ch">\n</span><span class="ss">"</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>      <span class="ss">f"kumulierte Stromerzeugung:</span><span class="ch">\t</span><span class="sc">{</span> ( kumulierte_erzeugung <span class="op">:=</span> erzeugung.<span class="bu">sum</span>(numeric_only <span class="op">=</span> <span class="va">True</span>).<span class="bu">sum</span>() <span class="op">//</span> (<span class="dv">1000</span> <span class="op">*</span> <span class="dv">1000</span>) )<span class="sc">:,.2f}</span><span class="ss"> TWh</span><span class="ch">\n</span><span class="ss">"</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>      <span class="ss">f"Summe:</span><span class="ch">\t\t\t\t\t\t</span><span class="sc">{</span>speicherverluste <span class="op">+</span> kumulierte_erzeugung<span class="sc">:,.2f}</span><span class="ss"> TWh</span><span class="ch">\n\n</span><span class="ss">"</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>      <span class="ss">f"Erzeugung durch Pumpspeicher:</span><span class="ch">\t\t\t\t</span><span class="sc">{</span>erzeugung[<span class="st">"Pumpspeicher [MWh]"</span>]<span class="sc">.</span><span class="bu">sum</span>() <span class="op">/</span> (<span class="dv">1000</span> <span class="op">*</span> <span class="dv">1000</span>)<span class="sc">:,.2f}</span><span class="ss"> TWh</span><span class="ch">\n</span><span class="ss">"</span></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>      <span class="ss">f"Erzeugung Pumpspeicher + Speicherverluste:</span><span class="ch">\t</span><span class="sc">{</span>(erzeugung[<span class="st">"Pumpspeicher [MWh]"</span>].<span class="bu">sum</span>() <span class="op">/</span> (<span class="dv">1000</span> <span class="op">*</span> <span class="dv">1000</span>)) <span class="op">+</span> speicherverluste<span class="sc">:,.2f}</span><span class="ss"> TWh</span><span class="ch">\n</span><span class="ss">"</span></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>      <span class="ss">f"Verbrauch Pumpspeicherkraftwerke:</span><span class="ch">\t\t\t</span><span class="sc">{</span>verbrauch[<span class="st">"Pumpspeicher [MWh]"</span>]<span class="sc">.</span><span class="bu">sum</span>() <span class="op">/</span> (<span class="dv">1000</span> <span class="op">*</span> <span class="dv">1000</span>)<span class="sc">:,.2f}</span><span class="ss"> TWh"</span>)</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Speicherverluste:             2.95 TWh
kumulierte Stromerzeugung:  448.00 TWh
Summe:                      450.95 TWh

Erzeugung durch Pumpspeicher:               11.15 TWh
Erzeugung Pumpspeicher + Speicherverluste:  14.10 TWh
Verbrauch Pumpspeicherkraftwerke:           14.10 TWh</code></pre>
</div>
</div>
<p><strong>Braucht es hier einen Hinweis, dass hier keine Erkenntnis produziert wird, sondern nur zur Veranschauung hin- und hergerechnet wird?</strong> &nbsp;</p>
<p>Die Differenz zwischen tatsächlich realisierter und von der Bundesnetzagentur veröffentlichter Stromerzeugung beträgt knapp 3 TWh, also weniger als 1 Prozent der Gesamtstromerzeugung. In anderen Netzen ist die korrekte Zuordnung der Daten auch betragsmäßig relevant.</p>
</section>
</section>
<section id="sec-aufgabe-beschreibende-Datenanalyse" class="level2" data-number="6.2">
<h2 data-number="6.2" class="anchored" data-anchor-id="sec-aufgabe-beschreibende-Datenanalyse"><span class="header-section-number">6.2</span> Aufgabe beschreibende Datenanalyse</h2>
<p>In Österreich spielen Pumpspeicherkraftwere eine bedeutende Rolle im Strommix.</p>
<div class="border">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="aufgaben/00-bilder/Schlegeisspeicher_von_Friesenberghaus_von_Klaus_Kettner_CC_BY-SA_3.0.png" class="img-fluid figure-img" style="width:80.0%"></p>
<figcaption>&nbsp;</figcaption>
</figure>
</div>
<p>Blick vom Schlegeisspeicher von Höhenweg aus. von Klaus Kettner steht unter der Lizenz <a href="https://creativecommons.org/licenses/by-sa/3.0/deed.de">CC BY-SA 3.0</a> und ist abrufbar auf <a href="https://commons.wikimedia.org/w/index.php?curid=20380105">Wikimedia</a>. Das Bild wurde zugeschnitten und im Format PNG gespeichert. 2012.</p>
</div>
<p>&nbsp;</p>
<p>Wie die Bundesnetzagentur veröffentlicht auch die Austrian Power Grid AG (APG) Strommarktdaten unter <a href="https://markttransparenz.apg.at/de/markt/Markttransparenz/erzeugung/Erzeugung-pro-Typ">https://markttransparenz.apg.at/</a>. Unter dem Link können Erzeugungsdaten für das Jahr 2023 heruntergeladen werden.</p>
<p>Diesem Skript ist folgende Datei angefügt.</p>
<div style="font-size: 90%;">
<table class="table">
<colgroup>
<col style="width: 50%">
<col style="width: 50%">
</colgroup>
<thead>
<tr class="header">
<th>Daten</th>
<th>Dateiname</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Realisierte Stromerzeugung 2023</td>
<td>AGPT_2022-12-31T23_00_00Z_2023-12-31T23_00_00Z_15M_de_2024-06-10T09_32_38Z.csv</td>
</tr>
</tbody>
</table>
</div>
<p><strong>Lesen Sie die österreichischen Erzeugungsdaten ein und visualisieren Sie die Anteile der Erzeugungstypen. Was fällt Ihnen im Datensatz auf?</strong></p>
<p><strong>Hat Marc Lust, eine Musterlösung zu erstellen?</strong></p>
<div id="wrn-Strommarkt-Austria" class="callout callout-style-simple callout-warning callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-8-contents" aria-controls="callout-8" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Warning&nbsp;3: Markttranzparenzdaten Österreich herunterladen
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-8" class="callout-8-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>Nach der Auswahl des Zeitraums auf Exportieren klicken, dann erscheint die Schaltfläche Download.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="aufgaben/00-bilder/APG-erzeugungsdaten-2023-de.png" class="img-fluid figure-img"></p>
<figcaption>&nbsp;</figcaption>
</figure>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="aufgaben/00-bilder/english/APG-generation-data-2023-en.png" class="img-fluid figure-img"></p>
<figcaption>&nbsp;</figcaption>
</figure>
</div>
<p>Das Datumsformat der Dateien ist abhängig von der auf der Internetseite eingestellten Sprache (Deutsch/English).</p>
</div>
</div>
</div>
<p>&nbsp;</p>
<div id="tip-Austria" class="callout callout-style-default callout-tip callout-titled" title="Musterlösung Strommarktdaten Österreich">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-10-contents" aria-controls="callout-10" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip&nbsp;5: Musterlösung Strommarktdaten Österreich
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-10" class="callout-10-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>Ich bin gemein und will noch nichts verraten.</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-9-contents" aria-controls="callout-9" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tipp
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-9" class="callout-9-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>Der Datensatz ist anders zusammengestellt. Pumpspeicher weisen teils negative Werte auf… die müssen natürlich bereinigt werden, um mit den Daten der Bundesnetzagentur verglichen zu werden.</p>
<p>Alle negativen Werte = Einspeichern (entspricht Verbrauchsdaten der Bundesnetzagentur)</p>
<p>Alle positiven Werte = Einspeisung (entspricht Erzeugungsdaten der Bundesnetzagentur)</p>
<p>(<strong>Hinweis: Ich habe bislang nur kurz in den Datensatz reingeschaut.</strong>)</p>
</div>
</div>
</div>
</div>
</div>
</div>
<section id="optionen-für-abschnitt-beschreibende-statistik" class="level3">
<h3 class="anchored" data-anchor-id="optionen-für-abschnitt-beschreibende-statistik">Optionen für Abschnitt beschreibende Statistik</h3>
<ul>
<li>gestapeltes Histogramm (das ist schwer, wenn man es nicht manuell macht) für die Erzeugung in einem Monat oder in einer Woche - eine Woche im Winter, eine Woche im Sommer</li>
</ul>
<p><strong>Eigentlich müsste man die Datensätze umstrukturieren, wenn man weiter damit arbeiten möchte, um Erzeugung von Speicherung zu trennen.</strong></p>
</section>
</section>
</section>
<section id="sec-explorative-datenanalyse" class="level1" data-number="7">
<h1 data-number="7"><span class="header-section-number">7</span> Explorative Datenanalyse</h1>
<p>Explorative Datenanalyse bedeutet, Fragen an die vorliegenden Daten zu stellen und diese mittels datenanalytischer Methoden zu beantworten. Die so gewonnenen Erkenntnisse können helfen, die Fragen zu verfeinern oder neue Fragen zu generieren. Es handelt sich also um einen iterativen Prozess. Dadurch soll vor allem ein tieferes Verständnis der Daten gewonnen werden. <span class="citation" data-cites="R-for-Data-Science">(<a href="#ref-R-for-Data-Science" role="doc-biblioref">Wickham, Çetinkaya-Rundel, und Grolemund 2023, Kap. 10</a> Exploratory data analysis)</span></p>
<section id="hintergrund-grenzstromanalyse" class="level2" data-number="7.1">
<h2 data-number="7.1" class="anchored" data-anchor-id="hintergrund-grenzstromanalyse"><span class="header-section-number">7.1</span> Hintergrund: Grenzstromanalyse</h2>
<p>Im vorliegenden Fall wird die explorative Auseinandersetzung mit dem Datensatz von der Frage strukturiert, welche Erzeuger Strom lieferten, um <em>zusätzlich</em> zur Netzlast die Pumpspeicher zu befüllen. Es soll also bestimmt werden, welche Stromerzeuger an den Zeitpunkten, an denen die Pumpspeicher befüllt wurden, in der Lage waren, zusätzliche Leistung bereitzustellen. Dieser zusätzliche Strom kann kurz als Grenzstrom bezeichnet werden.</p>
<div class="callout callout-style-default callout-important callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Definition Grenzstrom
</div>
</div>
<div class="callout-body-container callout-body">
<p>Grenzbetrachtungen untersuchen die Bedingungen, die bei der Produktion oder dem Verbrauch einer zusätzlichen Einheit herrschen. Eine Grenzbetrachtung unterscheidet sich dadurch von einer Durchschnittsbetrachtung, die den Effekt einer Mengenänderung auf alle Einheiten untersucht. Der Grenzstrom bezeichnet eine zusätzliche Einheit Strom.</p>
<p>Beispielsweise bestehe die momentane Stromerzeugung in Höhe von 100 Einheiten aus 60 Einheiten Solarstrom und, weil die solare Produktion nicht ausreicht, zusätzlich aus 40 Einheiten Kohlestrom. In diesem Fall enthält jede Einheit Strom durchschnittlich 0,4 Anteile Kohlestrom. Werden nun weitere 20 Einheiten Strom nachgefragt, so müssen diese durch eine zusätzliche Kohleverstromung bedient werden. In der Durchschnittsbetrachtung beträgt der Strommix nun aus 60 Einheiten Solarstrom und 40 + 20 = 60 Einheiten Kohlestrom. Dadurch verändert sich der durchschnittliche Anteil der Kohle an der Stromproduktion von 0,4 auf 0,5.</p>
<p>In der Grenzbetrachtung beträgt der Kohleanteil des zusätzlich verbrauchten Stroms 20 von 20 Einheiten, also 1.</p>
</div>
</div>
</section>
<section id="hintergrund-einspeisevorrang-erneuerbarer-energien" class="level2" data-number="7.2">
<h2 data-number="7.2" class="anchored" data-anchor-id="hintergrund-einspeisevorrang-erneuerbarer-energien"><span class="header-section-number">7.2</span> Hintergrund: Einspeisevorrang erneuerbarer Energien</h2>
<p>In Deutschland gilt seit dem Jahr 2000 das Erneuerbare-Energien-Gesetz, das ursprünglich als Gesetz für den Vorrang Erneuerbarer Energien eingeführt wurde <a href="https://dip.bundestag.de/vorgang/gesetz-f%C3%BCr-den-vorrang-erneuerbarer-energien-erneuerbare-energien-gesetz-eeg-sowie/111957">Dokumentations- und Informationssystem für Parlamentsmaterialien</a>. Dieses regelte in § 3 den Einspeisevorrang erneuerbarer Energien:</p>
<div>

</div>
<div class="border quarto-layout-panel" data-layout="[[5, 90, 5], [1]]">
<div class="quarto-layout-row">
<div class="quarto-layout-cell" style="flex-basis: 5.0%;justify-content: flex-start;">
<p>&nbsp;</p>
</div>
<div class="quarto-layout-cell" style="flex-basis: 90.0%;justify-content: flex-start;">
<p><strong>Abnahme- und Vergütungspflicht</strong><br>
(1) Netzbetreiber sind verpflichtet, Anlagen zur Erzeugung von Strom nach § 2 an ihr Netz anzuschließen, den gesamten angebotenen Strom aus diesen Anlagen vorrangig abzunehmen und den eingespeisten Strom nach §§ 4 bis 8 zu vergüten.</p>
</div>
<div class="quarto-layout-cell" style="flex-basis: 5.0%;justify-content: flex-start;">
<p>&nbsp;</p>
</div>
</div>
<div class="quarto-layout-row">
<div class="quarto-layout-cell" style="flex-basis: 100.0%;justify-content: flex-start;">
<p>&nbsp;<br>
Gesetz für den Vorrang Erneuerbarer Energien (Erneuerbare-Energien-Gesetz – EEG) sowie zur Änderung des Energiewirtschaftsgesetzes und des Mineralölsteuergesetzes. Bundesgesetzblatt Jahrgang 2000 Teil I Nr. 13, ausgegeben zu Bonn am 31. März 2000. <a href="https://www.bgbl.de/xaver/bgbl/start.xav?startbk=Bundesanzeiger_BGBl&amp;start=//*%5b@attr_id=%27bgbl100s0305.pdf%27%5d#__bgbl__%2F%2F*%5B%40attr_id%3D%27bgbl100s0305.pdf%27%5D__1718177313490">Bundesanzeiger</a></p>
</div>
</div>
</div>
<p>&nbsp;</p>
<p>Als erneuerbare Energien klassifizierte Erzeuger speisen vorrangig in das Netz ein. Dies sind nach der aktuellen Fassung des Gesetztes:</p>
<div class="border">
<ol type="a">
<li><p>Wasserkraft einschließlich der Wellen-, Gezeiten-, Salzgradienten- und Strömungsenergie,</p></li>
<li><p>Windenergie,</p></li>
<li><p>solare Strahlungsenergie,</p></li>
<li><p>Geothermie,</p></li>
<li><p>Energie aus Biomasse einschließlich Biogas, Biomethan, Deponiegas und Klärgas sowie aus dem biologisch abbaubaren Anteil von Abfällen aus Haushalten und Industrie</p></li>
</ol>
<p>Gesetz für den Ausbau erneuerbarer Energien (Erneuerbare-Energien-Gesetz - EEG 2023). § 3 Begriffsbestimmungen. <a href="https://www.gesetze-im-internet.de/eeg_2014/__3.html" class="uri">https://www.gesetze-im-internet.de/eeg_2014/__3.html</a></p>
</div>
<p>&nbsp;</p>
<p>Die nicht erneuerbaren Erzeuger arbeiten im Lastfolgebetrieb zur Deckung der Restlast, das heißt der Netzlast abzüglich der erneuerbaren Erzeugungsleistung. Dies bedeutet, dass zwei Szenarien zu unterscheiden sind:</p>
<ol type="1">
<li><p>Überschuss an erneuerbaren Energien: Der Stromverbrauch wird vollständig durch die Erzeugung erneuerbarer Energien gedeckt und es besteht ein Erzeugungsüberschuss (bzw. Erzeuger wurden abgeregelt), aus dem zusätzlicher Stromverbrauch bedient werden kann.</p></li>
<li><p>Strommix aus erneuerbarer Einspeisung und Lastfolgebetrieb nicht erneuerbarer Erzeuger: Erneuerbare Energien speisen mit voller Leistung ein, die Restlast und zusätzlicher Stromverbrauch wird von nicht erneuerbaren Erzeugern gedeckt.</p></li>
</ol>
<p>Die welches Szenario im Stromnetz zu einem bestimmten Zeitpunkt besteht, lässt sich also an der Restlast ablesen.</p>
</section>
<section id="residual--und-restlast-bestimmen" class="level2" data-number="7.3">
<h2 data-number="7.3" class="anchored" data-anchor-id="residual--und-restlast-bestimmen"><span class="header-section-number">7.3</span> Residual- und Restlast bestimmen</h2>
<p>Die Bundesnetzagentur veröffentlicht im Datensatz zum realisierten Stromverbrauch Netzlast, Residuallast und den Stromverbrauch durch Pumpspeicherkraftwerke.</p>
<div id="7244336e" class="cell" data-execution_count="17">
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(verbrauch.<span class="bu">sum</span>(numeric_only <span class="op">=</span> <span class="va">True</span>))</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Gesamt (Netzlast) [MWh]    4.58e+08
Residuallast [MWh]         2.60e+08
Pumpspeicher [MWh]         1.41e+07
dtype: float64</code></pre>
</div>
</div>
<div class="callout callout-style-default callout-important callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Definition Residuallast
</div>
</div>
<div class="callout-body-container callout-body">
<p>Die Residuallast […] entspricht dem gesamten Realisierten Stromverbrauch, abzüglich der Einspeisung von Photovoltaik-, Wind Onshore- und Wind Offshore-Anlagen. <a href="https://www.smard.de/resource/blob/212924/61a75e052eddb43a8d3cc4c6e1653fa3/smard-benutzerhandbuch-02-2024-data.pdf">SMARD.de Benutzerhandbuch (S. 53)</a></p>
</div>
</div>
<p>&nbsp;</p>
<p>Die nicht durch erneuerbare Energien bediente Restlast ist die Differenz aus Stromverbrauch und der Erzeugung durch erneuerbare Energien. Die Restlast ist folglich kleiner als die von der Bundesnetzagentur veröffentlichte Residuallast. Residual- und Restlast können aus der Differenz von Netzlast und der entsprechenden erneuerbaren Stromerzeugung berechnet werden.</p>
<div id="df09bfdc" class="cell" data-execution_count="18">
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>erneuerbare <span class="op">=</span> [<span class="st">'Biomasse [MWh]'</span>, <span class="st">'Wasserkraft [MWh]'</span>, <span class="st">'Wind Offshore [MWh]'</span>, <span class="st">'Wind Onshore [MWh]'</span>, <span class="st">'Photovoltaik [MWh]'</span>, <span class="st">'Sonstige Erneuerbare [MWh]'</span>]</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>PV_WindOnshore_WindOffshore <span class="op">=</span> [<span class="st">'Wind Offshore [MWh]'</span>, <span class="st">'Wind Onshore [MWh]'</span>, <span class="st">'Photovoltaik [MWh]'</span>] </span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>plotting_data <span class="op">=</span> pd.DataFrame()</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>plotting_data[<span class="st">"Netzlast [MWh]"</span>] <span class="op">=</span> verbrauch[<span class="st">"Gesamt (Netzlast) [MWh]"</span>].copy() </span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>plotting_data[<span class="st">"volatile EE [MWh]"</span>] <span class="op">=</span> erzeugung[PV_WindOnshore_WindOffshore].<span class="bu">sum</span>(axis <span class="op">=</span> <span class="st">"columns"</span>).copy()</span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>plotting_data[<span class="st">"Erneuerbare [MWh]"</span>] <span class="op">=</span> erzeugung[erneuerbare].<span class="bu">sum</span>(axis <span class="op">=</span> <span class="st">"columns"</span>).copy()</span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a>plotting_data[<span class="st">"Residuallast BNetzA [MWh]"</span>] <span class="op">=</span> verbrauch[<span class="st">"Residuallast [MWh]"</span>].copy()</span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a>plotting_data[<span class="st">"Residuallast [MWh]"</span>] <span class="op">=</span> plotting_data[<span class="st">"Netzlast [MWh]"</span>] <span class="op">-</span> plotting_data[<span class="st">"volatile EE [MWh]"</span>]</span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true" tabindex="-1"></a>plotting_data[<span class="st">"Restlast [MWh]"</span>] <span class="op">=</span> plotting_data[<span class="st">"Netzlast [MWh]"</span>] <span class="op">-</span> plotting_data[<span class="st">"Erneuerbare [MWh]"</span>]</span>
<span id="cb24-12"><a href="#cb24-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-13"><a href="#cb24-13" aria-hidden="true" tabindex="-1"></a>plotting_data.head()</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="18">
<div>
<div>


<table class="dataframe table table-sm table-striped small" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">Netzlast [MWh]</th>
<th data-quarto-table-cell-role="th">volatile EE [MWh]</th>
<th data-quarto-table-cell-role="th">Erneuerbare [MWh]</th>
<th data-quarto-table-cell-role="th">Residuallast BNetzA [MWh]</th>
<th data-quarto-table-cell-role="th">Residuallast [MWh]</th>
<th data-quarto-table-cell-role="th">Restlast [MWh]</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>9720.75</td>
<td>7830.50</td>
<td>9277.00</td>
<td>1890.25</td>
<td>1890.25</td>
<td>443.75</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>9641.25</td>
<td>7902.00</td>
<td>9343.00</td>
<td>1739.25</td>
<td>1739.25</td>
<td>298.25</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>9609.50</td>
<td>8119.50</td>
<td>9559.50</td>
<td>1490.00</td>
<td>1490.00</td>
<td>50.00</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>9565.00</td>
<td>7919.00</td>
<td>9362.25</td>
<td>1646.00</td>
<td>1646.00</td>
<td>202.75</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">4</td>
<td>9473.50</td>
<td>8107.75</td>
<td>9540.50</td>
<td>1365.75</td>
<td>1365.75</td>
<td>-67.00</td>
</tr>
</tbody>
</table>

</div>
</div>
</div>
</div>
<p>&nbsp;</p>
<p>Die von der Bundesnetzagentur veröffentlichte Residuallast <code>Residuallast BNetzA [MWh]</code> entspricht nach der Betrachtung der ersten Zeilen der selbst berechneten Residuallast <code>Residuallast [MWh]</code>. Ob dies für die gesamte Zeitreihe gilt, kann leicht mit der Methode <code>pd.Series.equals()</code> überprüft werden.</p>
<div id="c93c7bcc" class="cell" data-results="hold" data-execution_count="19">
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>plotting_data[<span class="st">'Residuallast BNetzA [MWh]'</span>].equals(plotting_data[<span class="st">'Residuallast [MWh]'</span>])</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="19">
<pre><code>True</code></pre>
</div>
</div>
<p>Somit kann die redundante Spalte entfernt werden.</p>
<div id="d4dbd2c3" class="cell" data-results="hold" data-execution_count="20">
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>plotting_data.drop([<span class="st">'Residuallast BNetzA [MWh]'</span>], axis <span class="op">=</span> <span class="st">'columns'</span>, inplace <span class="op">=</span> <span class="va">True</span>)</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="jahresgang-grafisch-darstellen" class="level2" data-number="7.4">
<h2 data-number="7.4" class="anchored" data-anchor-id="jahresgang-grafisch-darstellen"><span class="header-section-number">7.4</span> Jahresgang grafisch darstellen</h2>
<p>Die Netzlast, die Erzeugung durch erneuerbare Energien sowie die Residual- und Restlast sollen im Jahresgang dargestellt werden. Zur besseren Darstellung wird nur jeder 100. Wert eingezeichnet.</p>
<div class="tabset-margin-container"></div><div class="panel-tabset">
<ul class="nav nav-tabs" role="tablist"><li class="nav-item" role="presentation"><a class="nav-link active" id="tabset-4-1-tab" data-bs-toggle="tab" data-bs-target="#tabset-4-1" role="tab" aria-controls="tabset-4-1" aria-selected="true" href="">Netzlast im Jahresgang</a></li><li class="nav-item" role="presentation"><a class="nav-link" id="tabset-4-2-tab" data-bs-toggle="tab" data-bs-target="#tabset-4-2" role="tab" aria-controls="tabset-4-2" aria-selected="false" href="">Code für den Plot</a></li></ul>
<div class="tab-content">
<div id="tabset-4-1" class="tab-pane active" role="tabpanel" aria-labelledby="tabset-4-1-tab">
<div id="b07f938b" class="cell" data-results="hold" data-execution_count="22">
<div class="cell-output cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="Energiedatenauswertung_files/figure-html/cell-23-output-1.png" width="740" height="686" class="figure-img"></p>
<figcaption>Netzlast im Jahresgang</figcaption>
</figure>
</div>
</div>
</div>
</div>
<div id="tabset-4-2" class="tab-pane" role="tabpanel" aria-labelledby="tabset-4-2-tab">
<div id="7f7fa945" class="cell" data-results="hold" data-execution_count="23">
<div class="sourceCode cell-code" id="cb28"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Position und Inhalt der x-Achsenbeschriftung finden</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>monate <span class="op">=</span> erzeugung[<span class="st">"Datum von"</span>].dt.month.unique().tolist() <span class="co"># gibt die Zahlen 1-12 aus</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a><span class="co">## mit Pandas</span></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>monate_index <span class="op">=</span> erzeugung[<span class="op">~</span>erzeugung[<span class="st">"Datum von"</span>].dt.month.duplicated()].index</span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>monatsnamen <span class="op">=</span> erzeugung[<span class="st">"Datum von"</span>].iloc[monate_index].dt.strftime(<span class="st">"%B"</span>) </span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a><span class="co">## alternativ mit einer Listenoperation</span></span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a><span class="co"># monate_index = []</span></span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a><span class="co"># monatsnamen = []</span></span>
<span id="cb28-11"><a href="#cb28-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-12"><a href="#cb28-12" aria-hidden="true" tabindex="-1"></a><span class="co"># for i in monate:</span></span>
<span id="cb28-13"><a href="#cb28-13" aria-hidden="true" tabindex="-1"></a><span class="co">#   monate_index.append(erzeugung.index[erzeugung["Datum von"].dt.month == i].min())</span></span>
<span id="cb28-14"><a href="#cb28-14" aria-hidden="true" tabindex="-1"></a><span class="co">#   monatsnamen.append(erzeugung["Datum von"].iloc[monate_index[i - 1]].strftime("%B"))</span></span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="5ab47b1b" class="cell" data-results="hold" data-execution_count="24">
<div class="sourceCode cell-code" id="cb29"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="co"># plotten jedes 100. Werts</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a>plotting_data[::<span class="dv">100</span>].plot(figsize <span class="op">=</span> (<span class="dv">9</span>, <span class="dv">8</span>), subplots <span class="op">=</span> <span class="va">True</span>, sharey <span class="op">=</span> <span class="va">True</span>, xlim <span class="op">=</span> (plotting_data.index.<span class="bu">min</span>() <span class="op">-</span> (<span class="bu">len</span>(plotting_data.index) <span class="op">/</span> <span class="dv">100</span>), plotting_data.index.<span class="bu">max</span>() <span class="op">*</span> <span class="fl">1.01</span>), rot <span class="op">=</span> <span class="dv">45</span>, grid <span class="op">=</span> <span class="va">True</span>)</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>plt.ylim(top <span class="op">=</span> <span class="dv">20000</span>)</span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>plt.minorticks_off()</span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>plt.xticks(monate_index, monatsnamen)<span class="op">;</span></span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
</div>
</div>
<p>Es ist zu erkennen, dass die Netzlast dauerhaft oberhalb von 9000 MWh liegt. Darüber hinausgehend schwankt die Netzlast im Monatsgang stark. In jedem Monat werden Leistungen nahe des absoluten Minimums und Maximums erreicht. Im Sommer ist die Netzlast im Allgemeinen etwas niedriger als im Winter.<br>
Die Stromerzeugung durch erneuerbare Energien ist stark volatil. Phasen hoher Produktion wechseln sich mit Phasen geringer Produktion ab und dauern jeweils nur einige Tage und höchstens für zwei Wochen an. Dies geht maßgeblich auf die Stromerzeugung durch Photovoltaik und Off- und Onshore Wind zurück, deren deutschlandweit kombinierte Erzeugungsleistung häufig nahe Null liegt, um anschließend ein (lokales) Produktionsmaximum zu erreichen. Die zusätzliche Einspeisung weniger volatiler erneuerbarer Energien wie Biomasse und Wasserkraft ist vergleichsweise gering, sodass auch die über alle Erzeugungsformen summierte erneuerbare Stromerzeugung zwar nie Null, häufig aber eine geringe Gesamtleistung erreicht. Gleichwohl gibt es auch kurze Phasen erneuerbarer Vollversorgung bzw. Überschussproduktion, wie am Jahresgang der nicht erneuerbaren Restlast abzulesen ist.</p>
<p>Für die Frage nach der Herkunft des in den Pumpspeicherkraftwerken gespeicherten Stroms kann bereits durch die graphische Darstellung gefolgert werden, dass dieser überwiegend durch nicht erneuerbare Stromerzeuger erzeugt wurde, da die Restlast nur selten Null oder negativ ist.</p>
<p>Der Jahresgang der Restlast gleicht dem Erzeugungsverlauf der volatilen erneuerbaren Energien. Dies stellt für die konventionellen Kraftwerke eine Herausforderung dar. Dieser Aspekt wird im nächsten Abschnitt vertieft.</p>
<p>Zunächst aber eine kleine Aufgabe: <strong>Wie würde sich eine Verdopplung der erneuerbaren Erzeugung auf die Restlast auswirken? Stellen Sie den Effekt auf vergleichbare Weise grafisch dar (z. B. durch eine zusätzliche Spalte ‘Netzlast - 2x EE’).</strong></p>
<div id="tip-verdopplung-EE" class="callout callout-style-default callout-tip callout-titled" title="Musterlösung Verdopplung EE">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-13-contents" aria-controls="callout-13" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip&nbsp;6: Musterlösung Verdopplung EE
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-13" class="callout-13-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<div class="tabset-margin-container"></div><div class="panel-tabset">
<ul class="nav nav-tabs" role="tablist"><li class="nav-item" role="presentation"><a class="nav-link active" id="tabset-5-1-tab" data-bs-toggle="tab" data-bs-target="#tabset-5-1" role="tab" aria-controls="tabset-5-1" aria-selected="true" href="">Plot</a></li><li class="nav-item" role="presentation"><a class="nav-link" id="tabset-5-2-tab" data-bs-toggle="tab" data-bs-target="#tabset-5-2" role="tab" aria-controls="tabset-5-2" aria-selected="false" href="">Code</a></li><li class="nav-item" role="presentation"><a class="nav-link" id="tabset-5-3-tab" data-bs-toggle="tab" data-bs-target="#tabset-5-3" role="tab" aria-controls="tabset-5-3" aria-selected="false" href="">Mögliche Interpretation</a></li></ul>
<div class="tab-content">
<div id="tabset-5-1" class="tab-pane active" role="tabpanel" aria-labelledby="tabset-5-1-tab">
<div id="d2f07548" class="cell" data-execution_count="25">
<div class="cell-output cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="Energiedatenauswertung_files/figure-html/cell-26-output-1.png" width="751" height="538" class="figure-img"></p>
<figcaption>Musterlösung Verdopplung EE</figcaption>
</figure>
</div>
</div>
</div>
</div>
<div id="tabset-5-2" class="tab-pane" role="tabpanel" aria-labelledby="tabset-5-2-tab">
<div id="b37bfdcb" class="cell" data-execution_count="26">
<div class="sourceCode cell-code" id="cb30"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>plotting_data_2EE <span class="op">=</span> plotting_data.copy()</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>plotting_data_2EE[<span class="st">"2x EE"</span>] <span class="op">=</span> plotting_data_2EE[<span class="st">"Erneuerbare [MWh]"</span>] <span class="op">*</span> <span class="dv">2</span></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>plotting_data_2EE[<span class="st">"Netzlast - 2x EE"</span>] <span class="op">=</span> plotting_data_2EE[<span class="st">"Netzlast [MWh]"</span>] <span class="op">-</span> plotting_data_2EE[<span class="st">"2x EE"</span>]</span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>plotting_data_2EE <span class="op">=</span> plotting_data_2EE[[<span class="st">"Netzlast [MWh]"</span>, <span class="st">"Netzlast - 2x EE"</span>]]</span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a><span class="co"># plotten jedes 100. Werts</span></span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a>plotting_data_2EE[::<span class="dv">100</span>].plot(figsize <span class="op">=</span> (<span class="dv">9</span>, <span class="dv">6</span>), subplots <span class="op">=</span> <span class="va">True</span>, sharey <span class="op">=</span> <span class="va">True</span>, xlim <span class="op">=</span> (plotting_data_2EE.index.<span class="bu">min</span>() <span class="op">-</span> (<span class="bu">len</span>(plotting_data_2EE.index)) <span class="op">/</span> <span class="dv">100</span>, plotting_data_2EE.index.<span class="bu">max</span>() <span class="op">*</span> <span class="fl">1.01</span>), rot <span class="op">=</span> <span class="dv">45</span>, grid <span class="op">=</span> <span class="va">True</span>)</span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a>plt.minorticks_off()</span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true" tabindex="-1"></a>plt.xticks(monate_index, monatsnamen)<span class="op">;</span></span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<div id="tabset-5-3" class="tab-pane" role="tabpanel" aria-labelledby="tabset-5-3-tab">
<p>Die Netzlast abzüglich der verdoppelten erneuerbaren Stromerzeugung nähert sich einer symmetrischen Verteilung um die Nullinie an. Das heißt, Phasen erneuerbarer Über- und Unterproduktion halten sich ungefähr die Waage.</p>
</div>
</div>
</div>
</div>
</div>
</div>
</section>
<section id="hintergrund-grund--mittel-und-spitzenlast" class="level2" data-number="7.5">
<h2 data-number="7.5" class="anchored" data-anchor-id="hintergrund-grund--mittel-und-spitzenlast"><span class="header-section-number">7.5</span> Hintergrund: Grund-, Mittel und Spitzenlast</h2>
<p>Nicht alle Erzeuer sind aus technischen oder aus wirtschaftlichen Gründen gleichermaßen für den Lastfolgebetrieb geeignet. Beispielsweise sind Kohlekraftwerke weniger flexibel regelbar als Gaskraftwerke. Kernkraftwerke werden aufgrund ihrer hohen Fix- und geringen variablen Kosten bevorzugt im Grundlastbetrieb betrieben. Im Stromnetz werden drei Einsatzprofile für Kraftwerke unterschieden: Grundlast, Mittellast und Spitzenlast.</p>
<div class="callout callout-style-default callout-important callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Definition Grund-, Mittel- und Spitzenlast
</div>
</div>
<div class="callout-body-container callout-body">
<div class="border">
<ul>
<li><p>Grundlast: Die im Jahresgang dauerhaft nachgefragte Leistung.<br>
Kraftwerkstypen: Braunkohle, Kernkraft, Laufwasser</p></li>
<li><p>Mittellast: Über die Grundlast hinausgehende, im Tages- und Jahresgang planbar nachgefragte Leistung.<br>
Kraftwerkstypen: Gas-und-Dampfturbinen-Kraftwerk, Steinkohle</p></li>
<li><p>Spitzenlast: Über die Mittellast hinausgehende, im Tages- und Jahresgang nur kurzzeitig oder ungeplant nachgefragte Leistung.<br>
Kraftwerkstypen: Gaskraftwerke, Pumpspeicherkraftwerke</p></li>
</ul>
<p>ISPEX AG: <a href="https://www.ispex.de/lexikon/grundlast/">Grundlast</a>, <a href="https://www.ispex.de/lexikon/mittellast/">Mittellast</a>, <a href="https://www.ispex.de/lexikon/spitzenlast/">Spitzenlast</a></p>
<p>Grünwald, Reinhard / Caviezel, Claudio 2017: Lastfolgefähigkeit deutscher Kernkraftwerke. Monitoring. Büro für Technikfolgen-Abschätzung beim Deutschen Bundestag (TAB). doi: <a href="https://publikationen.bibliothek.kit.edu/1000102277">10.5445/IR/1000102277</a>. Seite 16.</p>
</div>
</div>
</div>
<p>Für die Frage, welche Kraftwerke den Grenzstrom zur Befüllung der Pumpspeicherkraftwerke liefern, ist insbesondere die Unterscheidung von im Grundlastbetrieb operierenden Kraftwerken einerseits sowie von im Mittellast- und Spitzenlastbetrieb arbeitenden Kraftwerken andererseits relevant. In Grundlast operierende Kraftwerke fahren 24 Stunden am Tag in Volllast. Beispielsweise erreichte Kernenergie im Jahr 2021 mit 8.070 Jahresvolllaststunden beinahe einen durchgehenden Volllastbetrieb <a href="https://de.statista.com/statistik/daten/studie/37610/umfrage/jahresvolllaststunden-deutscher-kraftwerke-im-jahr-2009/">statista</a>. In Volllast betriebene Kraftwerke können nicht mehr auf zusätzliche Stromnachfrage reagieren. Dies bleibt im Mittel- und Spitzenlastbetrieb arbeitenden Kraftwerken überlassen.</p>
<p>Somit können durch die Unterscheidung von in Grundlast und von in Mittel- bzw. Spitzenlast betriebenen Kraftwerkstypen die Kraftwerkstypen, die den zur Befüllung der Pumpspeicherkraftwerken erforderlichen Strom lieferten, eingegrenzt werden.</p>
<p>Die Auslastung eines Kraftwerks (bzw. einer Gruppe von Kraftwerken) kann mittels seiner Jahresvolllaststunden quantifiziert werden.</p>
<div class="callout callout-style-default callout-important callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Definition Jahresvolllaststunden
</div>
</div>
<div class="callout-body-container callout-body">
<p>Die Jahresvolllaststunden geben an, wie viel der 8.760 Stunden eines Jahres ein Kraftwerk bei maximaler Leistung laufen müsste, um seine Jahresproduktion zu erzeugen. <a href="https://de.statista.com/statistik/daten/studie/37610/umfrage/jahresvolllaststunden-deutscher-kraftwerke-im-jahr-2009/">statista</a></p>
<p><span class="math display">\[
Jahresvolllaststunden ~ in ~ h = \frac{Summe ~ erzeugten ~ Stroms ~ in ~ MWh}{installierte ~ Leistung ~ in ~ MW}
\]</span></p>
</div>
</div>
<p>Die Jahresvolllaststunden können wie folgt berechnet werden. Die Anwendung der Methode <code>.sum</code> auf den Datensatz installierte_leistung ist nicht erforderlich, da dieser nur eine Zeile hat. Die Methode <code>.sum</code> erlaubt es aber, über den Parameter <code>numeric_only = True</code> die Datumsspalten auszuschließen.<br>
<strong>Einfache Division SeriesA / SeriesB funktioniert nicht, möglicherweise weil die Spaltennamen nicht übereinstimmen. Deshalb muss der Index für beide Series mit der Methode .reset_index(drop = True) zurückgesetzt und manuell nachgetragen werden.</strong></p>
<div id="7fa3c9bd" class="cell" data-execution_count="27">
<div class="sourceCode cell-code" id="cb31"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="co"># print(f"{erzeugung.sum(numeric_only = True)}\n")</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a><span class="co"># print(installierte_leistung.sum(numeric_only = True), "\n")</span></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Für die Division müssen die Indizes zurücksetzt werden</span></span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>jahresvolllaststunden <span class="op">=</span> erzeugung.<span class="bu">sum</span>(numeric_only <span class="op">=</span> <span class="va">True</span>).reset_index(drop <span class="op">=</span> <span class="va">True</span>).divide(installierte_leistung.<span class="bu">sum</span>(numeric_only <span class="op">=</span> <span class="va">True</span>).reset_index(drop <span class="op">=</span> <span class="va">True</span>))</span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Index neu setzen</span></span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a>jahresvolllaststunden.index <span class="op">=</span> erzeugung.<span class="bu">sum</span>(numeric_only <span class="op">=</span> <span class="va">True</span>).index.<span class="bu">str</span>.replace(pat <span class="op">=</span> <span class="st">" [MWh]"</span>, repl <span class="op">=</span> <span class="st">" [h]"</span>)</span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n\n</span><span class="ss">Jahresvolllaststunden</span><span class="ch">\n\n</span><span class="sc">{</span>jahresvolllaststunden<span class="sc">.</span>sort_values(ascending <span class="op">=</span> <span class="va">False</span>)<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>

Jahresvolllaststunden

Biomasse [h]                   4467.41
Braunkohle [h]                 4399.96
Wind Offshore [h]              2893.34
Wasserkraft [h]                2855.83
Sonstige Erneuerbare [h]       2653.47
Steinkohle [h]                 2192.86
Wind Onshore [h]               2062.55
Kernenergie [h]                1661.92
Erdgas [h]                     1576.42
Sonstige Konventionelle [h]    1293.98
Pumpspeicher [h]               1188.76
Photovoltaik [h]                883.48
dtype: float64</code></pre>
</div>
</div>
<p>Die Berechnung der Jahresstunden zeigt, dass kein Kraftwerkstyp auch nur annähernd in Volllast lief. Die höchste Auslastung weisen Biomasse und Braunkohle auf. Biomasse ist umgerechnet in 51 Prozent der 8760 Jahresstunden in Volllast gelaufen, Braunkohle in 50 Prozent. Demgegenüber erreichte der klassische Grundlasterzeuger Kernenergie nur 25 Prozent. Die in Deutschland hauptsächlich für den Mittellastbetrieb eingesetzte Steinkohle erreichte 19 Prozent. Das Jahr 2023 war insbesondere für die Kernenergie ein ungewöhnliches Jahr.</p>
<p>Deshalb wird der Jahresgang ausgewählter konventioneller Erzeuger dargestellt. Um eine hohe Auflösung zu erreichen, wird eine Darstellung auf Monatsbasis gewählt. <strong>Man könnte zusätzlich Phasen des EE-Überschusses farblich hinterlegen (mit einem flotten Grau).</strong></p>
<div class="tabset-margin-container"></div><div class="panel-tabset">
<ul class="nav nav-tabs" role="tablist"><li class="nav-item" role="presentation"><a class="nav-link active" id="tabset-6-1-tab" data-bs-toggle="tab" data-bs-target="#tabset-6-1" role="tab" aria-controls="tabset-6-1" aria-selected="true" href="">Beispielcode Kernenergie</a></li><li class="nav-item" role="presentation"><a class="nav-link" id="tabset-6-2-tab" data-bs-toggle="tab" data-bs-target="#tabset-6-2" role="tab" aria-controls="tabset-6-2" aria-selected="false" href="">Kernenergie</a></li><li class="nav-item" role="presentation"><a class="nav-link" id="tabset-6-3-tab" data-bs-toggle="tab" data-bs-target="#tabset-6-3" role="tab" aria-controls="tabset-6-3" aria-selected="false" href="">Braunkohle</a></li><li class="nav-item" role="presentation"><a class="nav-link" id="tabset-6-4-tab" data-bs-toggle="tab" data-bs-target="#tabset-6-4" role="tab" aria-controls="tabset-6-4" aria-selected="false" href="">Steinkohle</a></li><li class="nav-item" role="presentation"><a class="nav-link" id="tabset-6-5-tab" data-bs-toggle="tab" data-bs-target="#tabset-6-5" role="tab" aria-controls="tabset-6-5" aria-selected="false" href="">Erdgas</a></li></ul>
<div class="tab-content">
<div id="tabset-6-1" class="tab-pane active" role="tabpanel" aria-labelledby="tabset-6-1-tab">
<div id="f1f6c804" class="cell" data-execution_count="28">
<div class="sourceCode cell-code" id="cb33"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>plotting_data <span class="op">=</span> erzeugung.copy()</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>erzeuger <span class="op">=</span> <span class="st">"Kernenergie"</span></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> plt.figure(figsize <span class="op">=</span> (<span class="dv">8</span>, <span class="dv">12</span>))</span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a>fig.suptitle(erzeuger, fontsize <span class="op">=</span> <span class="dv">12</span>)</span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="dv">13</span>):</span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a>  plotting_data_monthly <span class="op">=</span> plotting_data[plotting_data[<span class="st">'Datum von'</span>].dt.month <span class="op">==</span> i]</span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true" tabindex="-1"></a>  ax <span class="op">=</span> fig.add_subplot(<span class="dv">12</span>, <span class="dv">1</span>, i)</span>
<span id="cb33-10"><a href="#cb33-10" aria-hidden="true" tabindex="-1"></a>  ax.plot(plotting_data_monthly[erzeuger <span class="op">+</span> <span class="st">" [MWh]"</span>])</span>
<span id="cb33-11"><a href="#cb33-11" aria-hidden="true" tabindex="-1"></a>  plt.margins(x <span class="op">=</span> <span class="fl">0.01</span>)</span>
<span id="cb33-12"><a href="#cb33-12" aria-hidden="true" tabindex="-1"></a>  ax.set_ylabel(ylabel <span class="op">=</span> <span class="st">"MWh"</span>)</span>
<span id="cb33-13"><a href="#cb33-13" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb33-14"><a href="#cb33-14" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Titel erzeugen</span></span>
<span id="cb33-15"><a href="#cb33-15" aria-hidden="true" tabindex="-1"></a>  plt.title(label <span class="op">=</span> plotting_data_monthly[<span class="st">'Datum von'</span>].head(<span class="dv">1</span>).dt.strftime(<span class="st">'%B'</span>).item(), fontsize <span class="op">=</span> <span class="dv">10</span>)</span>
<span id="cb33-16"><a href="#cb33-16" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb33-17"><a href="#cb33-17" aria-hidden="true" tabindex="-1"></a>  <span class="co"># xticks erzeugen</span></span>
<span id="cb33-18"><a href="#cb33-18" aria-hidden="true" tabindex="-1"></a>  tage_index <span class="op">=</span> plotting_data_monthly[<span class="op">~</span>plotting_data_monthly[<span class="st">"Datum von"</span>].dt.day.duplicated()].index</span>
<span id="cb33-19"><a href="#cb33-19" aria-hidden="true" tabindex="-1"></a>  tagesnamen <span class="op">=</span> plotting_data_monthly[<span class="st">"Datum von"</span>].dt.day.unique() </span>
<span id="cb33-20"><a href="#cb33-20" aria-hidden="true" tabindex="-1"></a>  plt.xticks(tage_index, tagesnamen, fontsize <span class="op">=</span> <span class="dv">8</span>)</span>
<span id="cb33-21"><a href="#cb33-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-22"><a href="#cb33-22" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<div id="tabset-6-2" class="tab-pane" role="tabpanel" aria-labelledby="tabset-6-2-tab">
<div id="c244f5ce" class="cell" data-execution_count="29">
<div class="cell-output cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="Energiedatenauswertung_files/figure-html/cell-30-output-1.png" width="758" height="1134" class="figure-img"></p>
<figcaption>Jahresgang Kernenergie</figcaption>
</figure>
</div>
</div>
</div>
</div>
<div id="tabset-6-3" class="tab-pane" role="tabpanel" aria-labelledby="tabset-6-3-tab">
<div id="42457852" class="cell" data-execution_count="30">
<div class="cell-output cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="Energiedatenauswertung_files/figure-html/cell-31-output-1.png" width="758" height="1134" class="figure-img"></p>
<figcaption>Jahresgang Braunkohle</figcaption>
</figure>
</div>
</div>
</div>
</div>
<div id="tabset-6-4" class="tab-pane" role="tabpanel" aria-labelledby="tabset-6-4-tab">
<div id="34aad412" class="cell" data-execution_count="31">
<div class="cell-output cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="Energiedatenauswertung_files/figure-html/cell-32-output-1.png" width="758" height="1134" class="figure-img"></p>
<figcaption>Jahresgang Steinkohle</figcaption>
</figure>
</div>
</div>
</div>
</div>
<div id="tabset-6-5" class="tab-pane" role="tabpanel" aria-labelledby="tabset-6-5-tab">
<div id="ddcca174" class="cell" data-execution_count="32">
<div class="cell-output cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="Energiedatenauswertung_files/figure-html/cell-33-output-1.png" width="758" height="1134" class="figure-img"></p>
<figcaption>Jahresgang Erdgas</figcaption>
</figure>
</div>
</div>
</div>
</div>
</div>
</div>
<p>Im Reiter Kernenergie ist zu erkennen, dass 2023 die letzten deutschen Atomkraftwerke Emsland, Isar 2 und Neckarwestheim 2 vom Netz genommen wurden. Für diese wurde im Herbst 2022 aufgrund der Energiekrise ein über den ursprünglichen Abschalttermin zum 31. Dezember 2022 hinausgehender Streckbetrieb beschlossen. <a href="https://www.bmwk.de/Redaktion/DE/Pressemitteilungen/2023/04/20230413-deutschland-beendet-das-zeitalter-der-atomkraft.html">BMWK</a></p>
<p><strong>Bis zu welchem Tag wurde der Streckbetrieb genehmigt? Bestimmen Sie den Zeitpunkt der Abschaltung anhand des Datensatzes erzeugung. Geben Sie den Zeitpunkt über die Spalte ‘Datum bis’ in deutscher Datumsformtierung `TT. Monat YYYY um HH:MM Uhr’ aus.</strong></p>
<div id="tip-abschaltung-akw" class="callout callout-style-default callout-tip callout-titled" title="Lösungshinweis und Musterlösung">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-17-contents" aria-controls="callout-17" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip&nbsp;8: Lösungshinweis und Musterlösung
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-17" class="callout-17-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>Mit der Abschaltung erreichte die Stromproduktion durch Kernenergie den Wert 0. Die Abschaltung wurde in der Periode vollendet, die der ersten Periode mit der Stromproduktion durch Kernenergie mit dem Wert 0 vorausging.</p>
<p>Die Ausgabe einer als datetime formatierten Spalten können Sie mit der Methode <a href="https://pandas.pydata.org/docs/reference/api/pandas.Series.dt.strftime.html">pandas.Series.dt.strftime</a> formatieren.</p>
<div id="tip-abschaltung-akw" class="callout callout-style-default callout-tip callout-titled" title="Musterlösung">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-16-contents" aria-controls="callout-16" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip&nbsp;7: Musterlösung
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-16" class="callout-16-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p>In der graphischen Darstellung des Jahresgangs wurde nur jeder 100. Wert geplottet, sodass es möglich ist, dass die Stromerzeugung bereits vor der endgültigen Abschaltung den Wert Null erreichte. Es ist deshalb zuverlässiger, den Datensatz rückwärts zu durchsuchen.</p>
<p>In der Vorwärtssuche wird mit der Methode <code>.eq()</code>die Position des ersten Auftretens des Werts 0 bestimmt und 1 subtrahiert. In der Rückwärtssuche wird mit der Methode <code>.gt()</code> die Position des ersten Werts bestimmt, der größer als 0 ist.</p>
<div id="b7c73afd" class="cell" data-execution_count="33">
<div class="sourceCode cell-code" id="cb34"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Vorwärtssuche: erzeugung['Kernenergie [MWh]'].eq(0).idxmax() - 1</span><span class="ch">\n</span><span class="sc">{</span>erzeugung[<span class="st">'Kernenergie [MWh]'</span>]<span class="sc">.</span>eq(<span class="dv">0</span>)<span class="sc">.</span>idxmax() <span class="op">-</span> <span class="dv">1</span><span class="sc">}</span><span class="ch">\n</span><span class="ss">"</span>)</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a><span class="co"># rückwärts</span></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Rückwärtssuche: position := erzeugung['Kernenergie [MWh]'].iloc[::-1].gt(0).idxmax()</span><span class="ch">\n</span><span class="sc">{</span> ( position <span class="op">:=</span> erzeugung[<span class="st">'Kernenergie [MWh]'</span>].iloc[::<span class="op">-</span><span class="dv">1</span>].gt(<span class="dv">0</span>).idxmax() ) <span class="sc">}</span><span class="ch">\n</span><span class="ss">"</span>)</span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"erzeugung['Datum bis'].iloc[position].strftime('%d. %B %Y um %H:%M Uhr')</span><span class="ch">\n</span><span class="sc">{</span>erzeugung[<span class="st">'Datum bis'</span>]<span class="sc">.</span>iloc[position]<span class="sc">.</span>strftime(<span class="st">'</span><span class="sc">%d</span><span class="st">. %B %Y um %H:%M Uhr'</span>)<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Vorwärtssuche: erzeugung['Kernenergie [MWh]'].eq(0).idxmax() - 1
10075

Rückwärtssuche: position := erzeugung['Kernenergie [MWh]'].iloc[::-1].gt(0).idxmax()
10075

erzeugung['Datum bis'].iloc[position].strftime('%d. %B %Y um %H:%M Uhr')
16. April 2023 um 00:00 Uhr</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<p>Die Berechnung der Jahresvolllaststunden und die Visualisierung der Jahresgänge zeigen, dass es durch den hohen Anteil volatiler erneuerbarer Stromerzeugung im deutschen Stromsystem keine Grundlast mehr gibt, die von konventionellen Erzeugern bedient werden kann. Dies bedeutet, dass alle nicht erneuerbaren Erzeuger im Lastfolgebetrieb arbeiten. Dies kann am Beispiel der Steinkohle verdeutlicht werden, deren erzielte Jahresvolllaststunden näher an der klassischen Spitzenlasterzeugung aus Erdgas als an der Mittellasterzeugung durch Braunkohle liegt. Die Auslastung eines Stromerzeugers kann mit einer sortierten Jahresdauerlinie dargestellt werden.</p>
<div class="callout callout-style-default callout-important callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Definition sortierte Jahresdauerlinie
</div>
</div>
<div class="callout-body-container callout-body">
<p>Die sortierte Jahresdauerlinie ist ein Diagramm der absteigend sortierten Daten.</p>
<div class="border">
<div class="quarto-video ratio ratio-16x9"><iframe data-external="1" src="https://www.youtube.com/embed/rMxYJuGqR4s" title="" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div>
<p>Energietechnik. 2 Einführung. 2.13 Sortierte Jahresdauerlinie von Henrik te Heesen ist lizensiert unter <a href="https://creativecommons.org/licenses/by-sa/3.0/deed.de">CC BY-SA 3.0</a> und abrufbar auf <a href="https://www.youtube.com/watch?v=rMxYJuGqR4s">YouTube</a>.</p>
</div>
</div>
</div>
<div class="tabset-margin-container"></div><div class="panel-tabset">
<ul class="nav nav-tabs" role="tablist"><li class="nav-item" role="presentation"><a class="nav-link active" id="tabset-7-1-tab" data-bs-toggle="tab" data-bs-target="#tabset-7-1" role="tab" aria-controls="tabset-7-1" aria-selected="true" href="">Plot</a></li><li class="nav-item" role="presentation"><a class="nav-link" id="tabset-7-2-tab" data-bs-toggle="tab" data-bs-target="#tabset-7-2" role="tab" aria-controls="tabset-7-2" aria-selected="false" href="">Code für den Plot</a></li></ul>
<div class="tab-content">
<div id="tabset-7-1" class="tab-pane active" role="tabpanel" aria-labelledby="tabset-7-1-tab">
<div id="d3f8b5af" class="cell" data-execution_count="34">
<div class="cell-output cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="Energiedatenauswertung_files/figure-html/cell-35-output-1.png" width="691" height="376" class="figure-img"></p>
<figcaption>sortierte Jahresdauerlinie ausgewählter konventioneller Erzeuger</figcaption>
</figure>
</div>
</div>
</div>
</div>
<div id="tabset-7-2" class="tab-pane" role="tabpanel" aria-labelledby="tabset-7-2-tab">
<div id="6550adc0" class="cell" data-execution_count="35">
<div class="sourceCode cell-code" id="cb36"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Daten nach Tag gruppieren und durch Mittelwertbildung auf Tagesbasis aggregieren.</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>braunkohle_daily <span class="op">=</span> erzeugung[<span class="st">'Braunkohle [MWh]'</span>].groupby(erzeugung[<span class="st">"Datum von"</span>].dt.dayofyear).mean()</span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a>steinkohle_daily <span class="op">=</span> erzeugung[<span class="st">'Steinkohle [MWh]'</span>].groupby(erzeugung[<span class="st">"Datum von"</span>].dt.dayofyear).mean()</span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a>erdgas_daily <span class="op">=</span> erzeugung[<span class="st">'Erdgas [MWh]'</span>].groupby(erzeugung[<span class="st">"Datum von"</span>].dt.dayofyear).mean()</span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a><span class="co">## Zur Kontrolle</span></span>
<span id="cb36-7"><a href="#cb36-7" aria-hidden="true" tabindex="-1"></a><span class="co">## print(erzeugung["Datum von"].dt.dayofyear)</span></span>
<span id="cb36-8"><a href="#cb36-8" aria-hidden="true" tabindex="-1"></a><span class="co">## print(f"\n\nbraunkohle_daily.head()\n{braunkohle_daily.head()}\n\n"</span></span>
<span id="cb36-9"><a href="#cb36-9" aria-hidden="true" tabindex="-1"></a><span class="co">##       f"Zum Vergleich:\nerzeugung['Braunkohle [MWh]'].iloc[[0, 1, 95, 96]]\n{erzeugung['Braunkohle [MWh]'].iloc[[0, 1, 95, 96]]}\n\n"</span></span>
<span id="cb36-10"><a href="#cb36-10" aria-hidden="true" tabindex="-1"></a><span class="co">##       f"erzeugung['Braunkohle [MWh]'].iloc[0:96].mean()\n{erzeugung['Braunkohle [MWh]'].iloc[0:96].mean()}") </span></span>
<span id="cb36-11"><a href="#cb36-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-12"><a href="#cb36-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Liniendiagramm plotten</span></span>
<span id="cb36-13"><a href="#cb36-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Index um 1 verschieben, weil Index mit 0 beginnt, aber die Anzahl der Tage dargestellt wird.</span></span>
<span id="cb36-14"><a href="#cb36-14" aria-hidden="true" tabindex="-1"></a>linienstärke <span class="op">=</span> <span class="dv">5</span></span>
<span id="cb36-15"><a href="#cb36-15" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize <span class="op">=</span> (<span class="dv">8</span>, <span class="dv">4</span>))</span>
<span id="cb36-16"><a href="#cb36-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-17"><a href="#cb36-17" aria-hidden="true" tabindex="-1"></a>braunkohle_daily <span class="op">=</span> braunkohle_daily.sort_values(ascending <span class="op">=</span> <span class="va">False</span>, ignore_index <span class="op">=</span> <span class="va">True</span>)</span>
<span id="cb36-18"><a href="#cb36-18" aria-hidden="true" tabindex="-1"></a>braunkohle_daily.index <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb36-19"><a href="#cb36-19" aria-hidden="true" tabindex="-1"></a>braunkohle_daily.plot.line(lw <span class="op">=</span> linienstärke, color <span class="op">=</span> <span class="st">'brown'</span>, alpha <span class="op">=</span> <span class="fl">0.5</span>, label <span class="op">=</span> <span class="st">'Braunkohle'</span>)</span>
<span id="cb36-20"><a href="#cb36-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-21"><a href="#cb36-21" aria-hidden="true" tabindex="-1"></a>steinkohle_daily <span class="op">=</span> steinkohle_daily.sort_values(ascending <span class="op">=</span> <span class="va">False</span>, ignore_index <span class="op">=</span> <span class="va">True</span>)</span>
<span id="cb36-22"><a href="#cb36-22" aria-hidden="true" tabindex="-1"></a>steinkohle_daily.index <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb36-23"><a href="#cb36-23" aria-hidden="true" tabindex="-1"></a>steinkohle_daily.plot.line(lw <span class="op">=</span> linienstärke, color <span class="op">=</span> <span class="st">'black'</span>, alpha <span class="op">=</span> <span class="fl">0.5</span>, label <span class="op">=</span> <span class="st">'Steinkohle'</span>)</span>
<span id="cb36-24"><a href="#cb36-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-25"><a href="#cb36-25" aria-hidden="true" tabindex="-1"></a>erdgas_daily <span class="op">=</span> erdgas_daily.sort_values(ascending <span class="op">=</span> <span class="va">False</span>, ignore_index <span class="op">=</span> <span class="va">True</span>)</span>
<span id="cb36-26"><a href="#cb36-26" aria-hidden="true" tabindex="-1"></a>erdgas_daily.index <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb36-27"><a href="#cb36-27" aria-hidden="true" tabindex="-1"></a>erdgas_daily.plot.line(lw <span class="op">=</span> linienstärke, color <span class="op">=</span> <span class="st">'lightskyblue'</span>, alpha <span class="op">=</span> <span class="fl">0.5</span>, label <span class="op">=</span> <span class="st">'Erdgas'</span>)</span>
<span id="cb36-28"><a href="#cb36-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-29"><a href="#cb36-29" aria-hidden="true" tabindex="-1"></a>plt.title(label <span class="op">=</span> <span class="st">"sortierte Jahresdauerlinie für ausgewählte konventionelle Erzeuger"</span>)</span>
<span id="cb36-30"><a href="#cb36-30" aria-hidden="true" tabindex="-1"></a>plt.grid()</span>
<span id="cb36-31"><a href="#cb36-31" aria-hidden="true" tabindex="-1"></a>plt.legend()</span>
<span id="cb36-32"><a href="#cb36-32" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">'durchschnittliche Stromerzeugung in MWh</span><span class="ch">\n</span><span class="st">(auf Viertelstundenbasis)'</span>)</span>
<span id="cb36-33"><a href="#cb36-33" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'Anzahl Tage pro Jahr'</span>)</span>
<span id="cb36-34"><a href="#cb36-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb36-35"><a href="#cb36-35" aria-hidden="true" tabindex="-1"></a>plt.margins(x <span class="op">=</span> <span class="fl">0.02</span>)</span>
<span id="cb36-36"><a href="#cb36-36" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
</div>
</div>
<p>Beim Vergleich der erzielten Jahresvolllaststunden konnte festgestellt werden, dass die Auslastung der Steinkohle eher der des Spitzenlasterzeugers Erdgas als des Mittellasterzeugers Braunkohle entspricht. In der grafischen Darstellung der sortierten Jahresdauerlinien wird darüber hinaus deutlich, dass das Erzeugungsprofil der Steinkohle dem der Braunkohle sogar weniger ähnelt als dem von Erdgas.</p>
<p>Bisher wurde ausschließlich die Erzeugung durch konventionelle Kraftwerke betrachtet. Biomasse und Braunkohle erreichen vergleichbare Jahresvolllaststunden, sodass ein Vergleich beider Erzeuger interessant sein könnte. <strong>Stellen Sie den Jahresgang und die Jahresdauerlinien für Biomasse und Braunkohle dar.</strong></p>
<p><strong>Die Musterlösung könnte Marc machen.</strong></p>
<div id="tip-erzeugungsprofile-biomasse-braunkohle" class="callout callout-style-default callout-tip callout-titled" title="Musterlösung Erzeugungsprofile von Biomasse und Braunkohle">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-19-contents" aria-controls="callout-19" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip&nbsp;9: Musterlösung Erzeugungsprofile von Biomasse und Braunkohle
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-19" class="callout-19-contents callout-collapse collapse">
<div class="callout-body-container callout-body">

</div>
</div>
</div>
</section>
<section id="sec-Pumpspeicherinhalt" class="level2" data-number="7.6">
<h2 data-number="7.6" class="anchored" data-anchor-id="sec-Pumpspeicherinhalt"><span class="header-section-number">7.6</span> Bestimmung des in den Pumpspeichern gespeicherten Stroms</h2>
<p>In den bisherigen Betrachtungen wurde gezeigt, dass zwei grundsätzliche Szenarien im Stromnetz zu unterscheiden sind:</p>
<ol type="1">
<li><p>Restlast Null oder negativ: Grenzstrom wird von erneuerbaren Energien produziert.</p></li>
<li><p>Restlast positiv: Grenzstrom wird von konventionellen Energien im Lastfolgebetrieb produziert.</p></li>
</ol>
<p>Den Jahresgang des Stromverbrauchs durch Pumpspeicher und das jeweils bestehende Szenario zeigt folgender Graph, der jeden 100. Wert der Datenreihe verbrauch[‘Pumpspeicher [MWh]’] darstellt.</p>
<div class="tabset-margin-container"></div><div class="panel-tabset">
<ul class="nav nav-tabs" role="tablist"><li class="nav-item" role="presentation"><a class="nav-link active" id="tabset-8-1-tab" data-bs-toggle="tab" data-bs-target="#tabset-8-1" role="tab" aria-controls="tabset-8-1" aria-selected="true" href="">Plot</a></li><li class="nav-item" role="presentation"><a class="nav-link" id="tabset-8-2-tab" data-bs-toggle="tab" data-bs-target="#tabset-8-2" role="tab" aria-controls="tabset-8-2" aria-selected="false" href="">Code für den Plot</a></li></ul>
<div class="tab-content">
<div id="tabset-8-1" class="tab-pane active" role="tabpanel" aria-labelledby="tabset-8-1-tab">
<div id="5ed33821" class="cell" data-execution_count="36">
<div class="cell-output cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="Energiedatenauswertung_files/figure-html/cell-37-output-1.png" width="753" height="591" class="figure-img"></p>
<figcaption>Einspeicherung in Pumpspeicherkraftwerke 2023</figcaption>
</figure>
</div>
</div>
</div>
</div>
<div id="tabset-8-2" class="tab-pane" role="tabpanel" aria-labelledby="tabset-8-2-tab">
<div id="cc91139a" class="cell" data-execution_count="37">
<div class="sourceCode cell-code" id="cb37"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Restlast berechnen</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>erneuerbare <span class="op">=</span> [<span class="st">'Biomasse [MWh]'</span>, <span class="st">'Wasserkraft [MWh]'</span>, <span class="st">'Wind Offshore [MWh]'</span>, <span class="st">'Wind Onshore [MWh]'</span>, <span class="st">'Photovoltaik [MWh]'</span>, <span class="st">'Sonstige Erneuerbare [MWh]'</span>]</span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a>restlast <span class="op">=</span> pd.DataFrame()</span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a>restlast[<span class="st">"Netzlast [MWh]"</span>] <span class="op">=</span> verbrauch[<span class="st">"Gesamt (Netzlast) [MWh]"</span>].copy() </span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a>restlast[<span class="st">"Erneuerbare [MWh]"</span>] <span class="op">=</span> erzeugung[erneuerbare].<span class="bu">sum</span>(axis <span class="op">=</span> <span class="st">"columns"</span>).copy()</span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a>restlast[<span class="st">"Restlast [MWh]"</span>] <span class="op">=</span> restlast[<span class="st">"Netzlast [MWh]"</span>] <span class="op">-</span> restlast[<span class="st">"Erneuerbare [MWh]"</span>]</span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true" tabindex="-1"></a>restlast <span class="op">=</span> restlast[<span class="st">"Restlast [MWh]"</span>]</span>
<span id="cb37-9"><a href="#cb37-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-10"><a href="#cb37-10" aria-hidden="true" tabindex="-1"></a><span class="co"># xticks berechnen</span></span>
<span id="cb37-11"><a href="#cb37-11" aria-hidden="true" tabindex="-1"></a>monate_index <span class="op">=</span> erzeugung[<span class="op">~</span>erzeugung[<span class="st">"Datum von"</span>].dt.month.duplicated()].index</span>
<span id="cb37-12"><a href="#cb37-12" aria-hidden="true" tabindex="-1"></a>monatsnamen <span class="op">=</span> erzeugung[<span class="st">"Datum von"</span>].iloc[monate_index].dt.strftime(<span class="st">"%B"</span>) </span>
<span id="cb37-13"><a href="#cb37-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-14"><a href="#cb37-14" aria-hidden="true" tabindex="-1"></a><span class="co"># plotten jedes n. Werts</span></span>
<span id="cb37-15"><a href="#cb37-15" aria-hidden="true" tabindex="-1"></a>schritt <span class="op">=</span> <span class="dv">100</span></span>
<span id="cb37-16"><a href="#cb37-16" aria-hidden="true" tabindex="-1"></a>verbrauch[<span class="st">'Pumpspeicher [MWh]'</span>][::schritt].plot(figsize <span class="op">=</span> (<span class="dv">9</span>, <span class="dv">6</span>), xlim <span class="op">=</span> (verbrauch.index.<span class="bu">min</span>() <span class="op">-</span> (<span class="bu">len</span>(verbrauch.index) <span class="op">/</span> <span class="dv">100</span>), verbrauch.index.<span class="bu">max</span>() <span class="op">*</span> <span class="fl">1.01</span>), rot <span class="op">=</span> <span class="dv">45</span>, grid <span class="op">=</span> <span class="va">True</span>, label <span class="op">=</span> <span class="st">""</span>)</span>
<span id="cb37-17"><a href="#cb37-17" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">'Einspeicherung [MWh]'</span>, fontsize <span class="op">=</span> <span class="dv">12</span>)</span>
<span id="cb37-18"><a href="#cb37-18" aria-hidden="true" tabindex="-1"></a>plt.suptitle(<span class="st">'Einspeicherung in Pumpspeicherkraftwerke 2023'</span>)</span>
<span id="cb37-19"><a href="#cb37-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-20"><a href="#cb37-20" aria-hidden="true" tabindex="-1"></a><span class="co"># xticks eintragen</span></span>
<span id="cb37-21"><a href="#cb37-21" aria-hidden="true" tabindex="-1"></a>plt.minorticks_off()</span>
<span id="cb37-22"><a href="#cb37-22" aria-hidden="true" tabindex="-1"></a>plt.xticks(monate_index, monatsnamen)<span class="op">;</span></span>
<span id="cb37-23"><a href="#cb37-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-24"><a href="#cb37-24" aria-hidden="true" tabindex="-1"></a><span class="co"># Kurve unterlegen: plt.fill_between bietet einen praktischen Parameter where</span></span>
<span id="cb37-25"><a href="#cb37-25" aria-hidden="true" tabindex="-1"></a>plt.fill_between(x <span class="op">=</span> verbrauch[<span class="st">'Pumpspeicher [MWh]'</span>].index[::schritt], y1 <span class="op">=</span> verbrauch[<span class="st">'Pumpspeicher [MWh]'</span>][::schritt], label <span class="op">=</span> <span class="st">'konventionelle Einspeicherung'</span>) <span class="co"># , where = restlast[::schritt] &gt; 0 führt zu weißen Stellen</span></span>
<span id="cb37-26"><a href="#cb37-26" aria-hidden="true" tabindex="-1"></a>plt.fill_between(x <span class="op">=</span> verbrauch[<span class="st">'Pumpspeicher [MWh]'</span>].index[::schritt], y1 <span class="op">=</span> verbrauch[<span class="st">'Pumpspeicher [MWh]'</span>][::schritt], where <span class="op">=</span> restlast[::schritt] <span class="op">&lt;=</span> <span class="dv">0</span>, color <span class="op">=</span> <span class="st">'greenyellow'</span>, label <span class="op">=</span> <span class="st">'erneuerbare Einspeicherung'</span>)</span>
<span id="cb37-27"><a href="#cb37-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-28"><a href="#cb37-28" aria-hidden="true" tabindex="-1"></a>plt.legend()</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
</div>
</div>
<p>Die Grafik spiegelt die bei der Bestimmung der Residual- und Restlast gewonnene Erkenntnis wider, dass mit dem im Jahr 2023 realisierten Strommix zusätzliche Stromnachfrage vorwiegend konventionell bedient wird. <strong>Wie sähe die Grafik aus, wenn die Einspeisung aus erneuerbaren Energien doppelt so hoch ausgefallen wäre?</strong></p>
<p><strong>Marc fragen, ob die Aufgabe an der Stelle zu simpel ist.</strong></p>
<div id="tip-pumpspeicher" class="callout callout-style-default callout-tip callout-titled" title="Musterlösung Einspeicherung bei doppelter erneuerbarer Erzeugung">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-20-contents" aria-controls="callout-20" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip&nbsp;10: Musterlösung Einspeicherung bei doppelter erneuerbarer Erzeugung
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-20" class="callout-20-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<div id="cd37c36e" class="cell" data-execution_count="38">
<div class="cell-output cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="Energiedatenauswertung_files/figure-html/cell-39-output-1.png" width="753" height="591" class="figure-img"></p>
<figcaption>Einspeicherung in Pumpspeicherkraftwerke 2023</figcaption>
</figure>
</div>
</div>
</div>
</div>
</div>
</div>
</section>
<section id="aufgabe-explorative-datenanalyse" class="level2" data-number="7.7">
<h2 data-number="7.7" class="anchored" data-anchor-id="aufgabe-explorative-datenanalyse"><span class="header-section-number">7.7</span> Aufgabe explorative Datenanalyse</h2>
<div class="border">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="aufgaben/00-bilder/960px-StauseeMooserboden_von_Tigerente_CC_BY-SA_3.0.jpg" class="img-fluid figure-img" style="width:80.0%"></p>
<figcaption>&nbsp;</figcaption>
</figure>
</div>
<p>Ober- und Hauptstufe der Kraftwerksgruppe: Mooser- und Wasserfallboden mit Karlingerkees links oben, im Hintergrund rechts der Großvenediger von Tigerente ist lizensiert unter <a href="https://creativecommons.org/licenses/by-sa/3.0/de/deed.de">CC BY-SA 3.0</a> und abrufbar auf <a href="https://commons.wikimedia.org/w/index.php?curid=4595972">wikimedia.org</a>. 2008</p>
</div>
<p>&nbsp;</p>
<p><strong>Stellen Sie den Jahresgang des Stromverbrauchs durch Pumpspeicher in Österreich 2023 dar.</strong> Hinweise zum Einlesen der Daten finden Sie in Abschnitt <a href="#sec-aufgabe-beschreibende-Datenanalyse" class="quarto-xref">Kapitel&nbsp;6.2</a>.</p>
<p><strong>Die Musterlösung kann Marc erstellen</strong></p>
<div class="callout callout-style-default callout-tip callout-titled" title="Musterlösung Aufgabe explorative Datenanalyse">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-21-contents" aria-controls="callout-21" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Musterlösung Aufgabe explorative Datenanalyse
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-21" class="callout-21-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<p><em>Platzhalter</em></p>
</div>
</div>
</div>
</section>
</section>
<section id="schließende-datenanalyse" class="level1" data-number="8">
<h1 data-number="8"><span class="header-section-number">8</span> Schließende Datenanalyse</h1>
<p>Schließende Datenanalyse bedeutet, auf Grundlage der Daten Rückschlüsse zu ziehen. Die schließende Datenanalyse unterscheidet sich von der beschreibenden und explorativen Datenanalyse dadurch, dass Daten nicht nur betrachtet und zueinander ins Verhältnis gesetzt werden, sondern neue Daten erzeugt werden.</p>
<p>Bei der explorativen Analyse der Erzeugungsdaten konnte festgestellt werden, dass im Jahr 2023 punktuell bereits eine Vollversorgung aus erneuerbaren Energien erreicht wird. Aus der Betrachtung der verdoppelten erneuerbaren Stromerzeugung des Jahres 2023 (siehe <a href="#tip-verdopplung-EE" class="quarto-xref">Tip&nbsp;6</a>) kann geschlussfolgert werden, dass mit zunehmenden Ausbau der erneuerbaren Stromproduktion Phasen erneuerbarer Überproduktion immer häufiger der Fall sein werden. Die Perspektive regelmäßiger erneuerbarer Produktionsüberschüsse begründet einen Bedarf für Stromspeicher, um Strom aus Phasen der Überproduktion in Phasen mit positiver Restlast nutzbar zu machen.</p>
<p>In diesem Abschnitt wird der daraus resultierende Speicherbedarf betrachtet.</p>
<div class="callout callout-style-simple callout-warning callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Hinweis
</div>
</div>
<div class="callout-body-container callout-body">
<p>Die folgenden Rechnungen finden im sogenannten „Kupferplattenmodell“ auf der Grundlage der von der Bundesnetzgentur veröffentlichten Aggregatdaten zur Stromerzeugung und zum Stromverbrauch statt. In der Realität spielen die verfügbaren Kapazitäten zum Stromtransport eine wichtige Rolle bei der Auslegung eines Stromsystems. Diese werden hier aber nur insoweit berücksichtigt, als dass die Daten die tatsächlich realisierte Stromerzeugung im deutschen Stromsystem widerspiegeln. So wird auch die Abregelung erneuerbarer Stromerzeugung vernachlässigt. Diese betrug im Rahmen des Netzengpassmanagements im ersten Quartal 2023 5,29 Prozent der erneuerbaren Erzeugung (<a href="https://dserver.bundestag.de/btd/20/090/2009016.pdf">Deutscher Bundestag Drucksache 20/9016, S. 2</a>).</p>
<p>Ebenfalls bleibt der Stromhandel zum Ausland unberücksichtigt (siehe Differenz Netzlast und Stromerzeugung).</p>
</div>
</div>
<section id="hintergrund-ausbaupfad-erneuerbarer-energien" class="level2" data-number="8.1">
<h2 data-number="8.1" class="anchored" data-anchor-id="hintergrund-ausbaupfad-erneuerbarer-energien"><span class="header-section-number">8.1</span> Hintergrund: Ausbaupfad erneuerbarer Energien</h2>
<p>In Deutschland begann der Ausbau erneuerbarer Energien in den 1990er Jahren. Seit dem Beginn der 2000er Jahre stieg die erneuerbare Stromerzeugung weitgehend kontinuierlich an.</p>
<div class="border">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://www.volker-quaschning.de/datserv/ren-Strom-D/ren-Strom-D.png" class="img-fluid figure-img"></p>
<figcaption>Regenerative Strom­erzeugung in Deutschland seit 1990</figcaption>
</figure>
</div>
<p>Regenerative Strom­erzeugung in Deutschland seit 1990 von Volker Quaschning nach Daten der AG Energiebilanzen (<a href="https://ag-energiebilanzen.de/wp-content/uploads/2024/04/STRERZ_Abg_02_2024_korr.xlsx">Stromerzeugung nach Energieträgern (Strommix) von 1990 bis 2022 (in TWh) Deutschland insgesamt (XLSX)</a>) ist lizensiert unter <a href="http://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a> und abrufbar unter <a href="https://www.volker-quaschning.de/datserv/ren-Strom-D/index.php" class="uri">https://www.volker-quaschning.de/datserv/ren-Strom-D/index.php</a>. 2023</p>
</div>
<p>&nbsp;</p>
<p>Das Erneuerbare-Energien Gesetz legt in Paragraph 4 Ausbaupfade für die installierte Leistung von Solarenergie, Windenergie an Land sowie für Biomasse fest. Der Ausbaupfad für Windenergie auf See ist in Paragraph 1 des Windenergie-auf-See-Gesetzes geregelt.</p>
<div class="callout callout-style-simple callout-warning callout-titled" title="Gesetzliche Grundlagen des erneuerbaren Ausbaupfads">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-23-contents" aria-controls="callout-23" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Gesetzliche Grundlagen des erneuerbaren Ausbaupfads
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-23" class="callout-23-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<div>

</div>
<div class="border quarto-layout-panel" data-layout="[[5, 90, 5], [1], [1], [5, 90, 5], [1]]">
<div class="quarto-layout-row">
<div class="quarto-layout-cell" style="flex-basis: 5.0%;justify-content: flex-start;">
<p>&nbsp;</p>
</div>
<div class="quarto-layout-cell" style="flex-basis: 90.0%;justify-content: flex-start;">
<p><strong>§ 4 Ausbaupfad</strong><br>
[…]<br>
1. eine Steigerung der installierten Leistung von Windenergieanlagen an Land auf<br>
a) 69 Gigawatt im Jahr 2024,<br>
b) 84 Gigawatt im Jahr 2026,<br>
c) 99 Gigawatt im Jahr 2028,<br>
d) 115 Gigawatt im Jahr 2030,<br>
e) 157 Gigawatt im Jahr 2035 und<br>
f) 160 Gigawatt im Jahr 2040<br>
[…]<br>
2. eine Steigerung der installierten Leistung von Windenergieanlagen auf See nach Maßgabe des Windenergie-auf-See-Gesetzes,<br>
3. eine Steigerung der installierten Leistung von Solaranlagen auf<br>
a) 88 Gigawatt im Jahr 2024,<br>
b) 128 Gigawatt im Jahr 2026,<br>
c) 172 Gigawatt im Jahr 2028,<br>
d) 215 Gigawatt im Jahr 2030,<br>
e) 309 Gigawatt im Jahr 2035 und<br>
f) 400 Gigawatt im Jahr 2040<br>
[…]<br>
4. eine installierte Leistung von Biomasseanlagen von 8 400 Megawatt im Jahr 2030.</p>
</div>
<div class="quarto-layout-cell" style="flex-basis: 5.0%;justify-content: flex-start;">
<p>&nbsp;</p>
</div>
</div>
<div class="quarto-layout-row">
<div class="quarto-layout-cell" style="flex-basis: 100.0%;justify-content: flex-start;">
<p>Gesetz für den Ausbau erneuerbarer Energien (Erneuerbare-Energien-Gesetz - EEG 2023) <a href="https://www.gesetze-im-internet.de/eeg_2014/__4.html">Bundesministerium der Justiz</a></p>
</div>
</div>
<div class="quarto-layout-row">
<div class="quarto-layout-cell" style="flex-basis: 100.0%;justify-content: flex-start;">
<p>&nbsp;</p>
</div>
</div>
<div class="quarto-layout-row">
<div class="quarto-layout-cell" style="flex-basis: 5.0%;justify-content: flex-start;">
<p>&nbsp;</p>
</div>
<div class="quarto-layout-cell" style="flex-basis: 90.0%;justify-content: flex-start;">
<p><strong>§ 1 Zweck und Ziel des Gesetzes</strong><br>
[…]<br>
(2) Ziel dieses Gesetzes ist es, die installierte Leistung von Windenergieanlagen auf See, die an das Netz angeschlossen werden, auf insgesamt mindestens 30 Gigawatt bis zum Jahr 2030, auf insgesamt mindestens 40 Gigawatt bis zum Jahr 2035 und auf insgesamt mindestens 70 Gigawatt bis zum Jahr 2045 zu steigern.</p>
</div>
<div class="quarto-layout-cell" style="flex-basis: 5.0%;justify-content: flex-start;">
<p>&nbsp;</p>
</div>
</div>
<div class="quarto-layout-row">
<div class="quarto-layout-cell" style="flex-basis: 100.0%;justify-content: flex-start;">
<p>Gesetz zur Entwicklung und Förderung der Windenergie auf See (Windenergie-auf-See-Gesetz - WindSeeG) <a href="https://www.gesetze-im-internet.de/windseeg/BJNR231000016.html">Bundesministerium der Justiz</a></p>
</div>
</div>
</div>
</div>
</div>
</div>
<p>Die Ausbauziele der Bundesregierung legen für das Jahr 2030 bzw. 2035 eine installierte Leistung fest in Höhe von:</p>
<ul>
<li><p>115 GW Wind an Land bis 2030, 157 GW bis 2035,</p></li>
<li><p>30 GW Wind auf See bis 2030, 40 GW bis 2035,</p></li>
<li><p>215 GW Solar bis 2030, 309 GW bis 2035 sowie</p></li>
<li><p>8,4 GW Biomasse.</p></li>
</ul>
<p>Dies bedeutet einen geplanten Zubau der installierten Leistung gemessen an der installierten Leistung im Jahr 2023 von:</p>
<div id="lst-zubaufaktoren" class="listing quarto-float">
<figure class="quarto-float quarto-float-lst figure">
<div aria-describedby="lst-zubaufaktoren-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div id="01ca2444" class="cell" data-execution_count="39">
<div class="sourceCode cell-code" id="cb38"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Wind an Land 2030:</span><span class="ch">\t</span><span class="sc">{</span>( zubaufaktor_windonshore_2030 <span class="op">:=</span> <span class="dv">115</span> <span class="op">/</span> (installierte_leistung[<span class="st">'Wind Onshore [MW]'</span>].<span class="bu">sum</span>() <span class="op">/</span> <span class="dv">1000</span>) )<span class="sc">:,.2f}</span><span class="ch">\n</span><span class="ss">"</span></span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>      <span class="ss">f"Wind auf See 2030:</span><span class="ch">\t</span><span class="sc">{</span>( zubaufaktor_windoffshore_2030 <span class="op">:=</span> <span class="dv">30</span> <span class="op">/</span> (installierte_leistung[<span class="st">'Wind Offshore [MW]'</span>].<span class="bu">sum</span>() <span class="op">/</span> <span class="dv">1000</span>) )<span class="sc">:,.2f}</span><span class="ch">\n</span><span class="ss">"</span></span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a>      <span class="ss">f"Solar 2030:</span><span class="ch">\t\t\t</span><span class="sc">{</span>( zubaufaktor_solar_2030 <span class="op">:=</span> <span class="dv">215</span> <span class="op">/</span> (installierte_leistung[<span class="st">'Photovoltaik [MW]'</span>].<span class="bu">sum</span>() <span class="op">/</span> <span class="dv">1000</span>) )<span class="sc">:,.2f}</span><span class="ch">\n</span><span class="ss">"</span></span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a>      <span class="ss">f"Biomasse 2030:</span><span class="ch">\t\t</span><span class="sc">{</span><span class="fl">8.4</span> <span class="op">/</span> (installierte_leistung[<span class="st">'Biomasse [MW]'</span>].<span class="bu">sum</span>() <span class="op">/</span> <span class="dv">1000</span>)<span class="sc">:,.2f}</span><span class="ss">"</span>)</span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n\n</span><span class="ss">Wind an Land 2035:</span><span class="ch">\t</span><span class="sc">{</span>( zubaufaktor_windonshore_2035 <span class="op">:=</span> <span class="dv">157</span> <span class="op">/</span> (installierte_leistung[<span class="st">'Wind Onshore [MW]'</span>].<span class="bu">sum</span>() <span class="op">/</span> <span class="dv">1000</span>) )<span class="sc">:,.2f}</span><span class="ch">\n</span><span class="ss">"</span></span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true" tabindex="-1"></a>      <span class="ss">f"Wind auf See 2035:</span><span class="ch">\t</span><span class="sc">{</span>( zubaufaktor_windoffshore_2035 <span class="op">:=</span> <span class="dv">40</span> <span class="op">/</span> (installierte_leistung[<span class="st">'Wind Offshore [MW]'</span>].<span class="bu">sum</span>() <span class="op">/</span> <span class="dv">1000</span>) )<span class="sc">:,.2f}</span><span class="ch">\n</span><span class="ss">"</span></span>
<span id="cb38-8"><a href="#cb38-8" aria-hidden="true" tabindex="-1"></a>      <span class="ss">f"Solar 2035:</span><span class="ch">\t\t\t</span><span class="sc">{</span>( zubaufaktor_solar_2035 <span class="op">:=</span> <span class="dv">309</span> <span class="op">/</span> (installierte_leistung[<span class="st">'Photovoltaik [MW]'</span>].<span class="bu">sum</span>() <span class="op">/</span> <span class="dv">1000</span>) )<span class="sc">:,.2f}</span><span class="ch">\n</span><span class="ss">"</span></span>
<span id="cb38-9"><a href="#cb38-9" aria-hidden="true" tabindex="-1"></a>      <span class="ss">f"Biomasse 2035:</span><span class="ch">\t\t</span><span class="sc">{</span><span class="fl">8.4</span> <span class="op">/</span> (installierte_leistung[<span class="st">'Biomasse [MW]'</span>].<span class="bu">sum</span>() <span class="op">/</span> <span class="dv">1000</span>)<span class="sc">:,.2f}</span><span class="ss">"</span>)</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Wind an Land 2030:  2.00
Wind auf See 2030:  3.69
Solar 2030:         3.41
Biomasse 2030:      0.99


Wind an Land 2035:  2.73
Wind auf See 2035:  4.92
Solar 2035:         4.90
Biomasse 2035:      0.99</code></pre>
</div>
</div>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-lst quarto-uncaptioned" id="lst-zubaufaktoren-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Listing&nbsp;1
</figcaption>
</figure>
</div>
<p>Bis 2030 soll die Produktion durch Windkraftanlagen an Land verdoppelt sowie durch Windkraftanlagen auf See und durch Photovoltaik verdreieinhalbfacht werden. Bis 2035 soll Windkraft an Land fast verdreifacht, Wind auf See und Photovoltaik verfünffacht werden. Biomasse soll nicht weiter ausgebaut werden. Die Zubaufaktoren werden jeweils in einem Objekt gespeichert.</p>
</section>
<section id="hintergrund-stromspeicher" class="level2" data-number="8.2">
<h2 data-number="8.2" class="anchored" data-anchor-id="hintergrund-stromspeicher"><span class="header-section-number">8.2</span> Hintergrund: Stromspeicher</h2>
<p>Stromspeicher speichern die Stromerzeugung in Überschussphasen, um die Energie in Phasen der Unterdeckung wieder abzugeben. Verschiedene Arten von Stromspeichern und ihre Einsatzgebiete werden im folgenden Video vorgestellt. Die Speichertypen unterscheiden sich grundlegend hinsichtlich ihrer Kapazität sowie der Lade- bzw. Entladeleistung.</p>
<div class="border">
<div class="quarto-video ratio ratio-16x9"><iframe data-external="1" src="https://www.youtube.com/embed/yiJ1vAAJnVA" title="" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div>
<p>Energietechnik. 14 Energiespeicherung. 14.02 Kennzahlen von Henrik te Heesen ist lizensiert unter <a href="https://creativecommons.org/licenses/by-sa/3.0/deed.de">CC BY-SA 3.0</a> und abrufbar auf <a href="https://www.youtube.com/watch?v=yiJ1vAAJnVA">YouTube</a>. 2020</p>
</div>
<div class="callout callout-style-default callout-important callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Ausgewählte Kenngrößen von Stromspeichern
</div>
</div>
<div class="callout-body-container callout-body">
<div class="border">
<ul>
<li><p>Nominale Speicherkapazität: Energiemenge, die dem Stromspeicher entnommen werden kann.</p></li>
<li><p>Nutzbare Speicherkapazität: Beschädigungsfrei nutzbarer Anteil der nominalen Speicherkapazität.</p></li>
<li><p>Entladetiefe (Depth of Discharge, DoD): Differenz zwischen maximal und minimal erlaubten Ladezustand.</p></li>
<li><p>Ladezustand (State of Charge, SoC): Verhältnis der aktuell gespeicherten Energie zur nominalen Kapazität, i. d.&nbsp;R. in Prozent angegeben.</p></li>
<li><p>Effizienz: Wirkungsgrad bei der Speicherung (Be- und Entladen und Speicherverluste wie Selbstentladung)</p></li>
</ul>
<p>Weitere Kenngrößen werden im folgenden Video vorgestellt:</p>
<div class="quarto-video ratio ratio-16x9"><iframe data-external="1" src="https://www.youtube.com/embed/0-PRS2naETE" title="" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe></div>
<p>Energietechnik. 14 Energiespeicherung. 14.03 Kenngrößen und Begriffsdefinitionen von Henrik te Heesen ist lizensiert unter <a href="https://creativecommons.org/licenses/by-sa/3.0/deed.de">CC BY-SA 3.0</a> und abrufbar auf <a href="https://www.youtube.com/watch?v=0-PRS2naETE">YouTube</a>. 2020</p>
</div>
</div>
</div>
</section>
<section id="speichergröße-berechnen" class="level2" data-number="8.3">
<h2 data-number="8.3" class="anchored" data-anchor-id="speichergröße-berechnen"><span class="header-section-number">8.3</span> Speichergröße berechnen</h2>
<p>Im Folgenden werden Grundprinzipien der Speicherauslegung und die entsprechenden Verfahren zu ihrer Berechnung entwickelt. Grundlage aller Überlegungen ist die Restlastkurve. Werte kleiner als Null entsprechen einer erneuerbaren Überschussproduktion, Werte größer als Null einer durch Lastfolgekraftwerke oder Speicher zu bedienenden Netzlast. Die Restlast wird wie folgt bestimmt:</p>
<div id="c8ca71be" class="cell" data-execution_count="40">
<div class="sourceCode cell-code" id="cb40"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a>erneuerbare <span class="op">=</span> [<span class="st">'Biomasse [MWh]'</span>, <span class="st">'Wasserkraft [MWh]'</span>, <span class="st">'Wind Offshore [MWh]'</span>, <span class="st">'Wind Onshore [MWh]'</span>, <span class="st">'Photovoltaik [MWh]'</span>, <span class="st">'Sonstige Erneuerbare [MWh]'</span>]</span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a>restlast <span class="op">=</span> pd.DataFrame()</span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a>restlast[<span class="st">"Netzlast [MWh]"</span>] <span class="op">=</span> verbrauch[<span class="st">"Gesamt (Netzlast) [MWh]"</span>].copy() </span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a>restlast[<span class="st">"Erneuerbare [MWh]"</span>] <span class="op">=</span> erzeugung[erneuerbare].<span class="bu">sum</span>(axis <span class="op">=</span> <span class="st">"columns"</span>).copy()</span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a>restlast[<span class="st">"Restlast [MWh]"</span>] <span class="op">=</span> restlast[<span class="st">"Netzlast [MWh]"</span>] <span class="op">-</span> restlast[<span class="st">"Erneuerbare [MWh]"</span>]</span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true" tabindex="-1"></a>restlast <span class="op">=</span> restlast[<span class="st">"Restlast [MWh]"</span>]</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Um die Größenordnung der Berechnungen besser einordnen zu können, wird die Speichergröße zur bestehenden Pumpspeicherkapazität von 37,4 GWh ins Verhältnis gesetzt.</p>
<div id="7e99406b" class="cell" data-execution_count="41">
<div class="sourceCode cell-code" id="cb41"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a>pumpspeicherkapazität_MWh <span class="op">=</span> <span class="fl">37.4</span> <span class="op">*</span> <span class="dv">1000</span></span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>&nbsp;</p>
<div id="tip-Testdaten" class="callout callout-style-default callout-tip callout-titled" title="Funktionsentwicklung mit Testdaten">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-25-contents" aria-controls="callout-25" aria-expanded="true" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip&nbsp;11: Funktionsentwicklung mit Testdaten
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-25" class="callout-25-contents callout-collapse collapse show">
<div class="callout-body-container callout-body">
<p>Die im Folgenden entwickelten Funktionen bieten in der Regel eine Option zur Ausgabe der Rechenergebnisse, die aber aufgrund der Länge der vorliegenden Datenreihe zur Restlast nicht sinnvoll darstellbar sind. Dadurch sind die Datenreihe selbst wie auch die Zwischen- und Endergebnisse durchgeführter Berechnungen sowie vorhandene Fehler nicht zu überblicken. Für die Funktionsentwicklung empfiehlt es sich daher, mit Testdaten zu arbeiten. Auf diese Weise werden Berechnungen schneller durchgeführt und Zwischenergebnisse und Ergebnisse können bei Bedarf zur Überprüfung ausgegeben werden. Die nachfolgenden Funktionen wurden mit diesen Testdaten entwickelt.</p>
<p>Im folgenden Code-Block wird eine Restlastkurve aus zehn zufälligen Werten simuliert. Durch Anpassen der Werte für a und b kann das Ergebnis gesteuert werden. In der Ausgabe ist die Summe der Datenreihe festgehalten. Ein negativer Wert bedeutet, dass über die simulierte Restlastkurve eine Überschussproduktion erneuerbarer Energien herrscht. Ein positiver Wert bedeutet, dass über die simulierte Restlastkurve die positive Restlast größer als die erneuerbare Überschussproduktion ist.</p>
<p>Im Code-Block wird außerdem eine statische Datenreihe angelegt. Diese dient dazu, Testdaten festzuhalten, die zu Fehlern geführt haben. Dazu wird die Datenreihe random_data in Listenform ausgegeben, sodass diese durch Kopieren und Einfügen in die statische Datenreihe eingesetzt werden kann.</p>
<div id="c97c3508" class="cell" data-execution_count="42">
<div class="sourceCode cell-code" id="cb42"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> random <span class="im">as</span> rd</span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a>random_data <span class="op">=</span> []</span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">10</span>):</span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a>  random_data.append(rd.randint(a <span class="op">=</span> <span class="op">-</span><span class="dv">20</span>, b <span class="op">=</span> <span class="dv">20</span>))</span>
<span id="cb42-6"><a href="#cb42-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-7"><a href="#cb42-7" aria-hidden="true" tabindex="-1"></a>random_data <span class="op">=</span> pd.Series(random_data, dtype <span class="op">=</span> <span class="st">'float'</span>)</span>
<span id="cb42-8"><a href="#cb42-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"random_data: </span><span class="sc">{</span><span class="bu">list</span>(random_data)<span class="sc">}</span><span class="ch">\n</span><span class="ss">Summe random_data: </span><span class="sc">{</span>random_data<span class="sc">.</span><span class="bu">sum</span>()<span class="sc">}</span><span class="ch">\n</span><span class="ss">"</span>)</span>
<span id="cb42-9"><a href="#cb42-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-10"><a href="#cb42-10" aria-hidden="true" tabindex="-1"></a>static_data <span class="op">=</span> pd.Series([<span class="dv">8</span>, <span class="op">-</span><span class="dv">14</span>, <span class="op">-</span><span class="dv">7</span>, <span class="dv">1</span>, <span class="dv">3</span>, <span class="op">-</span><span class="dv">6</span>, <span class="dv">5</span>, <span class="op">-</span><span class="dv">20</span>, <span class="op">-</span><span class="dv">2</span>, <span class="dv">12</span>], dtype <span class="op">=</span> <span class="st">'float'</span>)</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>random_data: [1.0, 12.0, 12.0, -15.0, -2.0, -1.0, 18.0, 2.0, 13.0, -18.0]
Summe random_data: 22.0
</code></pre>
</div>
</div>
</div>
</div>
</div>
<section id="überschuss-oder-defizit-erneuerbarer-energien" class="level3">
<h3 class="anchored" data-anchor-id="überschuss-oder-defizit-erneuerbarer-energien">Überschuss oder Defizit erneuerbarer Energien</h3>
<p>Die erforderliche Größe des Stromspeichers ist einerseits abhängig von dem Verhältnis aus der Menge der erneuerbaren Überschussproduktion und der aus dem Speicher zu bedienenden Restlast. Andererseits spielen die Wirkungsgrade des Speichers beim Ein- und Ausspeichern von Strom eine Rolle.</p>
<div>

</div>
<div class="quarto-layout-panel" data-layout="[40, 60]">
<div class="quarto-layout-row">
<div id="18c96f86" class="cell quarto-layout-cell" data-execution_count="43" style="flex-basis: 40.0%;justify-content: flex-start;">
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="Energiedatenauswertung_files/figure-html/cell-44-output-1.png" alt="In zwei Grafiken sind zwei vereinfachte, aus je zwei Balken bestehende Restlastkurven im Jahresgang dargestellt. Auf der x-Achse sind die 365 Tage des Jahres dargestellt, auf der y-Achse die Restlast von minus 1 bis 1. In der oberen Grafik ist der Jahresgang bei einem Defizit erneuerbarer Energieerzeugung dargestellt. In der ersten Jahreshälfte ist die Restlast negativ in Höhe von minus 0.5, in der zweiten Jahreshälfte positiv in Höhe von 1. Dies ist durch jeweils einen Balken in entsprechender Höhe dargestellt. Der erste Balken mit den negativen Werten ist eingefärbt und nach links oben aufsteigend schraffiert. Die Färbung zeigt die erforderliche Speichergröße an, die aufsteigende Schraffierung die Phase der Einspeicherung. Der zweite Balken mit den positiven Werten ist bis zur halben Höhe 0.5 nach rechts unten absteigend schraffiert - dies zeigt die Phase der Ausspeicherung an. Der Bereich von 0.5 bis 1 ist unausgefüllt - dieser entspricht der durch Lastfolgekraftwerke zu bedienenden Restlast. In der unteren Grafik ist der Jahresgang bei einem Überschuss der erneuerbaren Energieerzeugung dargestellt. In der ersten Jahreshälfte ist die Restlast negativ in Höhe von minus 1, in der zweiten Jahreshälfte positiv in Höhe von 0.5. Der erste Balken mit den negativen Werten ist nicht eingefärbt und nur bis zur halben Höhe minus 0.5 zur Kennzeichnung der Einspeicherung aufsteigend schraffiert. Der zweite Balken mit den positiven Werten in Höhe von 0.5 ist zur Kennzeichnung der erforderlichen Speichergröße eingefärbt und zur kennzeichnung der Ausspeicherung absteigend schraffiert." width="566" height="470" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<div class="quarto-layout-cell" style="flex-basis: 60.0%;justify-content: flex-start;">
<dl>
<dt>Erneuerbare Stromproduktion: Überschuss oder Defizit?</dt>
<dd>
Ist die Summe der erneuerbaren Überschussproduktion kleiner als die aus dem Speicher zu bedienende Restlast, entspricht die erforderliche Speichergröße der Summe der erneuerbaren Überschussproduktion.
</dd>
<dd>
Ist die Summe der erneuerbaren Überschussproduktion größer als die aus dem Speicher zu bedienende Restlast, entspricht die erforderliche Speichergröße der Summe der zu bedienenden Restlast.
</dd>
<dd>
Ob ein Überschuss oder ein Defizit erneuerbarer Stromproduktion vorliegt, kann am Vorzeichen der summierten Restlast abgelesen werden. Ein negatives Vorzeichen entspricht einem erneuerbaren Stromüberschuss, ein positives Vorzeichen einem erneuerbaren Stromdefizit.
</dd>
</dl>
</div>
</div>
<div class="quarto-layout-row">
<div id="01a7705e" class="cell quarto-layout-cell" data-execution_count="44" style="flex-basis: 40.0%;justify-content: flex-start;">
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="Energiedatenauswertung_files/figure-html/cell-45-output-1.png" alt="Eine Grafik zeigt mit zwei Balken einen vereinfachten Jahresgang der Restlast mit Ein- und Ausspeicherwirkungsgrad. Auf der x-Achse sind die 365 Tage des Jahres dargestellt, auf der y-Achse die Restlast von minus 1 bis 1. In der ersten Jahreshälfte ist die Restlast negativ in Höhe von minus 1, in der zweiten Jahreshälfte positiv in Höhe von 1. Der erste Balken mit den negativen Werten ist bis zu einer Höhe von minus 0.8 gefärbt und aufsteigend schraffiert, um die Speichergröße und die Phase der Einspeicherung zu kennzeichnen. Der Bereich von minus 0.8 bis minus 1 ist gepunktet, was die Einspeicherverluste bei einem Wirkungsgrad von 0.8 kennzeichnet. Der zweite Balken mit den positiven Werten ist bis zu einer Höhe von 0.64 absteigend schraffiert, um die Phase der Ausspeicherung zu kennzeichnen. Der Bereich von 0.64 bis 0.8 ist großgepunktet, um die Ausspeicherverluste bei einem Wirkungsgrad von 0.8 zu kennzeichnen. Die Fläche von 0.8 bis 1 ist ungekennzeichnet weiß und entspricht, ebenso wie der Bereich der Ausspeicherverluste, der durch Lastfolgekraftwerke zu bedienenden Restlast." width="566" height="470" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<div class="quarto-layout-cell" style="flex-basis: 60.0%;justify-content: flex-start;">
<dl>
<dt>Wirkungsgrad</dt>
<dd>
Der Einspeicherwirkungsgrad vermindert den verfügbaren Überschussstrom. Ist die Summe der erneuerbaren Überschussproduktion kleiner als die aus dem Speicher zu bedienende Restlast, kann der Speicher um den Einspeicherwirkungsgrad kleiner dimensioniert werden.
</dd>
<dd>
Der Ausspeicherwirkungsgrad (inklusive Speicherverluste) erhöht die durch den Speicher zu bedienende Last. Ist die Summe der erneuerbaren Überschussproduktion größer als die aus dem Speicher zu bedienende Restlast, muss der Speicher um den Ausspeicherwirkungsgrad größer dimensioniert werden.
</dd>
</dl>
</div>
</div>
</div>
<section id="berechnung" class="level4">
<h4 class="anchored" data-anchor-id="berechnung">Berechnung</h4>
<p>Ob im Jahresgang Phasen erneuerbarer Überproduktion oder Phasen positiver Restlast vorherrschen, kann mit den folgenden Funktionen bestimmt werden.</p>
<div class="tabset-margin-container"></div><div class="panel-tabset">
<ul class="nav nav-tabs" role="tablist"><li class="nav-item" role="presentation"><a class="nav-link active" id="tabset-9-1-tab" data-bs-toggle="tab" data-bs-target="#tabset-9-1" role="tab" aria-controls="tabset-9-1" aria-selected="true" href="">ohne Wirkungsgrad</a></li><li class="nav-item" role="presentation"><a class="nav-link" id="tabset-9-2-tab" data-bs-toggle="tab" data-bs-target="#tabset-9-2" role="tab" aria-controls="tabset-9-2" aria-selected="false" href="">mit Wirkungsgrad</a></li></ul>
<div class="tab-content">
<div id="tabset-9-1" class="tab-pane active" role="tabpanel" aria-labelledby="tabset-9-1-tab">
<div id="5fd56ded" class="cell" data-execution_count="45">
<div class="sourceCode cell-code" id="cb44"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="co"># EE-Überschuss feststellen</span></span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a><span class="co">## Eingabe: data = pd.Series(data, dtype = 'float')</span></span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a><span class="co">## Verarbeitung: über die pd.Series wird die Summe gebildet</span></span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true" tabindex="-1"></a><span class="co">## Ausgabe: zurückgegeben wird der Wahrheitswert von data.sum() &lt; 0</span></span>
<span id="cb44-5"><a href="#cb44-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-6"><a href="#cb44-6" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> prüfe_EE_Überschuss(data):</span>
<span id="cb44-7"><a href="#cb44-7" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb44-8"><a href="#cb44-8" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> data.<span class="bu">sum</span>() <span class="op">&lt;</span> <span class="dv">0</span></span>
<span id="cb44-9"><a href="#cb44-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-10"><a href="#cb44-10" aria-hidden="true" tabindex="-1"></a>prüfe_EE_Überschuss(restlast)</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="45">
<pre><code>False</code></pre>
</div>
</div>
</div>
<div id="tabset-9-2" class="tab-pane" role="tabpanel" aria-labelledby="tabset-9-2-tab">
<div id="0f2e1510" class="cell" data-execution_count="46">
<div class="sourceCode cell-code" id="cb46"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a><span class="co"># EE-Überschuss feststellen, gegeben einen Ein- und Ausspeicherungswirkungsgrad</span></span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a><span class="co">## Eingabe: data = pd.Series(data, dtype = 'float'), einspeicherwirkungsgrad = 1, ausspeicherwirkungsgrad = 1</span></span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a><span class="co">## Verarbeitung: Werte kleiner 0 werden mit dem Einspeicherwirkungsgrad multipliziert</span></span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true" tabindex="-1"></a><span class="co">## Verarbeitung: Werte größer 0 werden durch den Ausspeicherwirkungsgrad geteilt</span></span>
<span id="cb46-5"><a href="#cb46-5" aria-hidden="true" tabindex="-1"></a><span class="co">## Verarbeitung: über die pd.Series wird die Summe gebildet</span></span>
<span id="cb46-6"><a href="#cb46-6" aria-hidden="true" tabindex="-1"></a><span class="co">## Ausgabe: zurückgegeben wird der Wahrheitswert von data_wirkungsgrad_bereinigt.sum() &lt; 0</span></span>
<span id="cb46-7"><a href="#cb46-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-8"><a href="#cb46-8" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> prüfe_EE_Überschuss(data, einspeicherwirkungsgrad <span class="op">=</span> <span class="dv">1</span>, ausspeicherwirkungsgrad <span class="op">=</span> <span class="dv">1</span>):</span>
<span id="cb46-9"><a href="#cb46-9" aria-hidden="true" tabindex="-1"></a>  data_wirkungsgrad_bereinigt <span class="op">=</span> data.copy()</span>
<span id="cb46-10"><a href="#cb46-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-11"><a href="#cb46-11" aria-hidden="true" tabindex="-1"></a>  data_wirkungsgrad_bereinigt[data_wirkungsgrad_bereinigt <span class="op">&lt;</span> <span class="dv">0</span>] <span class="op">=</span> data_wirkungsgrad_bereinigt[data_wirkungsgrad_bereinigt <span class="op">&lt;</span> <span class="dv">0</span>] <span class="op">*</span> einspeicherwirkungsgrad</span>
<span id="cb46-12"><a href="#cb46-12" aria-hidden="true" tabindex="-1"></a>  data_wirkungsgrad_bereinigt[data_wirkungsgrad_bereinigt <span class="op">&gt;</span> <span class="dv">0</span>] <span class="op">=</span> data_wirkungsgrad_bereinigt[data_wirkungsgrad_bereinigt <span class="op">&gt;</span> <span class="dv">0</span>] <span class="op">/</span> ausspeicherwirkungsgrad</span>
<span id="cb46-13"><a href="#cb46-13" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb46-14"><a href="#cb46-14" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> data_wirkungsgrad_bereinigt.<span class="bu">sum</span>() <span class="op">&lt;</span> <span class="dv">0</span></span>
<span id="cb46-15"><a href="#cb46-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-16"><a href="#cb46-16" aria-hidden="true" tabindex="-1"></a>prüfe_EE_Überschuss(restlast, einspeicherwirkungsgrad <span class="op">=</span> <span class="fl">0.9</span>, ausspeicherwirkungsgrad <span class="op">=</span> <span class="fl">0.9</span>)</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="46">
<pre><code>False</code></pre>
</div>
</div>
</div>
</div>
</div>
<p>Wie aus der Grenzstromanalyse im Abschnitt <a href="#sec-Pumpspeicherinhalt" class="quarto-xref">Kapitel&nbsp;7.6</a> bekannt, herrschte im Jahr 2023 kein Überschuss an erneuerbarer Stromproduktion.</p>
</section>
</section>
<section id="zyklik" class="level3">
<h3 class="anchored" data-anchor-id="zyklik">Zyklik</h3>
<p>Im Zeitraum eines Jahres beeinflusst die Reihenfolge von Phasen mit erneuerbaren Überschüssen und mit positiver Restlast, wie groß ein Speicher ausgelegt werden muss.</p>
<div>

</div>
<div class="quarto-layout-panel" data-layout="[40, 60]">
<div class="quarto-layout-row">
<div id="9f9eec69" class="cell quarto-layout-cell" data-execution_count="47" style="flex-basis: 40.0%;justify-content: flex-start;">
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="Energiedatenauswertung_files/figure-html/cell-48-output-1.png" alt="In zwei Grafiken sind zwei vereinfachte, aus je vier Balken bestehende Restlastkurven für zwei aufeinanderfolgende Jahresgänge dargestellt. Auf der x-Achse sind die 730 Tage der zwei aufeinanderfolgenden Jahre dargestellt, auf der y-Achse die Restlast von minus 1 bis 1. In der oberen Grafik ist der Zweijahresgang der Restlast bei einem Defizit an erneuerbarer Überschussproduktion dargestellt. Im ersten Halbjahr beträgt die positive Restlast 1, die noch nicht durch eingespeicherten Strom gedeckt werden kann. Im zweiten Halbjahr beträgt die Restlast minus 0.5. Dieser Balken ist eingefärbt und aufsteigend schraffiert. Die Färbung zeigt die erforderliche Speichergröße an, die aufsteigende Schraffierung die Phase der Einspeicherung. Im zweiten Jahr wiederholt sich der Jahresgang. Im dritten Halbjahr beträgt die positive Restlast somit erneut 1. Der dritte Balken mit den positiven Werten in Höhe von 1 ist bis zur halben Höhe 0.5 nach rechts unten absteigend schraffiert - dies zeigt die Phase der Ausspeicherung an. Der Bereich von 0.5 bis 1 ist unausgefüllt - dieser entspricht der durch Lastfolgekraftwerke zu bedienenden Restlast. Im vierten Halbjahr beträgt die negative Restlast erneut minus 0.5. Der Balken ist aufsteigend schraffiert, um die erneute Einspeicherung in den Speicher anzuzeigen. In der unteren Grafik ist der Zweijahresgang der Restlast bei einem Überschuss an erneuerbarer Überschussproduktion dargestellt. Im ersten Halbjahr beträgt die positive Restlast 0.5, die noch nicht durch eingespeicherten Strom gedeckt werden kann. Im zweiten Halbjahr beträgt die Restlast minus 1. Dieser Balken ist bis zur Höhe minus 0.5 aufsteigend schraffiert, um die Phase der Einspeicherung zu kennzeichnen. Der Bereich von minus 0.5 bis minus 1 ist unmarkiert weiß, dieser entspricht dem ungenutzten erneuerbaren Überschuss. Im zweiten Jahr wiederholt sich der Jahresgang. Im dritten Halbjahr beträgt die positive Restlast erneut 0.5. Der dritte Balken mit den positiven Werten in Höhe von 0.5 ist eingefärbt und nach rechts unten absteigend schraffiert - dies zeigt die benötigte Speichergröße und die Phase der Ausspeicherung an. Im vierten Halbjahr beträgt die Restlast minus 1. Dieser Balken ist bis zur Höhe minus 0.5 aufsteigend schraffiert, um die Phase der Einspeicherung zu kennzeichnen. Der Bereich von minus 0.5 bis minus 1 ist unmarkiert weiß, dieser entspricht dem ungenutzten erneuerbaren Überschuss." width="548" height="470" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<div class="quarto-layout-cell" style="flex-basis: 60.0%;justify-content: flex-start;">
<dl>
<dt>Reihenfolgeabhängigkeit</dt>
<dd>
Wird nur ein einziges Jahr betrachtet, entscheidet die Reihenfolge von erneuerbarer Über- und Unterproduktion, wie viel Strom eingespeichert werden kann. Im ungünstigstes Fall liegt im ersten Halbjahr eine positive Restlast vor (der Speicher ist aber noch leer) und im zweiten Halbjahr herrscht erneuerbare Überproduktion (die im zweiten Halbjahr nicht mehr abgenommen werden würde).
</dd>
<dd>
Die Reihenfolgeabhängigkeit kann aufgelöst werden, indem zwei aufeinanderfolgende Jahresgänge betrachtet werden. Im ersten Jahr wird der Speicher leer ans Netz angeschlossen. Das zweite Jahr beginnt der Speicher gefüllt durch die Überschussproduktion aus dem Vorjahr.
</dd>
</dl>
</div>
</div>
<div class="quarto-layout-row">
<div id="2db18e4a" class="cell quarto-layout-cell" data-execution_count="48" style="flex-basis: 40.0%;justify-content: flex-start;">
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="Energiedatenauswertung_files/figure-html/cell-49-output-1.png" alt="In zwei Grafiken sind zwei vereinfachte Jahresgänge der Restlast dargestellt. Auf der x-Achse sind die 365 Tage des Jahres dargestellt, auf der y-Achse die Restlast von minus 1 bis 1. In der oberen Grafik ist der Jahresgang der Restlast für einen Vollzyklus aus kompletter Ladung und Entladung mit zwei Balken dargestellt. Im ersten Halbjahr beträgt die Restlast minus 1, der Balken ist eingefärbt und aufsteigend schraffiert. Die Färbung zeigt die erforderliche Speichergröße an, die aufsteigende Schraffierung die Phase der Einspeicherung. Im zweiten Halbjahr beträgt die positive Restlast 1. Dieser Balken ist zur Kennzeichnung der Ausspeicherung nach rechts unten absteigend schraffiert. In der unteren Grafik ist der Jahresgang der Restlast für zwei Vollzyklen mit vier Balken dargestellt. Im ersten Vierteljahr beträgt die Restlast minus 1, der Balken ist eingefärbt und aufsteigend schraffiert. Die Färbung zeigt die erforderliche Speichergröße, die halb so groß wie in der oberen Grafik ist, an, die aufsteigende Schraffierung die Phase der Einspeicherung. Im zweiten Vierteljahr beträgt die positive Restlast 1. Dieser Balken ist zur Kennzeichnung der Ausspeicherung nach rechts unten absteigend schraffiert. Im zweiten Halbjahr wiederholt sich die Abfolge von Ein- und Ausspeicherung in Höhe von 1." width="566" height="470" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<div class="quarto-layout-cell" style="flex-basis: 60.0%;justify-content: flex-start;">
<dl>
<dt>Anzahl Vollzyklen</dt>
<dd>
Die erforderliche Größe des Stromspeichers ist abhängig von der Verteilung der Restlast und der realisierten Anzahl Vollzyklen. Ein Vollzyklus bedeutet, dass ein Speicher vollständig geladen und wieder entladen wird.
</dd>
<dd>
Im ungünstigsten Fall wird nur ein einziger Lade- / Entladezyklus gefahren. In diesem Fall entspricht die erforderliche Speichergröße der Summe der erneuerbaren Überschussproduktion.
</dd>
<dd>
Je häufiger sich Lade- und Entladezyklen abwechseln, desto geringer ist die erforderliche Speichergröße. Diese entspricht der Summe der erneuerbaren Überschussproduktion geteilt durch die Anzahl der Vollzyklen.
</dd>
</dl>
</div>
</div>
<div class="quarto-layout-row">
<div id="4de5b77e" class="cell quarto-layout-cell" data-execution_count="49" style="flex-basis: 40.0%;justify-content: flex-start;">
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="Energiedatenauswertung_files/figure-html/cell-50-output-1.png" width="548" height="470" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<div class="quarto-layout-cell" style="flex-basis: 60.0%;justify-content: flex-start;">
<dl>
<dt>Teilzyklen</dt>
<dd>
Auch die Verteilung auftretender Teilzyklen reduziert die erforderliche Speichergröße.
</dd>
<dd>
Ist die Summe der erneuerbaren Überschussproduktion kleiner als die durch den Speicher zu bedienende Restlast, entspricht die erforderliche Speichergröße dem Minimum der kummulierten Summe der Restlast, wenn diese niemals größer 0 gesetzt wird (das Überschreiten wäre der Moment, in dem der Speicher leer ist).
</dd>
<dd>
Ist die Summe der erneuerbaren Überschussproduktion größer als die durch den Speicher zu bedienende Restlast, entspricht die erforderliche Speichergröße dem Maximum der kummulierten Summe der Restlast, wenn diese niemals kleiner 0 gesetzt wird (das Unterschreiten wäre der Moment, in dem der Speicher überdimensioniert ist).
</dd>
</dl>
</div>
</div>
</div>
<section id="berechnung-1" class="level4">
<h4 class="anchored" data-anchor-id="berechnung-1">Berechnung</h4>
<p>Die Speichergröße wird aus dem Jahresgang der Restlast berechnet. Um nicht vom Zeitpunkt abhängig zu sein, an dem der Speicher an das Netz angeschlossen wird, wird der Datensatz zwei mal durchlaufen (auflösen der Reihenfolgeabhängigkeit).</p>
<ul>
<li><p>Ist die Summe der erneuerbaren Überschussproduktion kleiner als die Summe der durch den Speicher zu bedienenden Restlast, entspricht die erforderliche Speichergröße dem Minimum der kummulierten Summe der Restlast, wenn diese niemals größer 0 gesetzt wird (das Überschreiten wäre der Moment, in dem der Speicher leer ist).</p></li>
<li><p>Ist die Summe der erneuerbaren Überschussproduktion größer als die Summe der durch den Speicher zu bedienenden Restlast, entspricht die erforderliche Speichergröße dem Maximum der kummulierten Summe der Restlast, wenn diese niemals kleiner 0 gesetzt wird (das Unterschreiten wäre der Moment, in dem der Speicher überdimensioniert ist).</p></li>
</ul>
<div class="tabset-margin-container"></div><div class="panel-tabset">
<ul class="nav nav-tabs" role="tablist"><li class="nav-item" role="presentation"><a class="nav-link active" id="tabset-10-1-tab" data-bs-toggle="tab" data-bs-target="#tabset-10-1" role="tab" aria-controls="tabset-10-1" aria-selected="true" href="">ohne Wirkungsgrad</a></li><li class="nav-item" role="presentation"><a class="nav-link" id="tabset-10-2-tab" data-bs-toggle="tab" data-bs-target="#tabset-10-2" role="tab" aria-controls="tabset-10-2" aria-selected="false" href="">mit Wirkungsgrad</a></li></ul>
<div class="tab-content">
<div id="tabset-10-1" class="tab-pane active" role="tabpanel" aria-labelledby="tabset-10-1-tab">
<div id="4d616c38" class="cell" data-execution_count="50">
<div class="sourceCode cell-code" id="cb48"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Speichergröße berechnen</span></span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a><span class="co">## Eingabe: data = pd.Series(data, dtype = 'float'), output = False</span></span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a><span class="co">## Verarbeitung: aufrufen der Funktion prüfe_EE_Überschuss, um zwischen oberer Grenze = 0 (Speicher ist leer) und unterer Grenze = 0 (Speicher ist überdimensioniert) zu unterscheiden</span></span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a><span class="co">## Verarbeitung: data wird zwei mal zu data_x2 verkettet. Für data_x2 wird die bei 0 gekappte kumulierte Summe berechnet und die Speichergröße berechnet.</span></span>
<span id="cb48-5"><a href="#cb48-5" aria-hidden="true" tabindex="-1"></a><span class="co">## Ausgabe: wenn output = False wird die Speichergröße (float) zurückgegeben, wenn output = True werden die Summe von data und die Speichergröße mit print() ausgegeben</span></span>
<span id="cb48-6"><a href="#cb48-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-7"><a href="#cb48-7" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> berechne_speichergröße(data, output <span class="op">=</span> <span class="va">False</span>):</span>
<span id="cb48-8"><a href="#cb48-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-9"><a href="#cb48-9" aria-hidden="true" tabindex="-1"></a>  data_x2 <span class="op">=</span> pd.concat([data, data])</span>
<span id="cb48-10"><a href="#cb48-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-11"><a href="#cb48-11" aria-hidden="true" tabindex="-1"></a>  überschuss <span class="op">=</span> prüfe_EE_Überschuss(data)</span>
<span id="cb48-12"><a href="#cb48-12" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb48-13"><a href="#cb48-13" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> überschuss:</span>
<span id="cb48-14"><a href="#cb48-14" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb48-15"><a href="#cb48-15" aria-hidden="true" tabindex="-1"></a>    <span class="co"># gekappte kumulierte Summe berechnen</span></span>
<span id="cb48-16"><a href="#cb48-16" aria-hidden="true" tabindex="-1"></a>    capped_cumsum <span class="op">=</span> []</span>
<span id="cb48-17"><a href="#cb48-17" aria-hidden="true" tabindex="-1"></a>    summe <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb48-18"><a href="#cb48-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-19"><a href="#cb48-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> data_x2:</span>
<span id="cb48-20"><a href="#cb48-20" aria-hidden="true" tabindex="-1"></a>      summe <span class="op">+=</span> i </span>
<span id="cb48-21"><a href="#cb48-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-22"><a href="#cb48-22" aria-hidden="true" tabindex="-1"></a>      <span class="co"># Untergrenze prüfen</span></span>
<span id="cb48-23"><a href="#cb48-23" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> summe <span class="op">&lt;</span> <span class="dv">0</span>:</span>
<span id="cb48-24"><a href="#cb48-24" aria-hidden="true" tabindex="-1"></a>        summe <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb48-25"><a href="#cb48-25" aria-hidden="true" tabindex="-1"></a>      </span>
<span id="cb48-26"><a href="#cb48-26" aria-hidden="true" tabindex="-1"></a>      capped_cumsum.append(summe)</span>
<span id="cb48-27"><a href="#cb48-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-28"><a href="#cb48-28" aria-hidden="true" tabindex="-1"></a>    speichergröße <span class="op">=</span> <span class="bu">max</span>(capped_cumsum)</span>
<span id="cb48-29"><a href="#cb48-29" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb48-30"><a href="#cb48-30" aria-hidden="true" tabindex="-1"></a>  <span class="cf">else</span>:</span>
<span id="cb48-31"><a href="#cb48-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-32"><a href="#cb48-32" aria-hidden="true" tabindex="-1"></a>    <span class="co"># gekappte kumulierte Summe berechnen</span></span>
<span id="cb48-33"><a href="#cb48-33" aria-hidden="true" tabindex="-1"></a>    capped_cumsum <span class="op">=</span> []</span>
<span id="cb48-34"><a href="#cb48-34" aria-hidden="true" tabindex="-1"></a>    summe <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb48-35"><a href="#cb48-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-36"><a href="#cb48-36" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> data_x2:</span>
<span id="cb48-37"><a href="#cb48-37" aria-hidden="true" tabindex="-1"></a>      summe <span class="op">+=</span> i</span>
<span id="cb48-38"><a href="#cb48-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-39"><a href="#cb48-39" aria-hidden="true" tabindex="-1"></a>      <span class="co"># Obergrenze prüfen</span></span>
<span id="cb48-40"><a href="#cb48-40" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> summe <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb48-41"><a href="#cb48-41" aria-hidden="true" tabindex="-1"></a>        summe <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb48-42"><a href="#cb48-42" aria-hidden="true" tabindex="-1"></a>      </span>
<span id="cb48-43"><a href="#cb48-43" aria-hidden="true" tabindex="-1"></a>      capped_cumsum.append(summe)</span>
<span id="cb48-44"><a href="#cb48-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-45"><a href="#cb48-45" aria-hidden="true" tabindex="-1"></a>    speichergröße <span class="op">=</span> <span class="bu">abs</span>(<span class="bu">min</span>(capped_cumsum))</span>
<span id="cb48-46"><a href="#cb48-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-47"><a href="#cb48-47" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> output: <span class="co"># output = True</span></span>
<span id="cb48-48"><a href="#cb48-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-49"><a href="#cb48-49" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">Summe data: </span><span class="sc">{</span>data<span class="sc">.</span><span class="bu">sum</span>()<span class="sc">}</span><span class="ch">\n</span><span class="ss">Speichergröße: </span><span class="sc">{</span>speichergr<span class="sc">öß</span>e<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb48-50"><a href="#cb48-50" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb48-51"><a href="#cb48-51" aria-hidden="true" tabindex="-1"></a>  <span class="cf">else</span>: <span class="co"># output = False</span></span>
<span id="cb48-52"><a href="#cb48-52" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> speichergröße</span>
<span id="cb48-53"><a href="#cb48-53" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb48-54"><a href="#cb48-54" aria-hidden="true" tabindex="-1"></a>speicher_2023 <span class="op">=</span> berechne_speichergröße(restlast, output <span class="op">=</span> <span class="va">False</span>)</span>
<span id="cb48-55"><a href="#cb48-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-56"><a href="#cb48-56" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"erforderliche Speichergröße 2023: </span><span class="sc">{</span>speicher_2023<span class="sc">:,.1f}</span><span class="ss"> MWh</span><span class="ch">\n</span><span class="ss">Dies entspricht </span><span class="sc">{</span>speicher_2023 <span class="op">/</span> pumpspeicherkapazit<span class="sc">ä</span>t_MWh<span class="sc">:,.1f}</span><span class="ss"> Pumpspeicheräquivalenten."</span>)</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>erforderliche Speichergröße 2023: 119,667.0 MWh
Dies entspricht 3.2 Pumpspeicheräquivalenten.</code></pre>
</div>
</div>
</div>
<div id="tabset-10-2" class="tab-pane" role="tabpanel" aria-labelledby="tabset-10-2-tab">
<div id="25f506ef" class="cell" data-execution_count="51">
<div class="sourceCode cell-code" id="cb50"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Speichergröße berechnen</span></span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a><span class="co">## Eingabe: data = pd.Series(data, dtype = 'float'), einspeicherwirkungsgrad = 1, ausspeicherwirkungsgrad = 1, output = False</span></span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a><span class="co">## Verarbeitung: aufrufen der Funktion prüfe_EE_Überschuss, um zwischen oberer Grenze = 0 (Speicher ist leer) und unterer Grenze = 0 (Speicher ist überdimensioniert) zu unterscheiden</span></span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true" tabindex="-1"></a><span class="co">## Verarbeitung: data wird zwei mal zu data_x2 verkettet. Für data_x2 wird die bei 0 gekappte kumulierte Summe berechnet und die Speichergröße berechnet.</span></span>
<span id="cb50-5"><a href="#cb50-5" aria-hidden="true" tabindex="-1"></a><span class="co">## Ausgabe: wenn output = False wird die Speichergröße (float) zurückgegeben, wenn output = True werden die Summe von data und die Speichergröße mit print() ausgegeben</span></span>
<span id="cb50-6"><a href="#cb50-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-7"><a href="#cb50-7" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> berechne_speichergröße(data, einspeicherwirkungsgrad <span class="op">=</span> <span class="dv">1</span>, ausspeicherwirkungsgrad <span class="op">=</span> <span class="dv">1</span>, output <span class="op">=</span> <span class="va">False</span>):</span>
<span id="cb50-8"><a href="#cb50-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-9"><a href="#cb50-9" aria-hidden="true" tabindex="-1"></a>  data_x2 <span class="op">=</span> pd.concat([data, data])</span>
<span id="cb50-10"><a href="#cb50-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-11"><a href="#cb50-11" aria-hidden="true" tabindex="-1"></a>  überschuss <span class="op">=</span> prüfe_EE_Überschuss(data, einspeicherwirkungsgrad, ausspeicherwirkungsgrad)</span>
<span id="cb50-12"><a href="#cb50-12" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb50-13"><a href="#cb50-13" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> überschuss:</span>
<span id="cb50-14"><a href="#cb50-14" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb50-15"><a href="#cb50-15" aria-hidden="true" tabindex="-1"></a>    <span class="co"># gekappte kumulierte Summe berechnen</span></span>
<span id="cb50-16"><a href="#cb50-16" aria-hidden="true" tabindex="-1"></a>    capped_cumsum <span class="op">=</span> []</span>
<span id="cb50-17"><a href="#cb50-17" aria-hidden="true" tabindex="-1"></a>    summe <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb50-18"><a href="#cb50-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-19"><a href="#cb50-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> data_x2:</span>
<span id="cb50-20"><a href="#cb50-20" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> i <span class="op">&lt;</span> <span class="dv">0</span>:</span>
<span id="cb50-21"><a href="#cb50-21" aria-hidden="true" tabindex="-1"></a>        summe <span class="op">+=</span> i <span class="op">*</span> einspeicherwirkungsgrad</span>
<span id="cb50-22"><a href="#cb50-22" aria-hidden="true" tabindex="-1"></a>      <span class="cf">else</span>:</span>
<span id="cb50-23"><a href="#cb50-23" aria-hidden="true" tabindex="-1"></a>        summe <span class="op">+=</span> i <span class="op">/</span> ausspeicherwirkungsgrad</span>
<span id="cb50-24"><a href="#cb50-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-25"><a href="#cb50-25" aria-hidden="true" tabindex="-1"></a>      <span class="co"># Untergrenze prüfen</span></span>
<span id="cb50-26"><a href="#cb50-26" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> summe <span class="op">&lt;</span> <span class="dv">0</span>:</span>
<span id="cb50-27"><a href="#cb50-27" aria-hidden="true" tabindex="-1"></a>        summe <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb50-28"><a href="#cb50-28" aria-hidden="true" tabindex="-1"></a>      </span>
<span id="cb50-29"><a href="#cb50-29" aria-hidden="true" tabindex="-1"></a>      capped_cumsum.append(summe)</span>
<span id="cb50-30"><a href="#cb50-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-31"><a href="#cb50-31" aria-hidden="true" tabindex="-1"></a>    speichergröße <span class="op">=</span> <span class="bu">max</span>(capped_cumsum)</span>
<span id="cb50-32"><a href="#cb50-32" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb50-33"><a href="#cb50-33" aria-hidden="true" tabindex="-1"></a>  <span class="cf">else</span>: <span class="co"># Unterproduktion</span></span>
<span id="cb50-34"><a href="#cb50-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-35"><a href="#cb50-35" aria-hidden="true" tabindex="-1"></a>    <span class="co"># gekappte kumulierte Summe berechnen</span></span>
<span id="cb50-36"><a href="#cb50-36" aria-hidden="true" tabindex="-1"></a>    capped_cumsum <span class="op">=</span> []</span>
<span id="cb50-37"><a href="#cb50-37" aria-hidden="true" tabindex="-1"></a>    summe <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb50-38"><a href="#cb50-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-39"><a href="#cb50-39" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> data_x2:</span>
<span id="cb50-40"><a href="#cb50-40" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> i <span class="op">&lt;</span> <span class="dv">0</span>:</span>
<span id="cb50-41"><a href="#cb50-41" aria-hidden="true" tabindex="-1"></a>        summe <span class="op">+=</span> i <span class="op">*</span> einspeicherwirkungsgrad</span>
<span id="cb50-42"><a href="#cb50-42" aria-hidden="true" tabindex="-1"></a>      <span class="cf">else</span>:</span>
<span id="cb50-43"><a href="#cb50-43" aria-hidden="true" tabindex="-1"></a>        summe <span class="op">+=</span> i <span class="op">/</span> ausspeicherwirkungsgrad</span>
<span id="cb50-44"><a href="#cb50-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-45"><a href="#cb50-45" aria-hidden="true" tabindex="-1"></a>      <span class="co"># Obergrenze prüfen</span></span>
<span id="cb50-46"><a href="#cb50-46" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> summe <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb50-47"><a href="#cb50-47" aria-hidden="true" tabindex="-1"></a>        summe <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb50-48"><a href="#cb50-48" aria-hidden="true" tabindex="-1"></a>      </span>
<span id="cb50-49"><a href="#cb50-49" aria-hidden="true" tabindex="-1"></a>      capped_cumsum.append(summe)</span>
<span id="cb50-50"><a href="#cb50-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-51"><a href="#cb50-51" aria-hidden="true" tabindex="-1"></a>    speichergröße <span class="op">=</span> <span class="bu">abs</span>(<span class="bu">min</span>(capped_cumsum))</span>
<span id="cb50-52"><a href="#cb50-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-53"><a href="#cb50-53" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> output: <span class="co"># output = True</span></span>
<span id="cb50-54"><a href="#cb50-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-55"><a href="#cb50-55" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">Summe data: </span><span class="sc">{</span>data<span class="sc">.</span><span class="bu">sum</span>()<span class="sc">}</span><span class="ch">\n</span><span class="ss">Speichergröße: </span><span class="sc">{</span>speichergr<span class="sc">öß</span>e<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb50-56"><a href="#cb50-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-57"><a href="#cb50-57" aria-hidden="true" tabindex="-1"></a>  <span class="cf">else</span>: <span class="co"># output = False</span></span>
<span id="cb50-58"><a href="#cb50-58" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> speichergröße</span>
<span id="cb50-59"><a href="#cb50-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-60"><a href="#cb50-60" aria-hidden="true" tabindex="-1"></a>speicher_2023 <span class="op">=</span> berechne_speichergröße(restlast, einspeicherwirkungsgrad <span class="op">=</span> <span class="fl">0.9</span>, ausspeicherwirkungsgrad <span class="op">=</span> <span class="fl">0.9</span>, output <span class="op">=</span> <span class="va">False</span>)</span>
<span id="cb50-61"><a href="#cb50-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-62"><a href="#cb50-62" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"erforderliche Speichergröße 2023: </span><span class="sc">{</span>speicher_2023<span class="sc">:,.1f}</span><span class="ss"> MWh</span><span class="ch">\n</span><span class="ss">Dies entspricht </span><span class="sc">{</span>speicher_2023 <span class="op">/</span> pumpspeicherkapazit<span class="sc">ä</span>t_MWh<span class="sc">:,.1f}</span><span class="ss"> Pumpspeicheräquivalenten."</span>)   </span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>erforderliche Speichergröße 2023: 102,674.5 MWh
Dies entspricht 2.7 Pumpspeicheräquivalenten.</code></pre>
</div>
</div>
<p><strong>ist hier ersichtlich, welche Wirkungsgrade benutzt werden? Ich könnte das noch bei output hinterlegen und die Funktion zwei mal aufrufen.</strong></p>
</div>
</div>
</div>
</section>
<section id="jahresgang-des-speichers" class="level4">
<h4 class="anchored" data-anchor-id="jahresgang-des-speichers">Jahresgang des Speichers</h4>
<p>Nachdem die Speichergröße bestimmt wurde, kann der Jahresgang des Speichers für das erste und das zweite Jahr berechnet sowie grafisch dargestellt werden. Der Jahresgang des Speichers für das zweite Jahr ist das stabile Gleichgewicht, mit dem eine gegebene Restlastkurve beliebig oft durchlaufen werden kann.</p>
<ul>
<li><p>Eingabe: Der Funktion wird eine Restlastkurve übergeben. Außerdem kann eine Speichergröße übergeben werden, andernfalls wird diese durch Aufruf der Funktion berechne_speichergröße() ermittelt.</p></li>
<li><p>Verarbeitung: Beginnend mit einem leeren Speicher wird die Restlastlastdatenreihe zwei mal elementweise durchlaufen. Negative Werte werden in den Speicher übertragen, bis die Speicherkapazität erreicht wurde. Positive Werte werden dem Speicher entnommen, bis der Ladestand des Speichers Null beträgt. In der um Ein- und Ausspeicherwirkungsgrade erweiterten Funktion werden eingespeicherte Werte mit dem Einspeicherwirkungsgrad (0.9) multipliziert und ausgespeicherte Werte durch den Ausspeicherwirkungsgrad (0.9) geteilt.</p></li>
<li><p>Ausgabe: Die Funktion gibt, wenn <code>output = False</code> ist, ein Tupel zurück. An Position 0 ist die Speichergröße gespeichert, an Position 1 der Jahresgang in Jahr 1 als pd.Series, an Position 2 der Jahresgang in Jahr 2 als pd.Series. Die Jahresgänge werden im Folgenden Panel grafisch dargestellt. Wenn ‘output = True’, werden die kumulierte Summe der Restlast und die Speichergröße sowie die übergebene Restlastkurve, die Ladestände und freie Kapazität des Speichers im Jahresgang für Jahr 1 und Jahr 2 mit <code>print()</code> ausgegeben - dies ist in der Regel nur für Testdaten sinnvoll.</p></li>
</ul>
<div class="tabset-margin-container"></div><div class="panel-tabset">
<ul class="nav nav-tabs" role="tablist"><li class="nav-item" role="presentation"><a class="nav-link active" id="tabset-11-1-tab" data-bs-toggle="tab" data-bs-target="#tabset-11-1" role="tab" aria-controls="tabset-11-1" aria-selected="true" href="">ohne Wirkungsgrad</a></li><li class="nav-item" role="presentation"><a class="nav-link" id="tabset-11-2-tab" data-bs-toggle="tab" data-bs-target="#tabset-11-2" role="tab" aria-controls="tabset-11-2" aria-selected="false" href="">Plot ohne Wirkungsgrad</a></li><li class="nav-item" role="presentation"><a class="nav-link" id="tabset-11-3-tab" data-bs-toggle="tab" data-bs-target="#tabset-11-3" role="tab" aria-controls="tabset-11-3" aria-selected="false" href="">Code für den Plot</a></li><li class="nav-item" role="presentation"><a class="nav-link" id="tabset-11-4-tab" data-bs-toggle="tab" data-bs-target="#tabset-11-4" role="tab" aria-controls="tabset-11-4" aria-selected="false" href="">mit Wirkungsgrad</a></li><li class="nav-item" role="presentation"><a class="nav-link" id="tabset-11-5-tab" data-bs-toggle="tab" data-bs-target="#tabset-11-5" role="tab" aria-controls="tabset-11-5" aria-selected="false" href="">Plot mit Wirkungsgrad</a></li><li class="nav-item" role="presentation"><a class="nav-link" id="tabset-11-6-tab" data-bs-toggle="tab" data-bs-target="#tabset-11-6" role="tab" aria-controls="tabset-11-6" aria-selected="false" href="">Code für den Plot</a></li></ul>
<div class="tab-content">
<div id="tabset-11-1" class="tab-pane active" role="tabpanel" aria-labelledby="tabset-11-1-tab">
<div id="342404fb" class="cell" data-execution_count="52">
<div class="sourceCode cell-code" id="cb52"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Jahresgang des Speichers berechnen</span></span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a><span class="co">## Eingabe: data = pd.Series(data, dtype = 'float'), speichergröße = -1, output = False</span></span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a><span class="co">## Verarbeitung: Wenn speichergröße = -1 wird die Speichergröße mit der Funktion berechne_speichergröße(data) ermittelt</span></span>
<span id="cb52-4"><a href="#cb52-4" aria-hidden="true" tabindex="-1"></a><span class="co">## Verarbeitung: data wird zwei mal zu data_x2 verkettet.</span></span>
<span id="cb52-5"><a href="#cb52-5" aria-hidden="true" tabindex="-1"></a><span class="co">## Verarbeitung: Anhand der Speichergröße werden der Ladestand und die freie Kapazität des Speichers für alle Werte von data für Jahr1 und alle Folgejahre berechnet.</span></span>
<span id="cb52-6"><a href="#cb52-6" aria-hidden="true" tabindex="-1"></a><span class="co">## Ausgabe: Wenn output False ist, wird ein Tupel aus speichergröße (float), Ladestand Jahr1 (pd.Series), Ladestand Jahr2 (pd.Series) zurückgegeben.</span></span>
<span id="cb52-7"><a href="#cb52-7" aria-hidden="true" tabindex="-1"></a><span class="co">## Ausgabe: Wenn output True, werden die kumulierte Summe der Restlast, die Speichergröße, die Restlastkurve, die Ladestände und freie Kapazität des Speichers im Jahresgang für Jahr 1 und Jahr 2 mit ausgegeben</span></span>
<span id="cb52-8"><a href="#cb52-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-9"><a href="#cb52-9" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> jahresgang_speicher_berechnen(data, speichergröße <span class="op">=</span> <span class="op">-</span><span class="dv">1</span>, output <span class="op">=</span> <span class="va">False</span>):</span>
<span id="cb52-10"><a href="#cb52-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-11"><a href="#cb52-11" aria-hidden="true" tabindex="-1"></a>  data_x2 <span class="op">=</span> pd.concat([data, data])</span>
<span id="cb52-12"><a href="#cb52-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-13"><a href="#cb52-13" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> speichergröße <span class="op">==</span> <span class="op">-</span><span class="dv">1</span>:</span>
<span id="cb52-14"><a href="#cb52-14" aria-hidden="true" tabindex="-1"></a>    speichergröße <span class="op">=</span> berechne_speichergröße(data) </span>
<span id="cb52-15"><a href="#cb52-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-16"><a href="#cb52-16" aria-hidden="true" tabindex="-1"></a><span class="co"># Jahresgang des Speichers berechnen</span></span>
<span id="cb52-17"><a href="#cb52-17" aria-hidden="true" tabindex="-1"></a>  jahresgang_speicher <span class="op">=</span> []</span>
<span id="cb52-18"><a href="#cb52-18" aria-hidden="true" tabindex="-1"></a>  ladestand_speicher <span class="op">=</span> []</span>
<span id="cb52-19"><a href="#cb52-19" aria-hidden="true" tabindex="-1"></a>  freie_speicherkapazität <span class="op">=</span> speichergröße <span class="co"># der speicher ist leer</span></span>
<span id="cb52-20"><a href="#cb52-20" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> i <span class="kw">in</span> data_x2:</span>
<span id="cb52-21"><a href="#cb52-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-22"><a href="#cb52-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (speichergröße <span class="op">-</span> freie_speicherkapazität) <span class="op">-</span> i <span class="op">&lt;</span> <span class="dv">0</span>: <span class="co"># last ohne vorherige Einspeicherung kann nicht bedient werden</span></span>
<span id="cb52-23"><a href="#cb52-23" aria-hidden="true" tabindex="-1"></a>      freie_speicherkapazität <span class="op">=</span> speichergröße</span>
<span id="cb52-24"><a href="#cb52-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-25"><a href="#cb52-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> freie_speicherkapazität <span class="op">+</span> i <span class="op">&lt;</span> <span class="dv">0</span>: <span class="co"># wenn der Speicher voll ist, muss Überschuss verworfen werden.</span></span>
<span id="cb52-26"><a href="#cb52-26" aria-hidden="true" tabindex="-1"></a>      freie_speicherkapazität <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb52-27"><a href="#cb52-27" aria-hidden="true" tabindex="-1"></a>      </span>
<span id="cb52-28"><a href="#cb52-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>: <span class="co"># Ein-/Ausspeicherung</span></span>
<span id="cb52-29"><a href="#cb52-29" aria-hidden="true" tabindex="-1"></a>      freie_speicherkapazität <span class="op">+=</span> i</span>
<span id="cb52-30"><a href="#cb52-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-31"><a href="#cb52-31" aria-hidden="true" tabindex="-1"></a>    jahresgang_speicher.append(freie_speicherkapazität)</span>
<span id="cb52-32"><a href="#cb52-32" aria-hidden="true" tabindex="-1"></a>    ladestand_speicher.append(speichergröße <span class="op">-</span> freie_speicherkapazität)</span>
<span id="cb52-33"><a href="#cb52-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-34"><a href="#cb52-34" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> output: <span class="co"># output = True</span></span>
<span id="cb52-35"><a href="#cb52-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-36"><a href="#cb52-36" aria-hidden="true" tabindex="-1"></a>    dataset <span class="op">=</span> pd.DataFrame({<span class="st">'Restlast'</span>: data, <span class="st">'Ladestand Jahr1'</span>: ladestand_speicher[ : <span class="bu">len</span>(jahresgang_speicher) <span class="op">//</span> <span class="dv">2</span> ], <span class="st">'freie Kapazität Jahr1'</span>: jahresgang_speicher[ : <span class="bu">len</span>(jahresgang_speicher) <span class="op">//</span> <span class="dv">2</span> ], <span class="st">'Ladestand Folgejahre'</span>: ladestand_speicher[ <span class="bu">len</span>(jahresgang_speicher) <span class="op">//</span> <span class="dv">2</span> : ], <span class="st">'freie Kapazität Folgejahre'</span>: jahresgang_speicher[ <span class="bu">len</span>(jahresgang_speicher) <span class="op">//</span> <span class="dv">2</span> : ]})</span>
<span id="cb52-37"><a href="#cb52-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-38"><a href="#cb52-38" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">Summe data: </span><span class="sc">{</span>data<span class="sc">.</span><span class="bu">sum</span>()<span class="sc">}</span><span class="ch">\n</span><span class="ss">Speichergröße: </span><span class="sc">{</span>speichergr<span class="sc">öß</span>e<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb52-39"><a href="#cb52-39" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(dataset)</span>
<span id="cb52-40"><a href="#cb52-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-41"><a href="#cb52-41" aria-hidden="true" tabindex="-1"></a>  <span class="cf">else</span>: <span class="co"># output = False</span></span>
<span id="cb52-42"><a href="#cb52-42" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> speichergröße, pd.Series(ladestand_speicher[ : <span class="bu">len</span>(jahresgang_speicher) <span class="op">//</span> <span class="dv">2</span> ]), pd.Series(ladestand_speicher[ <span class="bu">len</span>(jahresgang_speicher) <span class="op">//</span> <span class="dv">2</span> : ])</span>
<span id="cb52-43"><a href="#cb52-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-44"><a href="#cb52-44" aria-hidden="true" tabindex="-1"></a>speicher_2023 <span class="op">=</span> jahresgang_speicher_berechnen(restlast, output <span class="op">=</span> <span class="va">False</span>)</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<div id="tabset-11-2" class="tab-pane" role="tabpanel" aria-labelledby="tabset-11-2-tab">
<div id="43e7c215" class="cell" data-execution_count="53">
<div class="cell-output cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="Energiedatenauswertung_files/figure-html/cell-54-output-1.png" width="710" height="569" class="figure-img"></p>
<figcaption>Restlast 2023 und Jahresgang eines Speichers mit Wirkungsgrad 1</figcaption>
</figure>
</div>
</div>
</div>
</div>
<div id="tabset-11-3" class="tab-pane" role="tabpanel" aria-labelledby="tabset-11-3-tab">
<div id="e85d91c4" class="cell" data-execution_count="54">
<div class="sourceCode cell-code" id="cb53"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Daten einlesen</span></span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a>jahresgang_speicher_jahr1 <span class="op">=</span> speicher_2023[<span class="dv">1</span>]</span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a>jahresgang_speicher_jahr2 <span class="op">=</span> speicher_2023[<span class="dv">2</span>]</span>
<span id="cb53-4"><a href="#cb53-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-5"><a href="#cb53-5" aria-hidden="true" tabindex="-1"></a><span class="co"># xticks erzeugen</span></span>
<span id="cb53-6"><a href="#cb53-6" aria-hidden="true" tabindex="-1"></a>monate_index <span class="op">=</span> erzeugung[<span class="op">~</span>erzeugung[<span class="st">"Datum von"</span>].dt.month.duplicated()].index</span>
<span id="cb53-7"><a href="#cb53-7" aria-hidden="true" tabindex="-1"></a>monatsnamen <span class="op">=</span> erzeugung[<span class="st">"Datum von"</span>].iloc[monate_index].dt.strftime(<span class="st">"%B"</span>) </span>
<span id="cb53-8"><a href="#cb53-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-9"><a href="#cb53-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Grafik mit drei subplots erzeugen</span></span>
<span id="cb53-10"><a href="#cb53-10" aria-hidden="true" tabindex="-1"></a>font_size <span class="op">=</span> <span class="dv">10</span></span>
<span id="cb53-11"><a href="#cb53-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-12"><a href="#cb53-12" aria-hidden="true" tabindex="-1"></a>fig, (ax1, ax2, ax3) <span class="op">=</span> plt.subplots(<span class="dv">3</span>, <span class="dv">1</span>, figsize <span class="op">=</span> (<span class="fl">7.5</span>, <span class="dv">6</span>), height_ratios <span class="op">=</span> [<span class="dv">2</span>, <span class="dv">1</span>, <span class="dv">1</span>], sharex <span class="op">=</span> <span class="va">True</span>, layout <span class="op">=</span> <span class="st">'tight'</span>)</span>
<span id="cb53-13"><a href="#cb53-13" aria-hidden="true" tabindex="-1"></a>plt.suptitle(<span class="st">'Restlast 2023 und Jahresgang eines Speichers mit Wirkungsgrad 1'</span>)</span>
<span id="cb53-14"><a href="#cb53-14" aria-hidden="true" tabindex="-1"></a>plt.xticks(monate_index, monatsnamen, rotation <span class="op">=</span> <span class="dv">45</span>)<span class="op">;</span></span>
<span id="cb53-15"><a href="#cb53-15" aria-hidden="true" tabindex="-1"></a>plt.minorticks_off()</span>
<span id="cb53-16"><a href="#cb53-16" aria-hidden="true" tabindex="-1"></a>plt.setp([ax1, ax2, ax3], xlim <span class="op">=</span> (restlast.index.<span class="bu">min</span>() <span class="op">-</span> <span class="bu">len</span>(restlast.index) <span class="op">/</span> <span class="dv">100</span>, restlast.index.<span class="bu">max</span>() <span class="op">*</span> <span class="fl">1.01</span>))</span>
<span id="cb53-17"><a href="#cb53-17" aria-hidden="true" tabindex="-1"></a>plt.setp([ax2, ax3], ylim <span class="op">=</span> (<span class="dv">0</span>, <span class="bu">max</span>(<span class="bu">max</span>(jahresgang_speicher_jahr1), <span class="bu">max</span>(jahresgang_speicher_jahr2)) <span class="op">*</span> <span class="fl">1.1</span>))</span>
<span id="cb53-18"><a href="#cb53-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-19"><a href="#cb53-19" aria-hidden="true" tabindex="-1"></a><span class="co">## plot restlast</span></span>
<span id="cb53-20"><a href="#cb53-20" aria-hidden="true" tabindex="-1"></a>ax1.plot(restlast, label <span class="op">=</span> <span class="st">"Restlast"</span>)</span>
<span id="cb53-21"><a href="#cb53-21" aria-hidden="true" tabindex="-1"></a>ax1.grid()</span>
<span id="cb53-22"><a href="#cb53-22" aria-hidden="true" tabindex="-1"></a>ax1.set_ylabel(<span class="st">'MWh'</span>)</span>
<span id="cb53-23"><a href="#cb53-23" aria-hidden="true" tabindex="-1"></a>ax1.legend()</span>
<span id="cb53-24"><a href="#cb53-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-25"><a href="#cb53-25" aria-hidden="true" tabindex="-1"></a><span class="co">## plot jahresgang_speicher_jahr1</span></span>
<span id="cb53-26"><a href="#cb53-26" aria-hidden="true" tabindex="-1"></a>ax2.plot(jahresgang_speicher_jahr1, color <span class="op">=</span> <span class="st">'black'</span>, linestyle <span class="op">=</span> <span class="st">'-'</span>, label <span class="op">=</span> <span class="st">'Stromspeicher Jahr 1'</span>)</span>
<span id="cb53-27"><a href="#cb53-27" aria-hidden="true" tabindex="-1"></a>ax2.grid()</span>
<span id="cb53-28"><a href="#cb53-28" aria-hidden="true" tabindex="-1"></a>ax2.set_ylabel(<span class="st">'MWh'</span>)</span>
<span id="cb53-29"><a href="#cb53-29" aria-hidden="true" tabindex="-1"></a>ax2.legend()</span>
<span id="cb53-30"><a href="#cb53-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-31"><a href="#cb53-31" aria-hidden="true" tabindex="-1"></a><span class="co">## plot jahresgang_speicher_jahr2</span></span>
<span id="cb53-32"><a href="#cb53-32" aria-hidden="true" tabindex="-1"></a>ax3.plot(jahresgang_speicher_jahr2, color <span class="op">=</span> <span class="st">'black'</span>, linestyle <span class="op">=</span> <span class="st">'-'</span>, label <span class="op">=</span> <span class="st">'Stromspeicher Jahr 2'</span>)</span>
<span id="cb53-33"><a href="#cb53-33" aria-hidden="true" tabindex="-1"></a>ax3.tick_params(axis <span class="op">=</span> <span class="st">'x'</span>, rotation <span class="op">=</span> <span class="dv">45</span>)</span>
<span id="cb53-34"><a href="#cb53-34" aria-hidden="true" tabindex="-1"></a>ax3.set_ylabel(<span class="st">'MWh'</span>)</span>
<span id="cb53-35"><a href="#cb53-35" aria-hidden="true" tabindex="-1"></a>ax3.grid()</span>
<span id="cb53-36"><a href="#cb53-36" aria-hidden="true" tabindex="-1"></a>ax3.legend()</span>
<span id="cb53-37"><a href="#cb53-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-38"><a href="#cb53-38" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<div id="tabset-11-4" class="tab-pane" role="tabpanel" aria-labelledby="tabset-11-4-tab">
<div id="e88e02a7" class="cell" data-execution_count="55">
<div class="sourceCode cell-code" id="cb54"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Jahresgang des Speichers berechnen</span></span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a><span class="co">## Eingabe: data = pd.Series(data, dtype = 'float'), speichergröße = -1, einspeicherwirkungsgrad = 1, ausspeicherwirkungsgrad = 1, output = False</span></span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true" tabindex="-1"></a><span class="co">## Verarbeitung: Wenn speichergröße = -1 wird die Speichergröße mit der Funktion berechne_speichergröße(data) ermittelt</span></span>
<span id="cb54-4"><a href="#cb54-4" aria-hidden="true" tabindex="-1"></a><span class="co">## Verarbeitung: data wird zwei mal zu data_x2 verkettet.</span></span>
<span id="cb54-5"><a href="#cb54-5" aria-hidden="true" tabindex="-1"></a><span class="co">## Verarbeitung: Anhand der Speichergröße werden der Ladestand und die freie Kapazität des Speichers für alle Werte von data für Jahr1 und alle Folgejahre berechnet.</span></span>
<span id="cb54-6"><a href="#cb54-6" aria-hidden="true" tabindex="-1"></a><span class="co">## Ausgabe: Wenn output False ist, wird ein Tupel aus speichergröße (float), Ladestand Jahr1 (pd.Series), Ladestand Jahr2 (pd.Series) zurückgegeben.</span></span>
<span id="cb54-7"><a href="#cb54-7" aria-hidden="true" tabindex="-1"></a><span class="co">## Ausgabe: Wenn output True, werden die kumulierte Summe der Restlast, die Speichergröße, die Restlastkurve, die Ladestände und freie Kapazität des Speichers im Jahresgang für Jahr 1 und Jahr 2 mit ausgegeben</span></span>
<span id="cb54-8"><a href="#cb54-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-9"><a href="#cb54-9" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> jahresgang_speicher_berechnen(data, speichergröße <span class="op">=</span> <span class="op">-</span><span class="dv">1</span>, einspeicherwirkungsgrad <span class="op">=</span> <span class="dv">1</span>, ausspeicherwirkungsgrad <span class="op">=</span> <span class="dv">1</span>, output <span class="op">=</span> <span class="va">False</span>):</span>
<span id="cb54-10"><a href="#cb54-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-11"><a href="#cb54-11" aria-hidden="true" tabindex="-1"></a>  data_x2 <span class="op">=</span> pd.concat([data, data])</span>
<span id="cb54-12"><a href="#cb54-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-13"><a href="#cb54-13" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> speichergröße <span class="op">==</span> <span class="op">-</span><span class="dv">1</span>:</span>
<span id="cb54-14"><a href="#cb54-14" aria-hidden="true" tabindex="-1"></a>    speichergröße <span class="op">=</span> berechne_speichergröße(data, einspeicherwirkungsgrad, ausspeicherwirkungsgrad) </span>
<span id="cb54-15"><a href="#cb54-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-16"><a href="#cb54-16" aria-hidden="true" tabindex="-1"></a>  jahresgang_speicher <span class="op">=</span> []</span>
<span id="cb54-17"><a href="#cb54-17" aria-hidden="true" tabindex="-1"></a>  ladestand_speicher <span class="op">=</span> []</span>
<span id="cb54-18"><a href="#cb54-18" aria-hidden="true" tabindex="-1"></a>  freie_speicherkapazität <span class="op">=</span> speichergröße <span class="co"># der speicher ist leer </span></span>
<span id="cb54-19"><a href="#cb54-19" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> i <span class="kw">in</span> data_x2:</span>
<span id="cb54-20"><a href="#cb54-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-21"><a href="#cb54-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> i <span class="op">&gt;</span> <span class="dv">0</span>: <span class="co"># Restlast</span></span>
<span id="cb54-22"><a href="#cb54-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-23"><a href="#cb54-23" aria-hidden="true" tabindex="-1"></a>      <span class="co"># last ohne entsprechende vorherige Einspeicherung kann nicht vollständig bedient werden, der Speicher ist dann leer</span></span>
<span id="cb54-24"><a href="#cb54-24" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> (speichergröße <span class="op">-</span> freie_speicherkapazität) <span class="op">-</span> i <span class="op">/</span> ausspeicherwirkungsgrad <span class="op">&lt;</span> <span class="dv">0</span>:</span>
<span id="cb54-25"><a href="#cb54-25" aria-hidden="true" tabindex="-1"></a>        freie_speicherkapazität <span class="op">=</span> speichergröße</span>
<span id="cb54-26"><a href="#cb54-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-27"><a href="#cb54-27" aria-hidden="true" tabindex="-1"></a>      <span class="cf">else</span>: <span class="co"># Ausspeicherung</span></span>
<span id="cb54-28"><a href="#cb54-28" aria-hidden="true" tabindex="-1"></a>        freie_speicherkapazität <span class="op">+=</span> i <span class="op">/</span> ausspeicherwirkungsgrad <span class="co"># hier kann zu viel ausgespeichert werden</span></span>
<span id="cb54-29"><a href="#cb54-29" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> freie_speicherkapazität <span class="op">&gt;</span> speichergröße:</span>
<span id="cb54-30"><a href="#cb54-30" aria-hidden="true" tabindex="-1"></a>          freie_speicherkapazität <span class="op">=</span> speichergröße</span>
<span id="cb54-31"><a href="#cb54-31" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb54-32"><a href="#cb54-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>: <span class="co"># i &lt;= 0 EE-Überschuss</span></span>
<span id="cb54-33"><a href="#cb54-33" aria-hidden="true" tabindex="-1"></a>      </span>
<span id="cb54-34"><a href="#cb54-34" aria-hidden="true" tabindex="-1"></a>      <span class="co"># wenn der Speicher voll ist, muss Überschuss verworfen werden.</span></span>
<span id="cb54-35"><a href="#cb54-35" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> freie_speicherkapazität <span class="op">+</span> i <span class="op">*</span> einspeicherwirkungsgrad <span class="op">&lt;</span> <span class="dv">0</span>: </span>
<span id="cb54-36"><a href="#cb54-36" aria-hidden="true" tabindex="-1"></a>        freie_speicherkapazität <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb54-37"><a href="#cb54-37" aria-hidden="true" tabindex="-1"></a>      </span>
<span id="cb54-38"><a href="#cb54-38" aria-hidden="true" tabindex="-1"></a>      <span class="cf">else</span>: <span class="co"># Einspeicherung</span></span>
<span id="cb54-39"><a href="#cb54-39" aria-hidden="true" tabindex="-1"></a>        freie_speicherkapazität <span class="op">+=</span> i <span class="op">*</span> einspeicherwirkungsgrad</span>
<span id="cb54-40"><a href="#cb54-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-41"><a href="#cb54-41" aria-hidden="true" tabindex="-1"></a>    jahresgang_speicher.append(freie_speicherkapazität)</span>
<span id="cb54-42"><a href="#cb54-42" aria-hidden="true" tabindex="-1"></a>    ladestand_speicher.append(speichergröße <span class="op">-</span> freie_speicherkapazität)</span>
<span id="cb54-43"><a href="#cb54-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-44"><a href="#cb54-44" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> output: <span class="co"># output = True</span></span>
<span id="cb54-45"><a href="#cb54-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-46"><a href="#cb54-46" aria-hidden="true" tabindex="-1"></a>    dataset <span class="op">=</span> pd.DataFrame({<span class="st">'Restlast'</span>: data, <span class="st">'Ladestand Jahr1'</span>: ladestand_speicher[ : <span class="bu">len</span>(jahresgang_speicher) <span class="op">//</span> <span class="dv">2</span> ], <span class="st">'freie Kapazität Jahr1'</span>: jahresgang_speicher[ : <span class="bu">len</span>(jahresgang_speicher) <span class="op">//</span> <span class="dv">2</span> ], <span class="st">'Ladestand Folgejahre'</span>: ladestand_speicher[ <span class="bu">len</span>(jahresgang_speicher) <span class="op">//</span> <span class="dv">2</span> : ], <span class="st">'freie Kapazität Folgejahre'</span>: jahresgang_speicher[ <span class="bu">len</span>(jahresgang_speicher) <span class="op">//</span> <span class="dv">2</span> : ]})</span>
<span id="cb54-47"><a href="#cb54-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-48"><a href="#cb54-48" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">Summe data: </span><span class="sc">{</span>data<span class="sc">.</span><span class="bu">sum</span>()<span class="sc">}</span><span class="ch">\n</span><span class="ss">Speichergröße: </span><span class="sc">{</span>speichergr<span class="sc">öß</span>e<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb54-49"><a href="#cb54-49" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(dataset)</span>
<span id="cb54-50"><a href="#cb54-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-51"><a href="#cb54-51" aria-hidden="true" tabindex="-1"></a>  <span class="cf">else</span>: <span class="co"># output = False</span></span>
<span id="cb54-52"><a href="#cb54-52" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> speichergröße, pd.Series(ladestand_speicher[ : <span class="bu">len</span>(jahresgang_speicher) <span class="op">//</span> <span class="dv">2</span> ]), pd.Series(ladestand_speicher[ <span class="bu">len</span>(jahresgang_speicher) <span class="op">//</span> <span class="dv">2</span> : ])</span>
<span id="cb54-53"><a href="#cb54-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-54"><a href="#cb54-54" aria-hidden="true" tabindex="-1"></a>speicher_2023_wirkungsgrad_90_90 <span class="op">=</span> jahresgang_speicher_berechnen(restlast, einspeicherwirkungsgrad <span class="op">=</span> <span class="fl">0.9</span>, ausspeicherwirkungsgrad <span class="op">=</span> <span class="fl">0.9</span>, output <span class="op">=</span> <span class="va">False</span>)</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
<div id="tabset-11-5" class="tab-pane" role="tabpanel" aria-labelledby="tabset-11-5-tab">
<div id="51f4d1c8" class="cell" data-execution_count="56">
<div class="cell-output cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="Energiedatenauswertung_files/figure-html/cell-57-output-1.png" width="734" height="569" class="figure-img"></p>
<figcaption>Restlast 2023 und Jahresgang eines Speichers mit Ein- und Ausspeicherwirkungsgrad 0.9</figcaption>
</figure>
</div>
</div>
</div>
</div>
<div id="tabset-11-6" class="tab-pane" role="tabpanel" aria-labelledby="tabset-11-6-tab">
<div id="08dae15f" class="cell" data-execution_count="57">
<div class="sourceCode cell-code" id="cb55"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Daten einlesen</span></span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a>jahresgang_speicher_jahr1 <span class="op">=</span> speicher_2023_wirkungsgrad_90_90[<span class="dv">1</span>]</span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true" tabindex="-1"></a>jahresgang_speicher_jahr2 <span class="op">=</span> speicher_2023_wirkungsgrad_90_90[<span class="dv">2</span>]</span>
<span id="cb55-4"><a href="#cb55-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-5"><a href="#cb55-5" aria-hidden="true" tabindex="-1"></a><span class="co"># xticks erzeugen</span></span>
<span id="cb55-6"><a href="#cb55-6" aria-hidden="true" tabindex="-1"></a>monate_index <span class="op">=</span> erzeugung[<span class="op">~</span>erzeugung[<span class="st">"Datum von"</span>].dt.month.duplicated()].index</span>
<span id="cb55-7"><a href="#cb55-7" aria-hidden="true" tabindex="-1"></a>monatsnamen <span class="op">=</span> erzeugung[<span class="st">"Datum von"</span>].iloc[monate_index].dt.strftime(<span class="st">"%B"</span>) </span>
<span id="cb55-8"><a href="#cb55-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-9"><a href="#cb55-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Grafik mit drei subplots erzeugen</span></span>
<span id="cb55-10"><a href="#cb55-10" aria-hidden="true" tabindex="-1"></a>font_size <span class="op">=</span> <span class="dv">10</span></span>
<span id="cb55-11"><a href="#cb55-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-12"><a href="#cb55-12" aria-hidden="true" tabindex="-1"></a>fig, (ax1, ax2, ax3) <span class="op">=</span> plt.subplots(<span class="dv">3</span>, <span class="dv">1</span>, figsize <span class="op">=</span> (<span class="fl">7.5</span>, <span class="dv">6</span>), height_ratios <span class="op">=</span> [<span class="dv">2</span>, <span class="dv">1</span>, <span class="dv">1</span>], sharex <span class="op">=</span> <span class="va">True</span>, layout <span class="op">=</span> <span class="st">'tight'</span>)</span>
<span id="cb55-13"><a href="#cb55-13" aria-hidden="true" tabindex="-1"></a>plt.suptitle(<span class="st">'Restlast 2023 und Jahresgang eines Speichers mit Ein- und Ausspeicherwirkungsgrad 0.9'</span>)</span>
<span id="cb55-14"><a href="#cb55-14" aria-hidden="true" tabindex="-1"></a>plt.xticks(monate_index, monatsnamen, rotation <span class="op">=</span> <span class="dv">45</span>)<span class="op">;</span></span>
<span id="cb55-15"><a href="#cb55-15" aria-hidden="true" tabindex="-1"></a>plt.minorticks_off()</span>
<span id="cb55-16"><a href="#cb55-16" aria-hidden="true" tabindex="-1"></a>plt.setp([ax1, ax2, ax3], xlim <span class="op">=</span> (restlast.index.<span class="bu">min</span>() <span class="op">-</span> <span class="bu">len</span>(restlast.index) <span class="op">/</span> <span class="dv">100</span>, restlast.index.<span class="bu">max</span>() <span class="op">*</span> <span class="fl">1.01</span>))</span>
<span id="cb55-17"><a href="#cb55-17" aria-hidden="true" tabindex="-1"></a>plt.setp([ax2, ax3], ylim <span class="op">=</span> (<span class="dv">0</span>, <span class="bu">max</span>(<span class="bu">max</span>(jahresgang_speicher_jahr1), <span class="bu">max</span>(jahresgang_speicher_jahr2)) <span class="op">*</span> <span class="fl">1.1</span>))</span>
<span id="cb55-18"><a href="#cb55-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-19"><a href="#cb55-19" aria-hidden="true" tabindex="-1"></a><span class="co">## plot restlast</span></span>
<span id="cb55-20"><a href="#cb55-20" aria-hidden="true" tabindex="-1"></a>ax1.plot(restlast, label <span class="op">=</span> <span class="st">"Restlast"</span>)</span>
<span id="cb55-21"><a href="#cb55-21" aria-hidden="true" tabindex="-1"></a>ax1.grid()</span>
<span id="cb55-22"><a href="#cb55-22" aria-hidden="true" tabindex="-1"></a>ax1.set_ylabel(<span class="st">'MWh'</span>)</span>
<span id="cb55-23"><a href="#cb55-23" aria-hidden="true" tabindex="-1"></a>ax1.legend()</span>
<span id="cb55-24"><a href="#cb55-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-25"><a href="#cb55-25" aria-hidden="true" tabindex="-1"></a><span class="co">## plot jahresgang_speicher_jahr1</span></span>
<span id="cb55-26"><a href="#cb55-26" aria-hidden="true" tabindex="-1"></a>ax2.plot(jahresgang_speicher_jahr1, color <span class="op">=</span> <span class="st">'black'</span>, linestyle <span class="op">=</span> <span class="st">'-'</span>, label <span class="op">=</span> <span class="st">'Stromspeicher Jahr 1'</span>)</span>
<span id="cb55-27"><a href="#cb55-27" aria-hidden="true" tabindex="-1"></a>ax2.grid()</span>
<span id="cb55-28"><a href="#cb55-28" aria-hidden="true" tabindex="-1"></a>ax2.set_ylabel(<span class="st">'MWh'</span>)</span>
<span id="cb55-29"><a href="#cb55-29" aria-hidden="true" tabindex="-1"></a>ax2.legend()</span>
<span id="cb55-30"><a href="#cb55-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-31"><a href="#cb55-31" aria-hidden="true" tabindex="-1"></a><span class="co">## plot jahresgang_speicher_jahr2</span></span>
<span id="cb55-32"><a href="#cb55-32" aria-hidden="true" tabindex="-1"></a>ax3.plot(jahresgang_speicher_jahr2, color <span class="op">=</span> <span class="st">'black'</span>, linestyle <span class="op">=</span> <span class="st">'-'</span>, label <span class="op">=</span> <span class="st">'Stromspeicher Jahr 2'</span>)</span>
<span id="cb55-33"><a href="#cb55-33" aria-hidden="true" tabindex="-1"></a>ax3.tick_params(axis <span class="op">=</span> <span class="st">'x'</span>, rotation <span class="op">=</span> <span class="dv">45</span>)</span>
<span id="cb55-34"><a href="#cb55-34" aria-hidden="true" tabindex="-1"></a>ax3.set_ylabel(<span class="st">'MWh'</span>)</span>
<span id="cb55-35"><a href="#cb55-35" aria-hidden="true" tabindex="-1"></a>ax3.grid()</span>
<span id="cb55-36"><a href="#cb55-36" aria-hidden="true" tabindex="-1"></a>ax3.legend()</span>
<span id="cb55-37"><a href="#cb55-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-38"><a href="#cb55-38" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</div>
</div>
</div>
<p>Die benötigte Kapazität des Speichers ergibt sich aus den ereuerbaren Erzeugungsüberschüssen während der Weihnachtsfeiertage. Diese Kapazitäten werden im übrigen Jahr kaum genutzt, der Speicher ist die meiste Zeit des Jahres leer. Der Jahresgang für das erste und das zweite Jahr ist optisch identisch. Dies kann mit <code>pd.Series1.equals(pd.Series2)</code> leicht überprüft werden. Werden Ein- und Ausspeicherwirkungsgrade berücksichtigt, reduzieren sich die ein- und ausgespeicherte Energie und somit die erforderliche Speichergröße.</p>
</section>
<section id="zyklenzahl-berechnen" class="level4">
<h4 class="anchored" data-anchor-id="zyklenzahl-berechnen">Zyklenzahl berechnen</h4>
<p>Anhand der Speichergröße und des Jahresgangs des Speichers kann die Zyklenzahl im ersten und in allen Folgejahren berechnet werden. Ein Zyklus entspricht der vollständigen Ladung und Entladung des Speichers bzw. einer entsprechenden Anzahl von Teilladezyklen. Die Zyklenzahl ergibt sich somit aus der Summe der im Jahresgang des Speichers ein- bzw. ausgespeicherten Energie, die durch die Speichergröße und durch 2 geteilt wird.</p>
<ul>
<li><p>Eingabe: Der Funktion kann ein Tupel bestehend aus einer Speichergröße an Position 0 und Speicherjahresgängen für Jahr 1 und Jahr 2 an den Positionen 1 und 2 übergeben werden. Andernfalls werden diese durch Aufruf der Funktion jahresgang_speicher_berechnen ermittelt (ohne bzw. mit Ein- und Ausspeicherwirkungsgrad).</p></li>
<li><p>Verarbeitung: Für die Speicherjahresgänge wird mit der Methode <code>pd.Series.diff()</code> elementweise die Differenz jedes Werts zu seinem Vorgänger gebildet (gleitende Differenz). Beispielsweise ist für die Zahlenreihe <code>1, 4, -6, 2</code> die elementweise Differenz <code>NaN, 3, -10, 8</code>. Da der erste Wert keinen Vorgänger hat, ist die Differenz NaN. Deshalb wird für die gleitende Differenzberechnung dem Jahresgang in Jahr 1 eine Null vorangestellt, dem Jahresgang in Jahr 2 der letzte Wert aus Jahr 1. Die Zahlreihe für Jahr 2 sähe beispielsweise so aus: <code>2, 1, 4, -6, 2</code>. Die elementweise Differenz wäre: <code>NaN, -1, 3, -10, 8</code>. Anschließend werden die Werte absolut gesetzt und summiert. Die Anweisung lautet somit: <code>pd.Series.diff().abs().sum()</code>. Zur Ermittlung der Zyklenzahl wird die Summe der ein- und ausgespeicherten Energie durch die Speichergröße und durch 2 geteilt.</p></li>
<li><p>Ausgabe: Die Funktion gibt, wenn <code>output = False</code> ist, ein Tupel der Zyklenzahl für Jahr 1 und Jahr 2 zurück. Ist <code>output = True</code>, erfolgt die Ausgabe mit <code>print()</code></p></li>
</ul>
<div class="tabset-margin-container"></div><div class="panel-tabset">
<ul class="nav nav-tabs" role="tablist"><li class="nav-item" role="presentation"><a class="nav-link active" id="tabset-12-1-tab" data-bs-toggle="tab" data-bs-target="#tabset-12-1" role="tab" aria-controls="tabset-12-1" aria-selected="true" href="">ohne Wirkungsgrad</a></li><li class="nav-item" role="presentation"><a class="nav-link" id="tabset-12-2-tab" data-bs-toggle="tab" data-bs-target="#tabset-12-2" role="tab" aria-controls="tabset-12-2" aria-selected="false" href="">mit Wirkungsgrad</a></li></ul>
<div class="tab-content">
<div id="tabset-12-1" class="tab-pane active" role="tabpanel" aria-labelledby="tabset-12-1-tab">
<div id="2c3bea7e" class="cell" data-execution_count="58">
<div class="sourceCode cell-code" id="cb56"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Zyklenzahl berechnen</span></span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a><span class="co">## Eingabe: data = pd.Series(data, dtype = 'float'), output = False</span></span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true" tabindex="-1"></a><span class="co">## Eingabe: Wenn die Eingabe ein Tupel {'Speichergröße': float, 'jahresgang_speicher_jahr1': pd.Series, 'jahresgang_speicher_jahr2': pd.Series} ist, wird die Zyklenzahl direkt berechnet.</span></span>
<span id="cb56-4"><a href="#cb56-4" aria-hidden="true" tabindex="-1"></a><span class="co">## Eingabe: Wenn die Eingabe data = pd.Series(data, dtype = 'float') ist, wird jahresgang_speicher_berechnen(data, speichergröße = -1, output = False) aufgerufen</span></span>
<span id="cb56-5"><a href="#cb56-5" aria-hidden="true" tabindex="-1"></a><span class="co">## Verarbeitung: Elementweise wird für Jahr 1 und Jahr 2 die Differenz aufeinanderfolgender Werte gebildet, absolut gesetzt und aufsummiert</span></span>
<span id="cb56-6"><a href="#cb56-6" aria-hidden="true" tabindex="-1"></a><span class="co">## Verarbeitung: Für die gleitende Differenzberechnung muss dem Jahresgang in Jahr 1 eine Null vorangestellt werden, dem Jahresgang in Jahr 2 der letzte Wert aus Jahr 1</span></span>
<span id="cb56-7"><a href="#cb56-7" aria-hidden="true" tabindex="-1"></a><span class="co">## Verarbeitung: Die Summe der Speicherladungen und -entladungen wird durch die Speichergröße und durch 2 geteilt.</span></span>
<span id="cb56-8"><a href="#cb56-8" aria-hidden="true" tabindex="-1"></a><span class="co">## Ausgabe: Zyklenzahl für Jahr 1 und Jahr 2 - wenn output = False als Rückgabewert (Tupel), wenn output = True mit print()</span></span>
<span id="cb56-9"><a href="#cb56-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-10"><a href="#cb56-10" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> zyklenzahl_berechnen(data, output <span class="op">=</span> <span class="va">False</span>):</span>
<span id="cb56-11"><a href="#cb56-11" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb56-12"><a href="#cb56-12" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="bu">type</span>(data) <span class="kw">is</span> <span class="bu">tuple</span>: <span class="co"># Speichergröße und Jahresgänge wurden übergeben</span></span>
<span id="cb56-13"><a href="#cb56-13" aria-hidden="true" tabindex="-1"></a>    speichergröße <span class="op">=</span> data[<span class="dv">0</span>]</span>
<span id="cb56-14"><a href="#cb56-14" aria-hidden="true" tabindex="-1"></a>    jahresgang_speicher_jahr1 <span class="op">=</span> data[<span class="dv">1</span>]</span>
<span id="cb56-15"><a href="#cb56-15" aria-hidden="true" tabindex="-1"></a>    jahresgang_speicher_jahr2 <span class="op">=</span> data[<span class="dv">2</span>]</span>
<span id="cb56-16"><a href="#cb56-16" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb56-17"><a href="#cb56-17" aria-hidden="true" tabindex="-1"></a>  <span class="cf">else</span>: <span class="co"># Restlast wurde übergeben</span></span>
<span id="cb56-18"><a href="#cb56-18" aria-hidden="true" tabindex="-1"></a>    ergebnis <span class="op">=</span> jahresgang_speicher_berechnen(data, speichergröße <span class="op">=</span> <span class="op">-</span><span class="dv">1</span>, output <span class="op">=</span> <span class="va">False</span>)</span>
<span id="cb56-19"><a href="#cb56-19" aria-hidden="true" tabindex="-1"></a>    speichergröße <span class="op">=</span> ergebnis[<span class="dv">0</span>]</span>
<span id="cb56-20"><a href="#cb56-20" aria-hidden="true" tabindex="-1"></a>    jahresgang_speicher_jahr1 <span class="op">=</span> ergebnis[<span class="dv">1</span>]</span>
<span id="cb56-21"><a href="#cb56-21" aria-hidden="true" tabindex="-1"></a>    jahresgang_speicher_jahr2 <span class="op">=</span> ergebnis[<span class="dv">2</span>]</span>
<span id="cb56-22"><a href="#cb56-22" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb56-23"><a href="#cb56-23" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Jahresgang Jahr 1 eine Null voranstellen, Jahresgang Jahr 2 den letzten Wert aus Jahr 1</span></span>
<span id="cb56-24"><a href="#cb56-24" aria-hidden="true" tabindex="-1"></a>  jahresgang_speicher_jahr1 <span class="op">=</span> pd.concat([pd.Series(<span class="dv">0</span>), jahresgang_speicher_jahr1])</span>
<span id="cb56-25"><a href="#cb56-25" aria-hidden="true" tabindex="-1"></a>  jahresgang_speicher_jahr2 <span class="op">=</span> pd.concat([jahresgang_speicher_jahr1[ <span class="op">-</span> <span class="dv">1</span>: ], jahresgang_speicher_jahr2])</span>
<span id="cb56-26"><a href="#cb56-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-27"><a href="#cb56-27" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Zyklenzahl berechnen</span></span>
<span id="cb56-28"><a href="#cb56-28" aria-hidden="true" tabindex="-1"></a>  zyklenzahl_jahr1 <span class="op">=</span> jahresgang_speicher_jahr1.diff().<span class="bu">abs</span>().<span class="bu">sum</span>() <span class="op">/</span> (speichergröße <span class="op">*</span> <span class="dv">2</span>) <span class="co"># ein Zyklus = vollständiges Be- und Entladen --&gt; durch 2 teilen</span></span>
<span id="cb56-29"><a href="#cb56-29" aria-hidden="true" tabindex="-1"></a>  zyklenzahl_jahr2 <span class="op">=</span> jahresgang_speicher_jahr2.diff().<span class="bu">abs</span>().<span class="bu">sum</span>() <span class="op">/</span> (speichergröße <span class="op">*</span> <span class="dv">2</span>) <span class="co"># ein Zyklus = vollständiges Be- und Entladen --&gt; durch 2 teilen</span></span>
<span id="cb56-30"><a href="#cb56-30" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb56-31"><a href="#cb56-31" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> output:</span>
<span id="cb56-32"><a href="#cb56-32" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Zyklenzahl Jahr 1: </span><span class="sc">{</span>zyklenzahl_jahr1<span class="sc">:,.2f}</span><span class="ch">\n</span><span class="ss">"</span></span>
<span id="cb56-33"><a href="#cb56-33" aria-hidden="true" tabindex="-1"></a>          <span class="ss">f"Zyklenzahl Jahr 2: </span><span class="sc">{</span>zyklenzahl_jahr2<span class="sc">:,.2f}</span><span class="ss">"</span>)</span>
<span id="cb56-34"><a href="#cb56-34" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb56-35"><a href="#cb56-35" aria-hidden="true" tabindex="-1"></a>  <span class="cf">else</span>:</span>
<span id="cb56-36"><a href="#cb56-36" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> zyklenzahl_jahr1, zyklenzahl_jahr2</span>
<span id="cb56-37"><a href="#cb56-37" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb56-38"><a href="#cb56-38" aria-hidden="true" tabindex="-1"></a>zyklenzahl_berechnen(speicher_2023, output <span class="op">=</span> <span class="va">True</span>)</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Zyklenzahl Jahr 1: 8.38
Zyklenzahl Jahr 2: 8.38</code></pre>
</div>
</div>
</div>
<div id="tabset-12-2" class="tab-pane" role="tabpanel" aria-labelledby="tabset-12-2-tab">
<div id="491a7bd5" class="cell" data-execution_count="59">
<div class="sourceCode cell-code" id="cb58"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Zyklenzahl berechnen mit Wirkungsgrad</span></span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a><span class="co">## Eingabe: data = pd.Series(data, dtype = 'float'), einspeicherwirkungsgrad = 1, ausspeicherwirkungsgrad = 1, output = False</span></span>
<span id="cb58-3"><a href="#cb58-3" aria-hidden="true" tabindex="-1"></a><span class="co">## Eingabe: Wenn die Eingabe ein Tupel {'Speichergröße': float, 'jahresgang_speicher_jahr1': pd.Series, 'jahresgang_speicher_jahr2': pd.Series} ist, wird die Zyklenzahl direkt berechnet.</span></span>
<span id="cb58-4"><a href="#cb58-4" aria-hidden="true" tabindex="-1"></a><span class="co">## Eingabe: Wenn die Eingabe data = pd.Series(data, dtype = 'float') ist, wird jahresgang_speicher_berechnen(data, speichergröße = -1, einspeicherwirkungsgrad = 1, ausspeicherwirkungsgrad = 1, output = False) aufgerufen</span></span>
<span id="cb58-5"><a href="#cb58-5" aria-hidden="true" tabindex="-1"></a><span class="co">## Verarbeitung: Elementweise wird für Jahr 1 und Jahr 2 die Differenz aufeinanderfolgender Werte gebildet, absolut gesetzt und aufsummiert</span></span>
<span id="cb58-6"><a href="#cb58-6" aria-hidden="true" tabindex="-1"></a><span class="co">## Verarbeitung: Für die gleitende Differenzberechnung muss dem Jahresgang in Jahr 1 eine Null vorangestellt werden, dem Jahresgang in Jahr 2 der letzte Wert aus Jahr 1</span></span>
<span id="cb58-7"><a href="#cb58-7" aria-hidden="true" tabindex="-1"></a><span class="co">## Verarbeitung: Die Summe der Speicherladungen und -entladungen wird durch die Speichergröße und durch 2 geteilt.</span></span>
<span id="cb58-8"><a href="#cb58-8" aria-hidden="true" tabindex="-1"></a><span class="co">## Ausgabe: Zyklenzahl für Jahr 1 und Jahr 2 - wenn output = False als Rückgabewert (Tupel), wenn output = True mit print()</span></span>
<span id="cb58-9"><a href="#cb58-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-10"><a href="#cb58-10" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> zyklenzahl_berechnen(data, einspeicherwirkungsgrad <span class="op">=</span> <span class="dv">1</span>, ausspeicherwirkungsgrad <span class="op">=</span> <span class="dv">1</span>, output <span class="op">=</span> <span class="va">False</span>):</span>
<span id="cb58-11"><a href="#cb58-11" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb58-12"><a href="#cb58-12" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="bu">type</span>(data) <span class="kw">is</span> <span class="bu">tuple</span>: <span class="co"># Speichergröße und Jahresgänge wurden übergeben</span></span>
<span id="cb58-13"><a href="#cb58-13" aria-hidden="true" tabindex="-1"></a>    speichergröße <span class="op">=</span> data[<span class="dv">0</span>]</span>
<span id="cb58-14"><a href="#cb58-14" aria-hidden="true" tabindex="-1"></a>    jahresgang_speicher_jahr1 <span class="op">=</span> data[<span class="dv">1</span>]</span>
<span id="cb58-15"><a href="#cb58-15" aria-hidden="true" tabindex="-1"></a>    jahresgang_speicher_jahr2 <span class="op">=</span> data[<span class="dv">2</span>]</span>
<span id="cb58-16"><a href="#cb58-16" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb58-17"><a href="#cb58-17" aria-hidden="true" tabindex="-1"></a>  <span class="cf">else</span>: <span class="co"># Restlast wurde übergeben</span></span>
<span id="cb58-18"><a href="#cb58-18" aria-hidden="true" tabindex="-1"></a>    ergebnis <span class="op">=</span> jahresgang_speicher_berechnen(data, speichergröße <span class="op">=</span> <span class="op">-</span><span class="dv">1</span>, einspeicherwirkungsgrad <span class="op">=</span> einspeicherwirkungsgrad, ausspeicherwirkungsgrad <span class="op">=</span> ausspeicherwirkungsgrad, output <span class="op">=</span> <span class="va">False</span>)</span>
<span id="cb58-19"><a href="#cb58-19" aria-hidden="true" tabindex="-1"></a>    speichergröße <span class="op">=</span> ergebnis[<span class="dv">0</span>]</span>
<span id="cb58-20"><a href="#cb58-20" aria-hidden="true" tabindex="-1"></a>    jahresgang_speicher_jahr1 <span class="op">=</span> ergebnis[<span class="dv">1</span>]</span>
<span id="cb58-21"><a href="#cb58-21" aria-hidden="true" tabindex="-1"></a>    jahresgang_speicher_jahr2 <span class="op">=</span> ergebnis[<span class="dv">2</span>]</span>
<span id="cb58-22"><a href="#cb58-22" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb58-23"><a href="#cb58-23" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Jahresgang Jahr 1 eine Null voranstellen, Jahresgang Jahr 2 den letzten Wert aus Jahr 1</span></span>
<span id="cb58-24"><a href="#cb58-24" aria-hidden="true" tabindex="-1"></a>  jahresgang_speicher_jahr1 <span class="op">=</span> pd.concat([pd.Series(<span class="dv">0</span>), jahresgang_speicher_jahr1])</span>
<span id="cb58-25"><a href="#cb58-25" aria-hidden="true" tabindex="-1"></a>  jahresgang_speicher_jahr2 <span class="op">=</span> pd.concat([jahresgang_speicher_jahr1[ <span class="op">-</span> <span class="dv">1</span>: ], jahresgang_speicher_jahr2])</span>
<span id="cb58-26"><a href="#cb58-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb58-27"><a href="#cb58-27" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Zyklenzahl berechnen  </span></span>
<span id="cb58-28"><a href="#cb58-28" aria-hidden="true" tabindex="-1"></a>  zyklenzahl_jahr1 <span class="op">=</span> jahresgang_speicher_jahr1.diff().<span class="bu">abs</span>().<span class="bu">sum</span>() <span class="op">/</span> (speichergröße <span class="op">*</span> <span class="dv">2</span>) <span class="co"># ein Zyklus = vollständiges Be- und Entladen --&gt; durch 2 teilen</span></span>
<span id="cb58-29"><a href="#cb58-29" aria-hidden="true" tabindex="-1"></a>  zyklenzahl_jahr2 <span class="op">=</span> jahresgang_speicher_jahr2.diff().<span class="bu">abs</span>().<span class="bu">sum</span>() <span class="op">/</span> (speichergröße <span class="op">*</span> <span class="dv">2</span>) <span class="co"># ein Zyklus = vollständiges Be- und Entladen --&gt; durch 2 teilen</span></span>
<span id="cb58-30"><a href="#cb58-30" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb58-31"><a href="#cb58-31" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> output:</span>
<span id="cb58-32"><a href="#cb58-32" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Zyklenzahl Jahr 1: </span><span class="sc">{</span>zyklenzahl_jahr1<span class="sc">:,.2f}</span><span class="ch">\n</span><span class="ss">"</span></span>
<span id="cb58-33"><a href="#cb58-33" aria-hidden="true" tabindex="-1"></a>          <span class="ss">f"Zyklenzahl Jahr 2: </span><span class="sc">{</span>zyklenzahl_jahr2<span class="sc">:,.2f}</span><span class="ss">"</span>)</span>
<span id="cb58-34"><a href="#cb58-34" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb58-35"><a href="#cb58-35" aria-hidden="true" tabindex="-1"></a>  <span class="cf">else</span>:</span>
<span id="cb58-36"><a href="#cb58-36" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> zyklenzahl_jahr1, zyklenzahl_jahr2</span>
<span id="cb58-37"><a href="#cb58-37" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb58-38"><a href="#cb58-38" aria-hidden="true" tabindex="-1"></a>zyklenzahl_berechnen(restlast, einspeicherwirkungsgrad <span class="op">=</span> <span class="fl">0.9</span>, ausspeicherwirkungsgrad <span class="op">=</span> <span class="fl">0.9</span>, output <span class="op">=</span> <span class="va">True</span>)</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Zyklenzahl Jahr 1: 8.79
Zyklenzahl Jahr 2: 8.79</code></pre>
</div>
</div>
</div>
</div>
</div>
<p>Aufgrund der geringen erneuerbaren Erzeugungsschüsse im Jahr 2023 ist die Zyklenzahl in Jahr 1 und Jahr 2 identisch. Wenn der Wirkungsgrad berücksichtigt wird, steigt die Zyklenzahl, weil der Speicher kleiner dimensioniert ist.</p>
</section>
</section>
<section id="kappung" class="level3">
<h3 class="anchored" data-anchor-id="kappung">Kappung</h3>
<div>

</div>
<div class="quarto-layout-panel" data-layout="[40, 60]">
<div class="quarto-layout-row">
<div id="833568e9" class="cell quarto-layout-cell" data-execution_count="60" style="flex-basis: 40.0%;justify-content: flex-start;">
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="Energiedatenauswertung_files/figure-html/cell-61-output-1.png" alt="In zwei Grafiken sind zwei vereinfachte, aus je vier Balken bestehende Restlastkurven im Jahresgang dargestellt. Auf der x-Achse sind die 365 Tage des Jahres dargestellt, auf der y-Achse die Restlast von minus 1 bis 1. In der oberen Grafik ist der Jahresgang eines Speicher ohne Kappung von Erzeugungsspitzen dargestellt. Im ersten Vierteljahr ist die Restlast negativ in Höhe von minus 1. Der erste Balken ist eingefärbt und nach links oben aufsteigend schraffiert. Die Färbung zeigt die erforderliche Speichergröße an, die aufsteigende Schraffierung die Phase der Einspeicherung. Im zweiten Vierteljahr ist die Restlast positiv in Höhe von 1, die Ausspeicherung ist durch eine absteigende Schraffierung gekennzeichnet. Es folgen im dritten und vierten Vierteljahr Phasen der Ein- bzw. Ausspeicherung in Höhe von minus bzw. plus 0.5, die entsprechend schraffiert sind. Auf diese Weise werden 1,5 Ein- und Ausspeicherzyklen realisiert. In der unteren Grafik ist der gleiche Jahresgang dargestellt, allerdings wird die Speichergröße auf 0.5 begrenzt. Im ersten Vierteljahr mit einer Restlast in Höhe von -1 werden deshalb nur -0.5 eingespeichert. Dies ist durch eine Einfärbung und aufsteigende Schraffierung des Bereichs zwischen 0 und 0.5 dargestellt. Der Bereich von minus 0.5 bis minus 1 ist ungekennzeichnet weiß. Dieser Überschussstrom wird nicht eingespeichert. Ebenso wird im zweiten Vierteljahr die Restlast in Höhe von 1 nur zur Hälfte aus dem Speicher bedient. Die Restlast im Bereich 0.5 bis 1 muss durch Lastfolgekraftwerke gedeckt werden. Die folgenden Phasen der Ein- bzw. Ausspeicherung im dritten und vierten Vierteljahr entsprechen der Restlast in Höhe von minus bzw. plus 0.5. Der auf 0.5 begrenzte Speicher erreicht dadurch 2 Ein- und Ausspeicherzyklen." width="566" height="470" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<div class="quarto-layout-cell" style="flex-basis: 60.0%;justify-content: flex-start;">
<dl>
<dt>Kappung von Erzeugungsspitzen</dt>
<dd>
Die Kappung von Erzeugungsspitzen ist eine Möglichkeit, die benötigte Speichergröße zu reduzieren. Die Kappung der Einspeicherung führt zu einer besseren Auslastung der Speicherkapazität und einer höheren Zyklenzahl.
</dd>
<dd>
Im oberen Beispiel wird die Speichergröße entsprechend der maximalen erneuerbaren Überschussproduktion ausgelegt. Der Speicher erreicht damit 1,5 Zyklen.
</dd>
<dd>
Im unteren Beispiel wird der Speicher kleiner dimensioniert. Der Speicher erreicht 2 Zyklen.
</dd>
</dl>
</div>
</div>
</div>
<section id="berechnung-2" class="level4">
<h4 class="anchored" data-anchor-id="berechnung-2">Berechnung</h4>
<p>Auf Grundlage des Jahresgangs des Speichers kann der Effekt der Kappung von Erzeugungsspitzen auf die eingespeicherte Strommenge und die erreichte Zyklenzahl des Stromspeichers berechnet werden. Dafür werden der Jahresgang des Speichers für verschiedene reduzierte Speichergrößen, die so erreichte Zyklenzahl und die Menge nicht eingespeicherten Stroms berechnet.</p>
<ul>
<li><p>Eingabe: Der Funktion ist eine Restlastdatenreihe als pd.Series und optional eine Liste reduzierter Speichergrößen, ausgedrückt als relative Bruchteile von 1, zu übergeben. Wird keine Liste übergeben, erfolgt die Berechnung für die relativen Speichergrößen [0.9, 0.8, 0.7, 0.6, 0.5].</p></li>
<li><p>Verarbeitung: Für die Restlast werden durch Aufruf der Funktion jahresgang_speicher_berechnen die ungekappte Speichergröße und Jahresgänge in Jahr 1 und in Jahr 2 berechnet. Anschließend wird durch Aufruf der Funktion zyklenzahl_berechnen die erreichte Zyklenzahl bestimmt. Anhand der Jahresgänge wird die eingespeicherte Strommenge berechnet. Dazu wird mit der Methode <code>pd.Series.diff()</code> elementweise die Differenz jedes Werts zu seinem Vorgänger gebildet (gleitende Differenz). Wie auch bei der Berechnung der Zyklenzahl wird dazu dem Jahresgang in Jahr 1 eine Null vorangestellt, dem Jahresgang in Jahr 2 der letzte Wert aus Jahr 1. Die eingespeicherte Strommenge ist die Summe aller positiven Werte dieser Reihe. Negative Werte bedeuten eine Reduzierung des Ladestands zwischen zwei Zeitpunkten, zeigen also Phasen der Ausspeicherung an. Deshalb werden negative Werte mit der Methode <code>.clip</code> Null gesetzt. Die Anweisung lautet: <code>pd.Series.diff().clip(lower = 0).sum()</code>.<br>
Diese Schritte werden für alle übergebenen Elemente in der Variablen neue_speichergrößen wiederholt. Dazu wird die Speichergröße ohne Kappung mit jeweils einer der relativen Speichergrößen multipliziert und die erreichte Zyklenzahl sowie die eingespeicherte Strommenge berechnet. Aus der Differenz der eingespeicherten Strommenge für jede neue Speichergröße zum Basisjahr wird die gekappte Strommenge bestimmt.</p></li>
<li><p>Ausgabe: Wenn <code>output = False</code>, wird ein DataFrame mit drei Spalten zurückgegeben. Die Spalte mit Index 0 enthält die relative Speichergröße, Die Spalten 1 und 2 die gekappten Strommengen in Jahr 1 und Jahr 2. Wenn’ output = True’ wird dieser DataFrame mit <code>print()</code> ausgegeben. Zusätzlich wird ein fünfspaltiger DataFrame mit den Zwischenergebnissen (inklusive Basisjahr in Zeile 0) mit <code>print()</code> ausgegeben. Dieser enthält in der Spalte mit Index 0 die absolute Speichergröße sowie in den folgenden Spalten die eingespeicherte Strommenge in Jahr 1 (Spalte mit Index 1), die Zyklenzahl in Jahr 1 (Spalte mit Index 2), die eingespeicherte Strommenge in Jahr 2 (Spalte mit Index 3), die Zyklenzahl in Jahr 2 (Spalte mit Index 4).</p></li>
</ul>
<div class="tabset-margin-container"></div><div class="panel-tabset">
<ul class="nav nav-tabs" role="tablist"><li class="nav-item" role="presentation"><a class="nav-link active" id="tabset-13-1-tab" data-bs-toggle="tab" data-bs-target="#tabset-13-1" role="tab" aria-controls="tabset-13-1" aria-selected="true" href="">ohne Wirkungsgrad</a></li><li class="nav-item" role="presentation"><a class="nav-link" id="tabset-13-2-tab" data-bs-toggle="tab" data-bs-target="#tabset-13-2" role="tab" aria-controls="tabset-13-2" aria-selected="false" href="">mit Wirkungsgrad</a></li></ul>
<div class="tab-content">
<div id="tabset-13-1" class="tab-pane active" role="tabpanel" aria-labelledby="tabset-13-1-tab">
<div id="1c1d672c" class="cell" data-execution_count="61">
<div class="sourceCode cell-code" id="cb60"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Kappung berechnen: Wie viel EE wird verworfen, wenn die Speichergröße begrenzt wird?</span></span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a><span class="co">## Eingabe: Restlastkurve data = pd.Series(data, dtype = 'float', neue_speichergrößen = [0.9, 0.8, 0.7, 0.6, 0.5], output = False)</span></span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true" tabindex="-1"></a><span class="co">## Verarbeitung: Für data werden mit der Funktion jahresgang_speicher_berechnen() die Speichergröße und die Jahresgänge Jahr 1 und Jahr 2 ohne zusätzliche Kappung bestimmt</span></span>
<span id="cb60-4"><a href="#cb60-4" aria-hidden="true" tabindex="-1"></a><span class="co">## Verarbeitung: Für data wird mit der Funktion zyklenzahl_berechnen() die Zyklenzahl in Jahr 1 und Jahr 2 ohne zusätzliche Kappung bestimmt</span></span>
<span id="cb60-5"><a href="#cb60-5" aria-hidden="true" tabindex="-1"></a><span class="co">## Verarbeitung: Anhand der Jahresgänge wird die eingespeicherte Strommenge ohne zusätzliche Kappung bestimmt</span></span>
<span id="cb60-6"><a href="#cb60-6" aria-hidden="true" tabindex="-1"></a><span class="co">## Verarbeitung: Die Verarbeitungsschritte werden für alle übergebenen Elemente in der Variablen neue_speichergrößen wiederholt</span></span>
<span id="cb60-7"><a href="#cb60-7" aria-hidden="true" tabindex="-1"></a><span class="co">## Verarbeitung: Die Speichergröße der Basisrestlastkurve data wird dafür mit den in neue_speichergrößen übergebenen Werten multipliziert</span></span>
<span id="cb60-8"><a href="#cb60-8" aria-hidden="true" tabindex="-1"></a><span class="co">## Verarbeitung: Aus der Differenz der eingespeicherten Strommengen für jede neue Speichergröße zum Basisjahr wird die gekappte Strommenge bestimmt</span></span>
<span id="cb60-9"><a href="#cb60-9" aria-hidden="true" tabindex="-1"></a><span class="co">## Ausgabe: Wenn output = False wird ein DataFrame mit drei Spalten zurückgegeben. Die Spalte mit Index 0 enthält die relative Speichergröße, Die Spalten 1 und 2 die gekappten Strommengen in Jahr 1 und Jahr 2.</span></span>
<span id="cb60-10"><a href="#cb60-10" aria-hidden="true" tabindex="-1"></a><span class="co">## Ausgabe: Wenn output = True wird der dreispaltige DataFrame mit print() ausgegeben.</span></span>
<span id="cb60-11"><a href="#cb60-11" aria-hidden="true" tabindex="-1"></a><span class="co">## Ausgabe: Zusätzlich wird ein fünfspaltiger DataFrame mit den Zwischenergebnissen (inklusive Basisjahr) mit print() ausgegeben.</span></span>
<span id="cb60-12"><a href="#cb60-12" aria-hidden="true" tabindex="-1"></a><span class="co">## Ausgabe: (Indexangaben): 0 = absolute Speichergröße, 1 = eingespeicherte Strommenge Jahr 1, 2 = Zyklenzahl Jahr 1, 3 = eingespeicherte Strommenge Jahr 2, 4 = Zyklenzahl Jahr 2</span></span>
<span id="cb60-13"><a href="#cb60-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-14"><a href="#cb60-14" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> effekt_kappung_berechnen(data, neue_speichergrößen <span class="op">=</span> [<span class="fl">0.9</span>, <span class="fl">0.8</span>, <span class="fl">0.7</span>, <span class="fl">0.6</span>, <span class="fl">0.5</span>], output <span class="op">=</span> <span class="va">False</span>):</span>
<span id="cb60-15"><a href="#cb60-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-16"><a href="#cb60-16" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Speichergröße im Basisjahr bestimmen</span></span>
<span id="cb60-17"><a href="#cb60-17" aria-hidden="true" tabindex="-1"></a>  ergebnis <span class="op">=</span> jahresgang_speicher_berechnen(data, speichergröße <span class="op">=</span> <span class="op">-</span><span class="dv">1</span>, output <span class="op">=</span> <span class="va">False</span>)</span>
<span id="cb60-18"><a href="#cb60-18" aria-hidden="true" tabindex="-1"></a>  speichergröße0 <span class="op">=</span> ergebnis[<span class="dv">0</span>]</span>
<span id="cb60-19"><a href="#cb60-19" aria-hidden="true" tabindex="-1"></a>  jahresgang_speicher_jahr1 <span class="op">=</span> ergebnis[<span class="dv">1</span>]</span>
<span id="cb60-20"><a href="#cb60-20" aria-hidden="true" tabindex="-1"></a>  jahresgang_speicher_jahr2 <span class="op">=</span> ergebnis[<span class="dv">2</span>]</span>
<span id="cb60-21"><a href="#cb60-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-22"><a href="#cb60-22" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Zyklenzahl im Basisjahr bestimmen, Tupel übergeben</span></span>
<span id="cb60-23"><a href="#cb60-23" aria-hidden="true" tabindex="-1"></a>  zyklen <span class="op">=</span> zyklenzahl_berechnen(ergebnis, output <span class="op">=</span> <span class="va">False</span>)</span>
<span id="cb60-24"><a href="#cb60-24" aria-hidden="true" tabindex="-1"></a>  zyklen_jahr1 <span class="op">=</span> zyklen[<span class="dv">0</span>]</span>
<span id="cb60-25"><a href="#cb60-25" aria-hidden="true" tabindex="-1"></a>  zyklen_jahr2 <span class="op">=</span> zyklen[<span class="dv">1</span>]</span>
<span id="cb60-26"><a href="#cb60-26" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb60-27"><a href="#cb60-27" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Jahresgang Jahr 1 eine Null voranstellen, Jahresgang Jahr 2 den letzten Wert aus Jahr 1</span></span>
<span id="cb60-28"><a href="#cb60-28" aria-hidden="true" tabindex="-1"></a>  jahresgang_speicher_jahr1 <span class="op">=</span> pd.concat([pd.Series([<span class="dv">0</span>]), jahresgang_speicher_jahr1])</span>
<span id="cb60-29"><a href="#cb60-29" aria-hidden="true" tabindex="-1"></a>  jahresgang_speicher_jahr2 <span class="op">=</span> pd.concat([jahresgang_speicher_jahr1[ <span class="op">-</span> <span class="dv">1</span>: ], jahresgang_speicher_jahr2])</span>
<span id="cb60-30"><a href="#cb60-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-31"><a href="#cb60-31" aria-hidden="true" tabindex="-1"></a>  <span class="co"># eingespeicherte Strommenge im Basisjahr bestimmen</span></span>
<span id="cb60-32"><a href="#cb60-32" aria-hidden="true" tabindex="-1"></a>  einspeicherung_jahr1 <span class="op">=</span> jahresgang_speicher_jahr1.diff().clip(lower <span class="op">=</span> <span class="dv">0</span>).<span class="bu">sum</span>()</span>
<span id="cb60-33"><a href="#cb60-33" aria-hidden="true" tabindex="-1"></a>  einspeicherung_jahr2 <span class="op">=</span> jahresgang_speicher_jahr2.diff().clip(lower <span class="op">=</span> <span class="dv">0</span>).<span class="bu">sum</span>()</span>
<span id="cb60-34"><a href="#cb60-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-35"><a href="#cb60-35" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Ergebnisse in DataFrame speichern</span></span>
<span id="cb60-36"><a href="#cb60-36" aria-hidden="true" tabindex="-1"></a>  dataframe <span class="op">=</span> pd.DataFrame({<span class="st">'Speichergröße'</span>: [speichergröße0], <span class="st">'Einspeicherung Jahr1'</span>: [einspeicherung_jahr1], <span class="st">'Zyklen Jahr1'</span>: zyklen_jahr1, <span class="st">'Einspeicherung Jahr2'</span>: [einspeicherung_jahr2], <span class="st">'Zyklen Jahr2'</span>: zyklen_jahr2})</span>
<span id="cb60-37"><a href="#cb60-37" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb60-38"><a href="#cb60-38" aria-hidden="true" tabindex="-1"></a>  <span class="co"># eingespeicherte Strommenge bei alternativen Speichergrößen bestimmen</span></span>
<span id="cb60-39"><a href="#cb60-39" aria-hidden="true" tabindex="-1"></a>  count <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb60-40"><a href="#cb60-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-41"><a href="#cb60-41" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(neue_speichergrößen)):</span>
<span id="cb60-42"><a href="#cb60-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-43"><a href="#cb60-43" aria-hidden="true" tabindex="-1"></a>    speichergröße_neu <span class="op">=</span> speichergröße0 <span class="op">*</span> neue_speichergrößen[i]</span>
<span id="cb60-44"><a href="#cb60-44" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb60-45"><a href="#cb60-45" aria-hidden="true" tabindex="-1"></a>    ergebnis <span class="op">=</span> jahresgang_speicher_berechnen(data, speichergröße <span class="op">=</span> speichergröße_neu, output <span class="op">=</span> <span class="va">False</span>)</span>
<span id="cb60-46"><a href="#cb60-46" aria-hidden="true" tabindex="-1"></a>    jahresgang_speicher_jahr1 <span class="op">=</span> ergebnis[<span class="dv">1</span>]</span>
<span id="cb60-47"><a href="#cb60-47" aria-hidden="true" tabindex="-1"></a>    jahresgang_speicher_jahr2 <span class="op">=</span> ergebnis[<span class="dv">2</span>]</span>
<span id="cb60-48"><a href="#cb60-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-49"><a href="#cb60-49" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Zyklenzahl im Basisjahr bestimmen, Tupel übergeben</span></span>
<span id="cb60-50"><a href="#cb60-50" aria-hidden="true" tabindex="-1"></a>    zyklen <span class="op">=</span> zyklenzahl_berechnen(ergebnis, output <span class="op">=</span> <span class="va">False</span>)</span>
<span id="cb60-51"><a href="#cb60-51" aria-hidden="true" tabindex="-1"></a>    zyklen_jahr1 <span class="op">=</span> zyklen[<span class="dv">0</span>]</span>
<span id="cb60-52"><a href="#cb60-52" aria-hidden="true" tabindex="-1"></a>    zyklen_jahr2 <span class="op">=</span> zyklen[<span class="dv">1</span>]</span>
<span id="cb60-53"><a href="#cb60-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-54"><a href="#cb60-54" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Jahresgang Jahr 1 eine Null voranstellen, Jahresgang Jahr 2 den letzten Wert aus Jahr 1</span></span>
<span id="cb60-55"><a href="#cb60-55" aria-hidden="true" tabindex="-1"></a>    jahresgang_speicher_jahr1 <span class="op">=</span> pd.concat([pd.Series([<span class="dv">0</span>]), jahresgang_speicher_jahr1])</span>
<span id="cb60-56"><a href="#cb60-56" aria-hidden="true" tabindex="-1"></a>    jahresgang_speicher_jahr2 <span class="op">=</span> pd.concat([jahresgang_speicher_jahr1[ <span class="op">-</span> <span class="dv">1</span>: ], jahresgang_speicher_jahr2])</span>
<span id="cb60-57"><a href="#cb60-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-58"><a href="#cb60-58" aria-hidden="true" tabindex="-1"></a>    <span class="co"># eingespeicherte Strommenge mit neuer Speichergröße bestimmen</span></span>
<span id="cb60-59"><a href="#cb60-59" aria-hidden="true" tabindex="-1"></a>    einspeicherung_jahr1 <span class="op">=</span> jahresgang_speicher_jahr1.diff().clip(lower <span class="op">=</span> <span class="dv">0</span>).<span class="bu">sum</span>()</span>
<span id="cb60-60"><a href="#cb60-60" aria-hidden="true" tabindex="-1"></a>    einspeicherung_jahr2 <span class="op">=</span> jahresgang_speicher_jahr2.diff().clip(lower <span class="op">=</span> <span class="dv">0</span>).<span class="bu">sum</span>()</span>
<span id="cb60-61"><a href="#cb60-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-62"><a href="#cb60-62" aria-hidden="true" tabindex="-1"></a>    neue_Zeile <span class="op">=</span> [speichergröße_neu, einspeicherung_jahr1, zyklen_jahr1, einspeicherung_jahr2, zyklen_jahr2]</span>
<span id="cb60-63"><a href="#cb60-63" aria-hidden="true" tabindex="-1"></a>    dataframe.loc[count] <span class="op">=</span> neue_Zeile</span>
<span id="cb60-64"><a href="#cb60-64" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb60-65"><a href="#cb60-65" aria-hidden="true" tabindex="-1"></a>    count <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb60-66"><a href="#cb60-66" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb60-67"><a href="#cb60-67" aria-hidden="true" tabindex="-1"></a>  <span class="co"># gekappte Menge berechnen data.sub(data[0]).drop(0)</span></span>
<span id="cb60-68"><a href="#cb60-68" aria-hidden="true" tabindex="-1"></a>  gekappte_einspeicherung_jahr1 <span class="op">=</span> dataframe[<span class="st">'Einspeicherung Jahr1'</span>].sub(dataframe[<span class="st">'Einspeicherung Jahr1'</span>][<span class="dv">0</span>]).<span class="bu">abs</span>().drop(<span class="dv">0</span>).reset_index(drop <span class="op">=</span> <span class="va">True</span>)</span>
<span id="cb60-69"><a href="#cb60-69" aria-hidden="true" tabindex="-1"></a>  gekappte_einspeicherung_jahr2 <span class="op">=</span> dataframe[<span class="st">'Einspeicherung Jahr2'</span>].sub(dataframe[<span class="st">'Einspeicherung Jahr2'</span>][<span class="dv">0</span>]).<span class="bu">abs</span>().drop(<span class="dv">0</span>).reset_index(drop <span class="op">=</span> <span class="va">True</span>)</span>
<span id="cb60-70"><a href="#cb60-70" aria-hidden="true" tabindex="-1"></a>  dataset <span class="op">=</span> pd.DataFrame({<span class="st">'relative Speichergröße'</span>: pd.Series(neue_speichergrößen), <span class="st">'gekappte Einspeicherung Jahr1'</span>: gekappte_einspeicherung_jahr1, <span class="st">'gekappte Einspeicherung Jahr2'</span>: gekappte_einspeicherung_jahr2})</span>
<span id="cb60-71"><a href="#cb60-71" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb60-72"><a href="#cb60-72" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> output:</span>
<span id="cb60-73"><a href="#cb60-73" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-74"><a href="#cb60-74" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(dataframe)</span>
<span id="cb60-75"><a href="#cb60-75" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">"</span>)</span>
<span id="cb60-76"><a href="#cb60-76" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(dataset)</span>
<span id="cb60-77"><a href="#cb60-77" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-78"><a href="#cb60-78" aria-hidden="true" tabindex="-1"></a>  <span class="cf">else</span>:</span>
<span id="cb60-79"><a href="#cb60-79" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dataset</span>
<span id="cb60-80"><a href="#cb60-80" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb60-81"><a href="#cb60-81" aria-hidden="true" tabindex="-1"></a>effekt_kappung_berechnen(restlast, output <span class="op">=</span> <span class="va">True</span>)</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>   Speichergröße  Einspeicherung Jahr1  Zyklen Jahr1  Einspeicherung Jahr2  \
0       119667.0              1.00e+06          8.38              1.00e+06   
1       107700.3              9.91e+05          9.20              9.91e+05   
2        95733.6              9.79e+05         10.23              9.79e+05   
3        83766.9              9.63e+05         11.49              9.63e+05   
4        71800.2              9.39e+05         13.07              9.39e+05   
5        59833.5              8.99e+05         15.03              8.99e+05   

   Zyklen Jahr2  
0          8.38  
1          9.20  
2         10.23  
3         11.49  
4         13.07  
5         15.03  


   relative Speichergröße  gekappte Einspeicherung Jahr1  \
0                     0.9                        11966.7   
1                     0.8                        23933.4   
2                     0.7                        40443.7   
3                     0.6                        64377.1   
4                     0.5                       103619.5   

   gekappte Einspeicherung Jahr2  
0                        11966.7  
1                        23933.4  
2                        40443.7  
3                        64377.1  
4                       103619.5  </code></pre>
</div>
</div>
</div>
<div id="tabset-13-2" class="tab-pane" role="tabpanel" aria-labelledby="tabset-13-2-tab">
<div id="3d0af32a" class="cell" data-execution_count="62">
<div class="sourceCode cell-code" id="cb62"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Kappung berechnen: Wie viel EE wird verworfen, wenn die Speichergröße begrenzt wird?</span></span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true" tabindex="-1"></a><span class="co">## Eingabe: Restlastkurve data = pd.Series(data, dtype = 'float', einspeicherwirkungsgrad = 1, ausspeicherwirkungsgrad = 1, neue_speichergrößen = [0.9, 0.8, 0.7, 0.6, 0.5], output = False)</span></span>
<span id="cb62-3"><a href="#cb62-3" aria-hidden="true" tabindex="-1"></a><span class="co">## Verarbeitung: Für data werden mit der Funktion jahresgang_speicher_berechnen() die Speichergröße und die Jahresgänge Jahr 1 und Jahr 2 ohne zusätzliche Kappung bestimmt</span></span>
<span id="cb62-4"><a href="#cb62-4" aria-hidden="true" tabindex="-1"></a><span class="co">## Verarbeitung: Für data wird mit der Funktion zyklenzahl_berechnen() die Zyklenzahl in Jahr 1 und Jahr 2 ohne zusätzliche Kappung bestimmt</span></span>
<span id="cb62-5"><a href="#cb62-5" aria-hidden="true" tabindex="-1"></a><span class="co">## Verarbeitung: Anhand der Jahresgänge wird die eingespeicherte Strommenge ohne zusätzliche Kappung bestimmt</span></span>
<span id="cb62-6"><a href="#cb62-6" aria-hidden="true" tabindex="-1"></a><span class="co">## Verarbeitung: Die Verarbeitungsschritte werden für alle übergebenen Elemente in der Variablen neue_speichergrößen wiederholt</span></span>
<span id="cb62-7"><a href="#cb62-7" aria-hidden="true" tabindex="-1"></a><span class="co">## Verarbeitung: Die Speichergröße der Basisrestlastkurve data wird dafür mit den in neue_speichergrößen übergebenen Werten multipliziert</span></span>
<span id="cb62-8"><a href="#cb62-8" aria-hidden="true" tabindex="-1"></a><span class="co">## Verarbeitung: Aus der Differenz der eingespeicherten Strommengen für jede neue Speichergröße zum Basisjahr wird die gekappte Strommenge bestimmt</span></span>
<span id="cb62-9"><a href="#cb62-9" aria-hidden="true" tabindex="-1"></a><span class="co">## Ausgabe: Wenn output = False wird ein DataFrame mit drei Spalten zurückgegeben. Die Spalte mit Index 0 enthält die relative Speichergröße, Die Spalten 1 und 2 die gekappten Strommengen in Jahr 1 und Jahr 2.</span></span>
<span id="cb62-10"><a href="#cb62-10" aria-hidden="true" tabindex="-1"></a><span class="co">## Ausgabe: Wenn output = True wird der dreispaltige DataFrame mit print() ausgegeben.</span></span>
<span id="cb62-11"><a href="#cb62-11" aria-hidden="true" tabindex="-1"></a><span class="co">## Ausgabe: Zusätzlich wird ein fünfspaltiger DataFrame mit den Zwischenergebnissen (inklusive Basisjahr) mit print() ausgegeben.</span></span>
<span id="cb62-12"><a href="#cb62-12" aria-hidden="true" tabindex="-1"></a><span class="co">## Ausgabe: (Indexangaben): 0 = absolute Speichergröße, 1 = eingespeicherte Strommenge Jahr 1, 2 = Zyklenzahl Jahr 1, 3 = eingespeicherte Strommenge Jahr 2, 4 = Zyklenzahl Jahr 2</span></span>
<span id="cb62-13"><a href="#cb62-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-14"><a href="#cb62-14" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> effekt_kappung_berechnen(data, einspeicherwirkungsgrad <span class="op">=</span> <span class="dv">1</span>, ausspeicherwirkungsgrad <span class="op">=</span> <span class="dv">1</span>, neue_speichergrößen <span class="op">=</span> [<span class="fl">0.9</span>, <span class="fl">0.8</span>, <span class="fl">0.7</span>, <span class="fl">0.6</span>, <span class="fl">0.5</span>], output <span class="op">=</span> <span class="va">False</span>):</span>
<span id="cb62-15"><a href="#cb62-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-16"><a href="#cb62-16" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Speichergröße im Basisjahr bestimmen</span></span>
<span id="cb62-17"><a href="#cb62-17" aria-hidden="true" tabindex="-1"></a>  ergebnis <span class="op">=</span> jahresgang_speicher_berechnen(data, speichergröße <span class="op">=</span> <span class="op">-</span><span class="dv">1</span>, einspeicherwirkungsgrad <span class="op">=</span> einspeicherwirkungsgrad, ausspeicherwirkungsgrad <span class="op">=</span> ausspeicherwirkungsgrad, output <span class="op">=</span> <span class="va">False</span>)</span>
<span id="cb62-18"><a href="#cb62-18" aria-hidden="true" tabindex="-1"></a>  speichergröße0 <span class="op">=</span> ergebnis[<span class="dv">0</span>]</span>
<span id="cb62-19"><a href="#cb62-19" aria-hidden="true" tabindex="-1"></a>  jahresgang_speicher_jahr1 <span class="op">=</span> ergebnis[<span class="dv">1</span>]</span>
<span id="cb62-20"><a href="#cb62-20" aria-hidden="true" tabindex="-1"></a>  jahresgang_speicher_jahr2 <span class="op">=</span> ergebnis[<span class="dv">2</span>]</span>
<span id="cb62-21"><a href="#cb62-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-22"><a href="#cb62-22" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Zyklenzahl im Basisjahr bestimmen, Tupel übergeben</span></span>
<span id="cb62-23"><a href="#cb62-23" aria-hidden="true" tabindex="-1"></a>  zyklen <span class="op">=</span> zyklenzahl_berechnen(ergebnis, einspeicherwirkungsgrad <span class="op">=</span> einspeicherwirkungsgrad, ausspeicherwirkungsgrad <span class="op">=</span> ausspeicherwirkungsgrad, output <span class="op">=</span> <span class="va">False</span>)</span>
<span id="cb62-24"><a href="#cb62-24" aria-hidden="true" tabindex="-1"></a>  zyklen_jahr1 <span class="op">=</span> zyklen[<span class="dv">0</span>]</span>
<span id="cb62-25"><a href="#cb62-25" aria-hidden="true" tabindex="-1"></a>  zyklen_jahr2 <span class="op">=</span> zyklen[<span class="dv">1</span>]</span>
<span id="cb62-26"><a href="#cb62-26" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb62-27"><a href="#cb62-27" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Jahresgang Jahr 1 eine Null voranstellen, Jahresgang Jahr 2 den letzten Wert aus Jahr 1</span></span>
<span id="cb62-28"><a href="#cb62-28" aria-hidden="true" tabindex="-1"></a>  jahresgang_speicher_jahr1 <span class="op">=</span> pd.concat([pd.Series([<span class="dv">0</span>]), jahresgang_speicher_jahr1])</span>
<span id="cb62-29"><a href="#cb62-29" aria-hidden="true" tabindex="-1"></a>  jahresgang_speicher_jahr2 <span class="op">=</span> pd.concat([jahresgang_speicher_jahr1[ <span class="op">-</span> <span class="dv">1</span>: ], jahresgang_speicher_jahr2])</span>
<span id="cb62-30"><a href="#cb62-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-31"><a href="#cb62-31" aria-hidden="true" tabindex="-1"></a>  <span class="co"># eingespeicherte Strommenge im Basisjahr bestimmen</span></span>
<span id="cb62-32"><a href="#cb62-32" aria-hidden="true" tabindex="-1"></a>  einspeicherung_jahr1 <span class="op">=</span> jahresgang_speicher_jahr1.diff().clip(lower <span class="op">=</span> <span class="dv">0</span>).<span class="bu">sum</span>()</span>
<span id="cb62-33"><a href="#cb62-33" aria-hidden="true" tabindex="-1"></a>  einspeicherung_jahr2 <span class="op">=</span> jahresgang_speicher_jahr2.diff().clip(lower <span class="op">=</span> <span class="dv">0</span>).<span class="bu">sum</span>()</span>
<span id="cb62-34"><a href="#cb62-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-35"><a href="#cb62-35" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Ergebnisse in DataFrame speichern</span></span>
<span id="cb62-36"><a href="#cb62-36" aria-hidden="true" tabindex="-1"></a>  dataframe <span class="op">=</span> pd.DataFrame({<span class="st">'Speichergröße'</span>: [speichergröße0], <span class="st">'Einspeicherung Jahr1'</span>: [einspeicherung_jahr1], <span class="st">'Zyklen Jahr1'</span>: zyklen_jahr1, <span class="st">'Einspeicherung Jahr2'</span>: [einspeicherung_jahr2], <span class="st">'Zyklen Jahr2'</span>: zyklen_jahr2})</span>
<span id="cb62-37"><a href="#cb62-37" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb62-38"><a href="#cb62-38" aria-hidden="true" tabindex="-1"></a>  <span class="co"># eingespeicherte Strommenge bei alternativen Speichergrößen bestimmen</span></span>
<span id="cb62-39"><a href="#cb62-39" aria-hidden="true" tabindex="-1"></a>  count <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb62-40"><a href="#cb62-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-41"><a href="#cb62-41" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(neue_speichergrößen)):</span>
<span id="cb62-42"><a href="#cb62-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-43"><a href="#cb62-43" aria-hidden="true" tabindex="-1"></a>    speichergröße_neu <span class="op">=</span> speichergröße0 <span class="op">*</span> neue_speichergrößen[i]</span>
<span id="cb62-44"><a href="#cb62-44" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb62-45"><a href="#cb62-45" aria-hidden="true" tabindex="-1"></a>    ergebnis <span class="op">=</span> jahresgang_speicher_berechnen(data, speichergröße <span class="op">=</span> speichergröße_neu, einspeicherwirkungsgrad <span class="op">=</span> einspeicherwirkungsgrad, ausspeicherwirkungsgrad <span class="op">=</span> ausspeicherwirkungsgrad, output <span class="op">=</span> <span class="va">False</span>)</span>
<span id="cb62-46"><a href="#cb62-46" aria-hidden="true" tabindex="-1"></a>    jahresgang_speicher_jahr1 <span class="op">=</span> ergebnis[<span class="dv">1</span>]</span>
<span id="cb62-47"><a href="#cb62-47" aria-hidden="true" tabindex="-1"></a>    jahresgang_speicher_jahr2 <span class="op">=</span> ergebnis[<span class="dv">2</span>]</span>
<span id="cb62-48"><a href="#cb62-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-49"><a href="#cb62-49" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Zyklenzahl im Basisjahr bestimmen, Tupel übergeben</span></span>
<span id="cb62-50"><a href="#cb62-50" aria-hidden="true" tabindex="-1"></a>    zyklen <span class="op">=</span> zyklenzahl_berechnen(ergebnis, einspeicherwirkungsgrad <span class="op">=</span> einspeicherwirkungsgrad, ausspeicherwirkungsgrad <span class="op">=</span> ausspeicherwirkungsgrad, output <span class="op">=</span> <span class="va">False</span>)</span>
<span id="cb62-51"><a href="#cb62-51" aria-hidden="true" tabindex="-1"></a>    zyklen_jahr1 <span class="op">=</span> zyklen[<span class="dv">0</span>]</span>
<span id="cb62-52"><a href="#cb62-52" aria-hidden="true" tabindex="-1"></a>    zyklen_jahr2 <span class="op">=</span> zyklen[<span class="dv">1</span>]</span>
<span id="cb62-53"><a href="#cb62-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-54"><a href="#cb62-54" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Jahresgang Jahr 1 eine Null voranstellen, Jahresgang Jahr 2 den letzten Wert aus Jahr 1</span></span>
<span id="cb62-55"><a href="#cb62-55" aria-hidden="true" tabindex="-1"></a>    jahresgang_speicher_jahr1 <span class="op">=</span> pd.concat([pd.Series([<span class="dv">0</span>]), jahresgang_speicher_jahr1])</span>
<span id="cb62-56"><a href="#cb62-56" aria-hidden="true" tabindex="-1"></a>    jahresgang_speicher_jahr2 <span class="op">=</span> pd.concat([jahresgang_speicher_jahr1[ <span class="op">-</span> <span class="dv">1</span>: ], jahresgang_speicher_jahr2])</span>
<span id="cb62-57"><a href="#cb62-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-58"><a href="#cb62-58" aria-hidden="true" tabindex="-1"></a>    <span class="co"># eingespeicherte Strommenge mit neuer Speichergröße bestimmen</span></span>
<span id="cb62-59"><a href="#cb62-59" aria-hidden="true" tabindex="-1"></a>    einspeicherung_jahr1 <span class="op">=</span> jahresgang_speicher_jahr1.diff().clip(lower <span class="op">=</span> <span class="dv">0</span>).<span class="bu">sum</span>()</span>
<span id="cb62-60"><a href="#cb62-60" aria-hidden="true" tabindex="-1"></a>    einspeicherung_jahr2 <span class="op">=</span> jahresgang_speicher_jahr2.diff().clip(lower <span class="op">=</span> <span class="dv">0</span>).<span class="bu">sum</span>()</span>
<span id="cb62-61"><a href="#cb62-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-62"><a href="#cb62-62" aria-hidden="true" tabindex="-1"></a>    neue_Zeile <span class="op">=</span> [speichergröße_neu, einspeicherung_jahr1, zyklen_jahr1, einspeicherung_jahr2, zyklen_jahr2]</span>
<span id="cb62-63"><a href="#cb62-63" aria-hidden="true" tabindex="-1"></a>    dataframe.loc[count] <span class="op">=</span> neue_Zeile</span>
<span id="cb62-64"><a href="#cb62-64" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb62-65"><a href="#cb62-65" aria-hidden="true" tabindex="-1"></a>    count <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb62-66"><a href="#cb62-66" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb62-67"><a href="#cb62-67" aria-hidden="true" tabindex="-1"></a>  <span class="co"># gekappte Menge berechnen data.sub(data[0]).drop(0)</span></span>
<span id="cb62-68"><a href="#cb62-68" aria-hidden="true" tabindex="-1"></a>  gekappte_einspeicherung_jahr1 <span class="op">=</span> dataframe[<span class="st">'Einspeicherung Jahr1'</span>].sub(dataframe[<span class="st">'Einspeicherung Jahr1'</span>][<span class="dv">0</span>]).<span class="bu">abs</span>().drop(<span class="dv">0</span>).reset_index(drop <span class="op">=</span> <span class="va">True</span>)</span>
<span id="cb62-69"><a href="#cb62-69" aria-hidden="true" tabindex="-1"></a>  gekappte_einspeicherung_jahr2 <span class="op">=</span> dataframe[<span class="st">'Einspeicherung Jahr2'</span>].sub(dataframe[<span class="st">'Einspeicherung Jahr2'</span>][<span class="dv">0</span>]).<span class="bu">abs</span>().drop(<span class="dv">0</span>).reset_index(drop <span class="op">=</span> <span class="va">True</span>)</span>
<span id="cb62-70"><a href="#cb62-70" aria-hidden="true" tabindex="-1"></a>  dataset <span class="op">=</span> pd.DataFrame({<span class="st">'relative Speichergröße'</span>: pd.Series(neue_speichergrößen), <span class="st">'gekappte Einspeicherung Jahr1'</span>: gekappte_einspeicherung_jahr1, <span class="st">'gekappte Einspeicherung Jahr2'</span>: gekappte_einspeicherung_jahr2})</span>
<span id="cb62-71"><a href="#cb62-71" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb62-72"><a href="#cb62-72" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> output:</span>
<span id="cb62-73"><a href="#cb62-73" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-74"><a href="#cb62-74" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(dataframe)</span>
<span id="cb62-75"><a href="#cb62-75" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">"</span>)</span>
<span id="cb62-76"><a href="#cb62-76" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(dataset)</span>
<span id="cb62-77"><a href="#cb62-77" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-78"><a href="#cb62-78" aria-hidden="true" tabindex="-1"></a>  <span class="cf">else</span>:</span>
<span id="cb62-79"><a href="#cb62-79" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dataset</span>
<span id="cb62-80"><a href="#cb62-80" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-81"><a href="#cb62-81" aria-hidden="true" tabindex="-1"></a>effekt_kappung_berechnen(restlast, einspeicherwirkungsgrad <span class="op">=</span> <span class="fl">0.9</span>, ausspeicherwirkungsgrad <span class="op">=</span> <span class="fl">0.9</span>, output <span class="op">=</span> <span class="va">True</span>)</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>   Speichergröße  Einspeicherung Jahr1  Zyklen Jahr1  Einspeicherung Jahr2  \
0      102674.54             902678.40          8.79             902678.40   
1       92407.08             892410.95          9.66             892410.95   
2       82139.63             882143.49         10.74             882143.49   
3       71872.18             864601.21         12.03             864601.21   
4       61604.72             844066.30         13.70             844066.30   
5       51337.27             799701.77         15.58             799701.77   

   Zyklen Jahr2  
0          8.79  
1          9.66  
2         10.74  
3         12.03  
4         13.70  
5         15.58  


   relative Speichergröße  gekappte Einspeicherung Jahr1  \
0                     0.9                       10267.45   
1                     0.8                       20534.91   
2                     0.7                       38077.19   
3                     0.6                       58612.10   
4                     0.5                      102976.63   

   gekappte Einspeicherung Jahr2  
0                       10267.45  
1                       20534.91  
2                       38077.19  
3                       58612.10  
4                      102976.63  </code></pre>
</div>
</div>
</div>
</div>
</div>
</section>
</section>
</section>
<section id="anteil-erneuerbarer-stromerzeugung-bestimmen" class="level2" data-number="8.4">
<h2 data-number="8.4" class="anchored" data-anchor-id="anteil-erneuerbarer-stromerzeugung-bestimmen"><span class="header-section-number">8.4</span> Anteil erneuerbarer Stromerzeugung bestimmen</h2>
<p>Durch die Integration eines Stromspeichers in das Stromsystem kann erneuerbare Überschussproduktion in Phasen mit einer positiven Restlast verschoben werden, die andernfalls durch Lastfolgekraftwerke zu decken wäre. Dadurch sinkt der Anteil konventioneller Stromerzeugung und steigt der Anteil erneuerbarer Stromerzeugung.</p>
<div>

</div>
<div class="quarto-layout-panel" data-layout="[40, 60]">
<div class="quarto-layout-row">
<div id="70cc64dd" class="cell quarto-layout-cell" data-execution_count="63" style="flex-basis: 40.0%;justify-content: flex-start;">
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="Energiedatenauswertung_files/figure-html/cell-64-output-1.png" alt="In zwei Grafiken ist eine vereinfachte, aus zwei Balken bestehende Restlastkurve im Jahresgang bei einem Defizit erneuerbarer Energieerzeugung dargestellt. Auf der x-Achse sind die 365 Tage des Jahres dargestellt, auf der y-Achse die Restlast von minus 1 bis 1. In der ersten Jahreshälfte ist die Restlast negativ in Höhe von minus 0.5, in der zweiten Jahreshälfte positiv in Höhe von 1. Dies ist durch jeweils einen Balken in entsprechender Höhe dargestellt. Der erste Balken mit den negativen Werten ist eingefärbt und nach links oben aufsteigend schraffiert. Die Färbung zeigt die erforderliche Speichergröße an, die aufsteigende Schraffierung die Phase der Einspeicherung. Der zweite Balken mit den positiven Werten ist bis zur halben Höhe 0.5 nach rechts unten absteigend schraffiert - dies zeigt die Phase der Ausspeicherung an. Der Bereich von 0.5 bis 1 ist unausgefüllt - dieser entspricht der durch Lastfolgekraftwerke zu bedienenden Restlast." width="516" height="431" class="figure-img"></p>
</figure>
</div>
</div>
</div>
<div class="quarto-layout-cell" style="flex-basis: 60.0%;justify-content: flex-start;">
<dl>
<dt>Anteil erneuerbarer Stromproduktion bestimmen</dt>
<dd>
Die Ausspeicherung von Strom vermindert die positive Restlast
</dd>
<dd>
Wird der ausgespeicherte Strom von der positiven Restlast abgezogen (in Summe oder im Jahresgang), entspricht der Anteil konventionell zu deckender Last dem Quotienten aus der summierten positiven Restlast und der summierten Netzlast bzw. aus der summierten positiven Restlast und der summierten Stromerzeugung.
</dd>
<dd>
Der Anteil erneuerbarer Stromproduktion entspricht 1 - Anteil konventionell zu deckender Last.
</dd>
</dl>
</div>
</div>
</div>
<p>Der Anteil erneuerbarer Stromproduktion kann deshalb wie folgt berechnet werden:</p>
<div id="fa5b22bd" class="cell" data-execution_count="64">
<div class="sourceCode cell-code" id="cb64"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a>restlast.clip(lower <span class="op">=</span> <span class="dv">0</span>).<span class="bu">sum</span>() <span class="op">/</span> verbrauch[<span class="st">'Gesamt (Netzlast) [MWh]'</span>].<span class="bu">sum</span>()</span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-3"><a href="#cb64-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Summe positive Restlast [MWh]: </span><span class="sc">{</span>restlast<span class="sc">.</span>clip(lower <span class="op">=</span> <span class="dv">0</span>)<span class="sc">.</span><span class="bu">sum</span>()<span class="sc">}</span><span class="ch">\n</span><span class="ss">"</span></span>
<span id="cb64-4"><a href="#cb64-4" aria-hidden="true" tabindex="-1"></a>      <span class="ss">f"Summe Netzlast: </span><span class="sc">{</span>verbrauch[<span class="st">'Gesamt (Netzlast) [MWh]'</span>]<span class="sc">.</span><span class="bu">sum</span>()<span class="sc">}</span><span class="ch">\n</span><span class="ss">"</span></span>
<span id="cb64-5"><a href="#cb64-5" aria-hidden="true" tabindex="-1"></a>      <span class="ss">f"Quotient positive Restlast / Netzlast: </span><span class="sc">{</span>restlast<span class="sc">.</span>clip(lower <span class="op">=</span> <span class="dv">0</span>)<span class="sc">.</span><span class="bu">sum</span>() <span class="op">/</span> verbrauch[<span class="st">'Gesamt (Netzlast) [MWh]'</span>]<span class="sc">.</span><span class="bu">sum</span>()<span class="sc">:,.2f}</span><span class="ch">\n</span><span class="ss">"</span></span>
<span id="cb64-6"><a href="#cb64-6" aria-hidden="true" tabindex="-1"></a>      <span class="ss">f"Anteil erneuerbarer Erzeugung: </span><span class="sc">{</span> ( anteil_ee <span class="op">:=</span> <span class="dv">1</span> <span class="op">-</span> (restlast.clip(lower <span class="op">=</span> <span class="dv">0</span>).<span class="bu">sum</span>() <span class="op">/</span> verbrauch[<span class="st">'Gesamt (Netzlast) [MWh]'</span>].<span class="bu">sum</span>()) ) <span class="sc">:,.2f}</span><span class="ch">\n\n</span><span class="ss">"</span></span>
<span id="cb64-7"><a href="#cb64-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-8"><a href="#cb64-8" aria-hidden="true" tabindex="-1"></a>      <span class="ss">f"Summe Erzeugung: </span><span class="sc">{</span>erzeugung<span class="sc">.</span><span class="bu">sum</span>(numeric_only <span class="op">=</span> <span class="va">True</span>)<span class="sc">.</span><span class="bu">sum</span>()<span class="sc">}</span><span class="ch">\n</span><span class="ss">"</span></span>
<span id="cb64-9"><a href="#cb64-9" aria-hidden="true" tabindex="-1"></a>      <span class="ss">f"Quotient positive Restlast / Erzeugung: </span><span class="sc">{</span>restlast<span class="sc">.</span>clip(lower <span class="op">=</span> <span class="dv">0</span>)<span class="sc">.</span><span class="bu">sum</span>() <span class="op">/</span> erzeugung<span class="sc">.</span><span class="bu">sum</span>(numeric_only <span class="op">=</span> <span class="va">True</span>)<span class="sc">.</span><span class="bu">sum</span>()<span class="sc">:,.2f}</span><span class="ch">\n</span><span class="ss">"</span></span>
<span id="cb64-10"><a href="#cb64-10" aria-hidden="true" tabindex="-1"></a>      <span class="ss">f"Anteil erneuerbarer Erzeugung: </span><span class="sc">{</span><span class="dv">1</span> <span class="op">-</span> (restlast.clip(lower <span class="op">=</span> <span class="dv">0</span>).<span class="bu">sum</span>() <span class="op">/</span> erzeugung.<span class="bu">sum</span>(numeric_only <span class="op">=</span> <span class="va">True</span>).<span class="bu">sum</span>())<span class="sc">:,.2f}</span><span class="ss">"</span>)</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Summe positive Restlast [MWh]: 207842228.25
Summe Netzlast: 458271100.75
Quotient positive Restlast / Netzlast: 0.45
Anteil erneuerbarer Erzeugung: 0.55

Summe Erzeugung: 448650448.25
Quotient positive Restlast / Erzeugung: 0.46
Anteil erneuerbarer Erzeugung: 0.54</code></pre>
</div>
</div>
<p>Die Netzlast aus dem Datensatz verbrauch weicht mit 458 TWh geringfügig von der summierten Stromerzeugung aus dem Datensatz erzeugung in Höhe von 448 TWh ab. Dadurch unterscheiden sich die berechneten Anteile leicht.</p>
<section id="berechnung-3" class="level4">
<h4 class="anchored" data-anchor-id="berechnung-3">Berechnung</h4>
<p>Grundlage für die Berechnung des Anteils erneuerbarer Stromerzeugung nach Ausspeicherung erneuerbarer Überschussproduktion ist der Jahresgang des Speichers. Die Ausspeicherung von Strom bedeutet eine Verminderung des Ladestands zwischen zwei Zeitpunkten. Der ausgespeicherte Strom vermindert die positive Restlast zu diesem Zeitpunkt. Dadurch nimmt der Quotient aus der positiven Restlast und der Netzlast ab und der Anteil erneuerbarer Stromerzeugung steigt. Dies ist in der folgenden Funktion umgesetzt.</p>
<ul>
<li><p>Eingabe: Der Funktion wird eine Restlastdatenreihe übergeben. Optional kann zusätzlich eine Netzlastdatenreihe übergeben werden. Ebenso kann optional eine Liste reduzierter Speichergrößen, ausgedrückt als relative Bruchteile von 1, übergeben werden. Wird keine Liste übergeben, erfolgt die Berechnung für die relativen Speichergrößen [0.9, 0.8, 0.7, 0.6, 0.5].</p></li>
<li><p>Verarbeitung: Durch Aufruf der Funktion jahresgang_speicher_berechnen() werden für die Restlastdatenreihe die Jahresgänge des Stromspeichers mit relativer Größe 1 berechnet. Mit den Jahresgängen wird die ausgespeicherte Strommenge im Jahresgang mit der Methode <code>pd.Series.diff().clip(upper = 0)</code> bestimmt. Auch für diese gleitende Differenzberechnung wird dem Jahresgang in Jahr 1 eine Null vorangestellt, dem Jahresgang in Jahr 2 der letzte Wert aus Jahr 1. Der erste Wert im Jahresgang der ausgespeicherten Strommenge ist NaN, weshalb dieser Wert entfällt und der Index zurückgesetzt wird. Der vollständige Befehl lautet: <code>pd.Series.diff().clip(upper = 0)[1: ].reset_index(drop = True)</code>. Die Jahresgang der ausgespeicherten Strommenge wird von der Restlastkurve abgezogen und so die Restlastkurve nach Ausspeicherung bestimmt. Da die Ausspeicherung im Jahresgang durch negative Werte angezeigt wird, erfolgt die Differenzbildung durch Addition.<br>
Wenn eine Netzlastdatenreihe übergeben wurde, wird auf der Grundlage der Restlastkurve nach Ausspeicherung der realisierte Anteil erneuerbarer Erzeugung berechnet: 1 - (Summe positive Restlast / Summe Netzlast). Die Berechnungen werden für kleiner dimensionerte Speicher wiederholt.</p></li>
<li><p>Ausgabe: Wenn <code>output = False</code>, werden die Restlastkurven nach Ausspeicherung als DataFrame zurückgeben. Der DataFrame besteht aus je einer Spalte für die relative Speichergröße 1 sowie für alle übergebenen relativ reduzierten Speichergrößen. Die Restlastkurven in Jahr 1 und Jahr 2 sind in Zeile 0 bzw. 1 gespeichert. Wenn <code>output = True</code>, werden die summierte Netzlast, die summierte positive &amp; negative Restlast, der Anteil erneuerbarer Erzeugung ohne Speicher sowie der realisierter Anteil erneuerbarer Erzeugung mit der Speichergröße im Basisjahr und für alle übergebenen Speichergrößen jeweils für Jahr 1 und Jahr2 mittels print() ausgegeben.</p></li>
</ul>
<div class="tabset-margin-container"></div><div class="panel-tabset">
<ul class="nav nav-tabs" role="tablist"><li class="nav-item" role="presentation"><a class="nav-link active" id="tabset-14-1-tab" data-bs-toggle="tab" data-bs-target="#tabset-14-1" role="tab" aria-controls="tabset-14-1" aria-selected="true" href="">ohne Wirkungsgrad</a></li><li class="nav-item" role="presentation"><a class="nav-link" id="tabset-14-2-tab" data-bs-toggle="tab" data-bs-target="#tabset-14-2" role="tab" aria-controls="tabset-14-2" aria-selected="false" href="">mit Wirkungsgrad</a></li></ul>
<div class="tab-content">
<div id="tabset-14-1" class="tab-pane active" role="tabpanel" aria-labelledby="tabset-14-1-tab">
<div id="47f14f79" class="cell" data-execution_count="65">
<div class="sourceCode cell-code" id="cb66"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a><span class="co"># 6. Anteil EE berechnen</span></span>
<span id="cb66-2"><a href="#cb66-2" aria-hidden="true" tabindex="-1"></a><span class="co">## Eingabe: data = pd.Series(data, dtype = 'float'), netzlast = -1, neue_speichergrößen = [0.9, 0.8, 0.7, 0.6, 0.5], output = False</span></span>
<span id="cb66-3"><a href="#cb66-3" aria-hidden="true" tabindex="-1"></a><span class="co">## Verarbeitung: Aufruf der Funktion jahresgang_speicher_berechnen(data) zur Bestimmung von Speichergröße und Jahrsgang des Speichers in Jahr 1 und Jahr 2</span></span>
<span id="cb66-4"><a href="#cb66-4" aria-hidden="true" tabindex="-1"></a><span class="co">## Verarbeitung: Im Jahresgang des Stromspeichers wird die ausgespeicherte Strommenge bestimmt, diese wird von der Restlast abgezogen --&gt; neue Restlastkurve nach Ausspeicherung</span></span>
<span id="cb66-5"><a href="#cb66-5" aria-hidden="true" tabindex="-1"></a><span class="co">## Verarbeitung: Wenn netzlast = pd.Series(netzlast, dtype = 'float') übergeben wurde, wird anhand der Restlastkurve nach Ausspeicherung der Anteil erneuerbarer Energie bestimmt</span></span>
<span id="cb66-6"><a href="#cb66-6" aria-hidden="true" tabindex="-1"></a><span class="co">## Verarbeitung: Die Berechnungen werden für kleiner dimensionerte Speicher wiederholt, default = [0.9, 0.8, 0.7, 0.6, 0.5]</span></span>
<span id="cb66-7"><a href="#cb66-7" aria-hidden="true" tabindex="-1"></a><span class="co">## Ausgabe: output = False Restlastkurve wird zurückgeben</span></span>
<span id="cb66-8"><a href="#cb66-8" aria-hidden="true" tabindex="-1"></a><span class="co">## Ausgabe: output = True, Ausgabe Summe Netzlast, positive / negative Restlast, Anteil EE ohne Speicher sowie realisierter Anteil EE für Speichergröße Basisjahr und neue_speichergrößen jeweils für Jahr 1 und Jahr2 mittels print()</span></span>
<span id="cb66-9"><a href="#cb66-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-10"><a href="#cb66-10" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> anteil_ee_berechnen(data, netzlast <span class="op">=</span> <span class="op">-</span><span class="dv">1</span>, neue_speichergrößen <span class="op">=</span> [<span class="fl">0.9</span>, <span class="fl">0.8</span>, <span class="fl">0.7</span>, <span class="fl">0.6</span>, <span class="fl">0.5</span>], output <span class="op">=</span> <span class="va">False</span>):</span>
<span id="cb66-11"><a href="#cb66-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-12"><a href="#cb66-12" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Jahresgang im Basisjahr bestimmen</span></span>
<span id="cb66-13"><a href="#cb66-13" aria-hidden="true" tabindex="-1"></a>  ergebnis <span class="op">=</span> jahresgang_speicher_berechnen(data, speichergröße <span class="op">=</span> <span class="op">-</span><span class="dv">1</span>, output <span class="op">=</span> <span class="va">False</span>)</span>
<span id="cb66-14"><a href="#cb66-14" aria-hidden="true" tabindex="-1"></a>  speichergröße0 <span class="op">=</span> ergebnis[<span class="dv">0</span>]</span>
<span id="cb66-15"><a href="#cb66-15" aria-hidden="true" tabindex="-1"></a>  jahresgang_speicher_jahr1 <span class="op">=</span> ergebnis[<span class="dv">1</span>]</span>
<span id="cb66-16"><a href="#cb66-16" aria-hidden="true" tabindex="-1"></a>  jahresgang_speicher_jahr2 <span class="op">=</span> ergebnis[<span class="dv">2</span>]</span>
<span id="cb66-17"><a href="#cb66-17" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb66-18"><a href="#cb66-18" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Jahresgang Jahr 1 eine Null voranstellen, Jahresgang Jahr 2 den letzten Wert aus Jahr 1</span></span>
<span id="cb66-19"><a href="#cb66-19" aria-hidden="true" tabindex="-1"></a>  jahresgang_speicher_jahr1 <span class="op">=</span> pd.concat([pd.Series([<span class="dv">0</span>]), jahresgang_speicher_jahr1])</span>
<span id="cb66-20"><a href="#cb66-20" aria-hidden="true" tabindex="-1"></a>  jahresgang_speicher_jahr2 <span class="op">=</span> pd.concat([jahresgang_speicher_jahr1[ <span class="op">-</span> <span class="dv">1</span>: ], jahresgang_speicher_jahr2])</span>
<span id="cb66-21"><a href="#cb66-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-22"><a href="#cb66-22" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Jahresgang der ausgespeicherten Strommenge, erster Wert ist NaN und entfällt</span></span>
<span id="cb66-23"><a href="#cb66-23" aria-hidden="true" tabindex="-1"></a>  ausspeicherung_jahr1 <span class="op">=</span> jahresgang_speicher_jahr1.diff().clip(upper <span class="op">=</span> <span class="dv">0</span>)[<span class="dv">1</span>: ].reset_index(drop <span class="op">=</span> <span class="va">True</span>)</span>
<span id="cb66-24"><a href="#cb66-24" aria-hidden="true" tabindex="-1"></a>  ausspeicherung_jahr2 <span class="op">=</span> jahresgang_speicher_jahr2.diff().clip(upper <span class="op">=</span> <span class="dv">0</span>)[<span class="dv">1</span>: ].reset_index(drop <span class="op">=</span> <span class="va">True</span>)</span>
<span id="cb66-25"><a href="#cb66-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-26"><a href="#cb66-26" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Restlast nach Ausspeicherung berechnen, Werte in ausspeicherung_jahr1 und ausspeicherung_jahr2 sind negativ</span></span>
<span id="cb66-27"><a href="#cb66-27" aria-hidden="true" tabindex="-1"></a>  restlast_jahr1 <span class="op">=</span> data <span class="op">+</span> ausspeicherung_jahr1</span>
<span id="cb66-28"><a href="#cb66-28" aria-hidden="true" tabindex="-1"></a>  restlast_jahr2 <span class="op">=</span> data <span class="op">+</span> ausspeicherung_jahr2</span>
<span id="cb66-29"><a href="#cb66-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-30"><a href="#cb66-30" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Restlast in DataFrame speichern</span></span>
<span id="cb66-31"><a href="#cb66-31" aria-hidden="true" tabindex="-1"></a>  restlast_nach_ausspeichern <span class="op">=</span> pd.DataFrame({<span class="st">'Speichergröße 1'</span>: [ <span class="bu">list</span>(restlast_jahr1), <span class="bu">list</span>(restlast_jahr2) ]})</span>
<span id="cb66-32"><a href="#cb66-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-33"><a href="#cb66-33" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="bu">type</span>(netzlast) <span class="kw">is</span> <span class="bu">int</span>: <span class="co"># Anteil EE kann nicht ermittelt werden</span></span>
<span id="cb66-34"><a href="#cb66-34" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> output:</span>
<span id="cb66-35"><a href="#cb66-35" aria-hidden="true" tabindex="-1"></a>      <span class="bu">print</span>(<span class="st">"Netzlast wurde nicht übergeben. Anteil erneuerbarer Energien kann nicht ermittelt werden."</span>)</span>
<span id="cb66-36"><a href="#cb66-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-37"><a href="#cb66-37" aria-hidden="true" tabindex="-1"></a>    output <span class="op">=</span> <span class="va">False</span></span>
<span id="cb66-38"><a href="#cb66-38" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb66-39"><a href="#cb66-39" aria-hidden="true" tabindex="-1"></a>  <span class="cf">else</span>: <span class="co"># Anteil EE berechnen</span></span>
<span id="cb66-40"><a href="#cb66-40" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb66-41"><a href="#cb66-41" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Anteil Anteil EE berechnen = 1 - Summe positive Restlast / Summe Netzlast </span></span>
<span id="cb66-42"><a href="#cb66-42" aria-hidden="true" tabindex="-1"></a>    <span class="co">## Jahr1</span></span>
<span id="cb66-43"><a href="#cb66-43" aria-hidden="true" tabindex="-1"></a>    anteil_ee_jahr1 <span class="op">=</span> <span class="dv">1</span> <span class="op">-</span> (restlast_jahr1.clip(lower <span class="op">=</span> <span class="dv">0</span>).<span class="bu">sum</span>() <span class="op">/</span> netzlast.<span class="bu">sum</span>() )</span>
<span id="cb66-44"><a href="#cb66-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-45"><a href="#cb66-45" aria-hidden="true" tabindex="-1"></a>    <span class="co">## Jahr2</span></span>
<span id="cb66-46"><a href="#cb66-46" aria-hidden="true" tabindex="-1"></a>    anteil_ee_jahr2 <span class="op">=</span> <span class="dv">1</span> <span class="op">-</span> (restlast_jahr2.clip(lower <span class="op">=</span> <span class="dv">0</span>).<span class="bu">sum</span>() <span class="op">/</span> netzlast.<span class="bu">sum</span>() )</span>
<span id="cb66-47"><a href="#cb66-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-48"><a href="#cb66-48" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Anteil EE in DataFrame speichern</span></span>
<span id="cb66-49"><a href="#cb66-49" aria-hidden="true" tabindex="-1"></a>    dataframe_anteil_ee <span class="op">=</span> pd.DataFrame({<span class="st">'relative Speichergröße'</span>: pd.concat([ pd.Series([<span class="dv">1</span>]), pd.Series(neue_speichergrößen) ], ignore_index <span class="op">=</span> <span class="va">True</span>), <span class="st">'Anteil EE Jahr1'</span>: pd.Series([ anteil_ee_jahr1 ] ), <span class="st">'Anteil EE Jahr2'</span>: pd.Series([ anteil_ee_jahr2 ])})</span>
<span id="cb66-50"><a href="#cb66-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-51"><a href="#cb66-51" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Jahresgang der ausgespeicherten Strommenge und Anteil EE bei alternativen Speichergrößen berechnen</span></span>
<span id="cb66-52"><a href="#cb66-52" aria-hidden="true" tabindex="-1"></a>  count <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb66-53"><a href="#cb66-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-54"><a href="#cb66-54" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(neue_speichergrößen)):</span>
<span id="cb66-55"><a href="#cb66-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-56"><a href="#cb66-56" aria-hidden="true" tabindex="-1"></a>    speichergröße_neu <span class="op">=</span> speichergröße0 <span class="op">*</span> neue_speichergrößen[i]</span>
<span id="cb66-57"><a href="#cb66-57" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb66-58"><a href="#cb66-58" aria-hidden="true" tabindex="-1"></a>    ergebnis <span class="op">=</span> jahresgang_speicher_berechnen(data, speichergröße <span class="op">=</span> speichergröße_neu, output <span class="op">=</span> <span class="va">False</span>)</span>
<span id="cb66-59"><a href="#cb66-59" aria-hidden="true" tabindex="-1"></a>    jahresgang_speicher_jahr1 <span class="op">=</span> ergebnis[<span class="dv">1</span>]</span>
<span id="cb66-60"><a href="#cb66-60" aria-hidden="true" tabindex="-1"></a>    jahresgang_speicher_jahr2 <span class="op">=</span> ergebnis[<span class="dv">2</span>]</span>
<span id="cb66-61"><a href="#cb66-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-62"><a href="#cb66-62" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Jahresgang Jahr 1 eine Null voranstellen, Jahresgang Jahr 2 den letzten Wert aus Jahr 1</span></span>
<span id="cb66-63"><a href="#cb66-63" aria-hidden="true" tabindex="-1"></a>    jahresgang_speicher_jahr1 <span class="op">=</span> pd.concat([pd.Series([<span class="dv">0</span>]), jahresgang_speicher_jahr1])</span>
<span id="cb66-64"><a href="#cb66-64" aria-hidden="true" tabindex="-1"></a>    jahresgang_speicher_jahr2 <span class="op">=</span> pd.concat([jahresgang_speicher_jahr1[ <span class="op">-</span> <span class="dv">1</span>: ], jahresgang_speicher_jahr2])</span>
<span id="cb66-65"><a href="#cb66-65" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-66"><a href="#cb66-66" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Jahresgang der ausgespeicherten Strommenge, erster Wert ist NaN und entfällt</span></span>
<span id="cb66-67"><a href="#cb66-67" aria-hidden="true" tabindex="-1"></a>    ausspeicherung_jahr1 <span class="op">=</span> jahresgang_speicher_jahr1.diff().clip(upper <span class="op">=</span> <span class="dv">0</span>)[<span class="dv">1</span>: ].reset_index(drop <span class="op">=</span> <span class="va">True</span>)</span>
<span id="cb66-68"><a href="#cb66-68" aria-hidden="true" tabindex="-1"></a>    ausspeicherung_jahr2 <span class="op">=</span> jahresgang_speicher_jahr2.diff().clip(upper <span class="op">=</span> <span class="dv">0</span>)[<span class="dv">1</span>: ].reset_index(drop <span class="op">=</span> <span class="va">True</span>)</span>
<span id="cb66-69"><a href="#cb66-69" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-70"><a href="#cb66-70" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Restlast nach Ausspeicherung berechnen, Werte in ausspeicherung_jahr1 und ausspeicherung_jahr2 sind negativ</span></span>
<span id="cb66-71"><a href="#cb66-71" aria-hidden="true" tabindex="-1"></a>    restlast_jahr1 <span class="op">=</span> data <span class="op">+</span> ausspeicherung_jahr1</span>
<span id="cb66-72"><a href="#cb66-72" aria-hidden="true" tabindex="-1"></a>    restlast_jahr2 <span class="op">=</span> data <span class="op">+</span> ausspeicherung_jahr2</span>
<span id="cb66-73"><a href="#cb66-73" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-74"><a href="#cb66-74" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Spalte in DataFrame restlast_nach_ausspeichern einfügen</span></span>
<span id="cb66-75"><a href="#cb66-75" aria-hidden="true" tabindex="-1"></a>    restlast_nach_ausspeichern[<span class="st">'Speichergröße '</span> <span class="op">+</span> <span class="bu">str</span>(speichergröße_neu)] <span class="op">=</span> [ <span class="bu">list</span>(restlast_jahr1), <span class="bu">list</span>(restlast_jahr2) ]</span>
<span id="cb66-76"><a href="#cb66-76" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-77"><a href="#cb66-77" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Anteil EE berechnen = 1 - Summe positive Restlast / Summe Netzlast </span></span>
<span id="cb66-78"><a href="#cb66-78" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">type</span>(netzlast) <span class="kw">is</span> <span class="kw">not</span> <span class="bu">int</span>:</span>
<span id="cb66-79"><a href="#cb66-79" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb66-80"><a href="#cb66-80" aria-hidden="true" tabindex="-1"></a>       <span class="co">## Jahr1</span></span>
<span id="cb66-81"><a href="#cb66-81" aria-hidden="true" tabindex="-1"></a>      anteil_ee_jahr1 <span class="op">=</span> <span class="dv">1</span> <span class="op">-</span> (restlast_jahr1.clip(lower <span class="op">=</span> <span class="dv">0</span>).<span class="bu">sum</span>() <span class="op">/</span> netzlast.<span class="bu">sum</span>() )</span>
<span id="cb66-82"><a href="#cb66-82" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-83"><a href="#cb66-83" aria-hidden="true" tabindex="-1"></a>      <span class="co">## Jahr2</span></span>
<span id="cb66-84"><a href="#cb66-84" aria-hidden="true" tabindex="-1"></a>      anteil_ee_jahr2 <span class="op">=</span> <span class="dv">1</span> <span class="op">-</span> (restlast_jahr2.clip(lower <span class="op">=</span> <span class="dv">0</span>).<span class="bu">sum</span>() <span class="op">/</span> netzlast.<span class="bu">sum</span>() )</span>
<span id="cb66-85"><a href="#cb66-85" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-86"><a href="#cb66-86" aria-hidden="true" tabindex="-1"></a>      <span class="co"># Anteil EE in DataFrame speichern, value assignment: df.loc[row_indexer, "col"] = values</span></span>
<span id="cb66-87"><a href="#cb66-87" aria-hidden="true" tabindex="-1"></a>      dataframe_anteil_ee.loc[count, <span class="st">'Anteil EE Jahr1'</span>] <span class="op">=</span> anteil_ee_jahr1</span>
<span id="cb66-88"><a href="#cb66-88" aria-hidden="true" tabindex="-1"></a>      dataframe_anteil_ee.loc[count, <span class="st">'Anteil EE Jahr2'</span>] <span class="op">=</span> anteil_ee_jahr2</span>
<span id="cb66-89"><a href="#cb66-89" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb66-90"><a href="#cb66-90" aria-hidden="true" tabindex="-1"></a>    count <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb66-91"><a href="#cb66-91" aria-hidden="true" tabindex="-1"></a>                          </span>
<span id="cb66-92"><a href="#cb66-92" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> output: <span class="co"># Anteil EE ausgeben</span></span>
<span id="cb66-93"><a href="#cb66-93" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-94"><a href="#cb66-94" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Summe Netzlast: </span><span class="sc">{</span>netzlast<span class="sc">.</span><span class="bu">sum</span>()<span class="sc">:,.2f}</span><span class="ch">\n</span><span class="ss">Summe positive Restlast: </span><span class="sc">{</span>data<span class="sc">.</span>clip(lower <span class="op">=</span> <span class="dv">0</span>)<span class="sc">.</span><span class="bu">sum</span>()<span class="sc">:,.2f}</span><span class="ch">\t</span><span class="ss">Summe negative Restlast: </span><span class="sc">{</span>data<span class="sc">.</span>clip(upper <span class="op">=</span> <span class="dv">0</span>)<span class="sc">.</span><span class="bu">sum</span>()<span class="sc">:,.2f}</span><span class="ch">\n</span><span class="ss">Speichergröße 1: </span><span class="sc">{</span>speichergr<span class="sc">öß</span>e0<span class="sc">:,.2f}</span><span class="ch">\t</span><span class="ss">Anteil EE ohne Speicher: </span><span class="sc">{</span><span class="dv">1</span> <span class="op">-</span> ( data.clip(lower <span class="op">=</span> <span class="dv">0</span>).<span class="bu">sum</span>() <span class="op">/</span> netzlast.<span class="bu">sum</span>() ) <span class="cf">if</span> <span class="bu">len</span>(netzlast) <span class="op">&gt;</span> <span class="dv">1</span> <span class="cf">else</span> <span class="st">'--'</span><span class="sc">:,.2f}</span><span class="ch">\n</span><span class="ss">"</span>)</span>
<span id="cb66-95"><a href="#cb66-95" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(dataframe_anteil_ee)</span>
<span id="cb66-96"><a href="#cb66-96" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb66-97"><a href="#cb66-97" aria-hidden="true" tabindex="-1"></a>  <span class="cf">else</span>: <span class="co"># Restlastkurven zurückgeben</span></span>
<span id="cb66-98"><a href="#cb66-98" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> restlast_nach_ausspeichern</span>
<span id="cb66-99"><a href="#cb66-99" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-100"><a href="#cb66-100" aria-hidden="true" tabindex="-1"></a>anteil_ee_berechnen(restlast, netzlast <span class="op">=</span> verbrauch[<span class="st">'Gesamt (Netzlast) [MWh]'</span>], neue_speichergrößen <span class="op">=</span> [<span class="fl">0.9</span>, <span class="fl">0.8</span>, <span class="fl">0.7</span>, <span class="fl">0.6</span>, <span class="fl">0.5</span>], output <span class="op">=</span> <span class="va">True</span>)</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Summe Netzlast: 458,271,100.75
Summe positive Restlast: 207,842,228.25 Summe negative Restlast: -1,002,976.00
Speichergröße 1: 119,667.00 Anteil EE ohne Speicher: 0.55

   relative Speichergröße  Anteil EE Jahr1  Anteil EE Jahr2
0                     1.0             0.55             0.55
1                     0.9             0.55             0.55
2                     0.8             0.55             0.55
3                     0.7             0.55             0.55
4                     0.6             0.55             0.55
5                     0.5             0.55             0.55</code></pre>
</div>
</div>
</div>
<div id="tabset-14-2" class="tab-pane" role="tabpanel" aria-labelledby="tabset-14-2-tab">
<div id="003ce591" class="cell" data-execution_count="66">
<div class="sourceCode cell-code" id="cb68"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Anteil EE berechnen</span></span>
<span id="cb68-2"><a href="#cb68-2" aria-hidden="true" tabindex="-1"></a><span class="co">## Eingabe: data = pd.Series(data, dtype = 'float'), netzlast = -1, einspeicherwirkungsgrad = 1, ausspeicherwirkungsgrad = 1, neue_speichergrößen = [0.9, 0.8, 0.7, 0.6, 0.5], output = False</span></span>
<span id="cb68-3"><a href="#cb68-3" aria-hidden="true" tabindex="-1"></a><span class="co">## Verarbeitung: Aufruf der Funktion jahresgang_speicher_berechnen(data) zur Bestimmung von Speichergröße und Jahrsgang des Speichers in Jahr 1 und Jahr 2</span></span>
<span id="cb68-4"><a href="#cb68-4" aria-hidden="true" tabindex="-1"></a><span class="co">## Verarbeitung: Im Jahresgang des Stromspeichers wird die ausgespeicherte Strommenge bestimmt, diese wird von der Restlast abgezogen --&gt; neue Restlastkurve nach Ausspeicherung</span></span>
<span id="cb68-5"><a href="#cb68-5" aria-hidden="true" tabindex="-1"></a><span class="co">## Verarbeitung: Wenn netzlast = pd.Series(netzlast, dtype = 'float') übergeben wurde, wird anhand der Restlastkurve nach Ausspeicherung der Anteil erneuerbarer Energie bestimmt</span></span>
<span id="cb68-6"><a href="#cb68-6" aria-hidden="true" tabindex="-1"></a><span class="co">## Verarbeitung: Die Berechnungen werden für kleiner dimensionerte Speicher wiederholt, default = [0.9, 0.8, 0.7, 0.6, 0.5]</span></span>
<span id="cb68-7"><a href="#cb68-7" aria-hidden="true" tabindex="-1"></a><span class="co">## Ausgabe: output = False Restlastkurve wird zurückgeben</span></span>
<span id="cb68-8"><a href="#cb68-8" aria-hidden="true" tabindex="-1"></a><span class="co">## Ausgabe: output = True, Ausgabe Summe Netzlast, positive / negative Restlast, Anteil EE ohne Speicher sowie realisierter Anteil EE für Speichergröße Basisjahr und neue_speichergrößen jeweils für Jahr 1 und Jahr2 mittels print()</span></span>
<span id="cb68-9"><a href="#cb68-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-10"><a href="#cb68-10" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> anteil_ee_berechnen(data, netzlast <span class="op">=</span> <span class="op">-</span><span class="dv">1</span>, einspeicherwirkungsgrad <span class="op">=</span> <span class="dv">1</span>, ausspeicherwirkungsgrad <span class="op">=</span> <span class="dv">1</span>, neue_speichergrößen <span class="op">=</span> [<span class="fl">0.9</span>, <span class="fl">0.8</span>, <span class="fl">0.7</span>, <span class="fl">0.6</span>, <span class="fl">0.5</span>], output <span class="op">=</span> <span class="va">False</span>):</span>
<span id="cb68-11"><a href="#cb68-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-12"><a href="#cb68-12" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Jahresgang im Basisjahr bestimmen</span></span>
<span id="cb68-13"><a href="#cb68-13" aria-hidden="true" tabindex="-1"></a>  ergebnis <span class="op">=</span> jahresgang_speicher_berechnen(data, speichergröße <span class="op">=</span> <span class="op">-</span><span class="dv">1</span>, einspeicherwirkungsgrad <span class="op">=</span> einspeicherwirkungsgrad, ausspeicherwirkungsgrad <span class="op">=</span> ausspeicherwirkungsgrad, output <span class="op">=</span> <span class="va">False</span>)</span>
<span id="cb68-14"><a href="#cb68-14" aria-hidden="true" tabindex="-1"></a>  speichergröße0 <span class="op">=</span> ergebnis[<span class="dv">0</span>]</span>
<span id="cb68-15"><a href="#cb68-15" aria-hidden="true" tabindex="-1"></a>  jahresgang_speicher_jahr1 <span class="op">=</span> ergebnis[<span class="dv">1</span>]</span>
<span id="cb68-16"><a href="#cb68-16" aria-hidden="true" tabindex="-1"></a>  jahresgang_speicher_jahr2 <span class="op">=</span> ergebnis[<span class="dv">2</span>]</span>
<span id="cb68-17"><a href="#cb68-17" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb68-18"><a href="#cb68-18" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Jahresgang Jahr 1 eine Null voranstellen, Jahresgang Jahr 2 den letzten Wert aus Jahr 1</span></span>
<span id="cb68-19"><a href="#cb68-19" aria-hidden="true" tabindex="-1"></a>  jahresgang_speicher_jahr1 <span class="op">=</span> pd.concat([pd.Series([<span class="dv">0</span>]), jahresgang_speicher_jahr1])</span>
<span id="cb68-20"><a href="#cb68-20" aria-hidden="true" tabindex="-1"></a>  jahresgang_speicher_jahr2 <span class="op">=</span> pd.concat([jahresgang_speicher_jahr1[ <span class="op">-</span> <span class="dv">1</span>: ], jahresgang_speicher_jahr2])</span>
<span id="cb68-21"><a href="#cb68-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-22"><a href="#cb68-22" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Jahresgang der ausgespeicherten Strommenge, erster Wert ist NaN und entfällt</span></span>
<span id="cb68-23"><a href="#cb68-23" aria-hidden="true" tabindex="-1"></a>  ausspeicherung_jahr1 <span class="op">=</span> jahresgang_speicher_jahr1.diff().clip(upper <span class="op">=</span> <span class="dv">0</span>)[<span class="dv">1</span>: ].reset_index(drop <span class="op">=</span> <span class="va">True</span>)</span>
<span id="cb68-24"><a href="#cb68-24" aria-hidden="true" tabindex="-1"></a>  ausspeicherung_jahr2 <span class="op">=</span> jahresgang_speicher_jahr2.diff().clip(upper <span class="op">=</span> <span class="dv">0</span>)[<span class="dv">1</span>: ].reset_index(drop <span class="op">=</span> <span class="va">True</span>)</span>
<span id="cb68-25"><a href="#cb68-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-26"><a href="#cb68-26" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Restlast nach Ausspeicherung berechnen, Werte in ausspeicherung_jahr1 und ausspeicherung_jahr2 sind negativ</span></span>
<span id="cb68-27"><a href="#cb68-27" aria-hidden="true" tabindex="-1"></a>  restlast_jahr1 <span class="op">=</span> data <span class="op">+</span> ausspeicherung_jahr1</span>
<span id="cb68-28"><a href="#cb68-28" aria-hidden="true" tabindex="-1"></a>  restlast_jahr2 <span class="op">=</span> data <span class="op">+</span> ausspeicherung_jahr2</span>
<span id="cb68-29"><a href="#cb68-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-30"><a href="#cb68-30" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Restlast in DataFrame speichern</span></span>
<span id="cb68-31"><a href="#cb68-31" aria-hidden="true" tabindex="-1"></a>  restlast_nach_ausspeichern <span class="op">=</span> pd.DataFrame({<span class="st">'Speichergröße 1'</span>: [ <span class="bu">list</span>(restlast_jahr1), <span class="bu">list</span>(restlast_jahr2) ]})</span>
<span id="cb68-32"><a href="#cb68-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-33"><a href="#cb68-33" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="bu">type</span>(netzlast) <span class="kw">is</span> <span class="bu">int</span>: <span class="co"># Anteil EE kann nicht ermittelt werden</span></span>
<span id="cb68-34"><a href="#cb68-34" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> output:</span>
<span id="cb68-35"><a href="#cb68-35" aria-hidden="true" tabindex="-1"></a>      <span class="bu">print</span>(<span class="st">"Netzlast wurde nicht übergeben. Anteil erneuerbarer Energien kann nicht ermittelt werden."</span>)</span>
<span id="cb68-36"><a href="#cb68-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-37"><a href="#cb68-37" aria-hidden="true" tabindex="-1"></a>    output <span class="op">=</span> <span class="va">False</span></span>
<span id="cb68-38"><a href="#cb68-38" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb68-39"><a href="#cb68-39" aria-hidden="true" tabindex="-1"></a>  <span class="cf">else</span>: <span class="co"># Anteil EE berechnen</span></span>
<span id="cb68-40"><a href="#cb68-40" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb68-41"><a href="#cb68-41" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Anteil Anteil EE berechnen = 1 - Summe positive Restlast / Summe Netzlast </span></span>
<span id="cb68-42"><a href="#cb68-42" aria-hidden="true" tabindex="-1"></a>    <span class="co">## Jahr1</span></span>
<span id="cb68-43"><a href="#cb68-43" aria-hidden="true" tabindex="-1"></a>    anteil_ee_jahr1 <span class="op">=</span> <span class="dv">1</span> <span class="op">-</span> (restlast_jahr1.clip(lower <span class="op">=</span> <span class="dv">0</span>).<span class="bu">sum</span>() <span class="op">/</span> netzlast.<span class="bu">sum</span>() )</span>
<span id="cb68-44"><a href="#cb68-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-45"><a href="#cb68-45" aria-hidden="true" tabindex="-1"></a>    <span class="co">## Jahr2</span></span>
<span id="cb68-46"><a href="#cb68-46" aria-hidden="true" tabindex="-1"></a>    anteil_ee_jahr2 <span class="op">=</span> <span class="dv">1</span> <span class="op">-</span> (restlast_jahr2.clip(lower <span class="op">=</span> <span class="dv">0</span>).<span class="bu">sum</span>() <span class="op">/</span> netzlast.<span class="bu">sum</span>() )</span>
<span id="cb68-47"><a href="#cb68-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-48"><a href="#cb68-48" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Anteil EE in DataFrame speichern</span></span>
<span id="cb68-49"><a href="#cb68-49" aria-hidden="true" tabindex="-1"></a>    dataframe_anteil_ee <span class="op">=</span> pd.DataFrame({<span class="st">'relative Speichergröße'</span>: pd.concat([ pd.Series([<span class="dv">1</span>]), pd.Series(neue_speichergrößen) ], ignore_index <span class="op">=</span> <span class="va">True</span>), <span class="st">'Anteil EE Jahr1'</span>: pd.Series([ anteil_ee_jahr1 ] ), <span class="st">'Anteil EE Jahr2'</span>: pd.Series([ anteil_ee_jahr2 ])})</span>
<span id="cb68-50"><a href="#cb68-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-51"><a href="#cb68-51" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Jahresgang der ausgespeicherten Strommenge und Anteil EE bei alternativen Speichergrößen berechnen</span></span>
<span id="cb68-52"><a href="#cb68-52" aria-hidden="true" tabindex="-1"></a>  count <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb68-53"><a href="#cb68-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-54"><a href="#cb68-54" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(neue_speichergrößen)):</span>
<span id="cb68-55"><a href="#cb68-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-56"><a href="#cb68-56" aria-hidden="true" tabindex="-1"></a>    speichergröße_neu <span class="op">=</span> speichergröße0 <span class="op">*</span> neue_speichergrößen[i]</span>
<span id="cb68-57"><a href="#cb68-57" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb68-58"><a href="#cb68-58" aria-hidden="true" tabindex="-1"></a>    ergebnis <span class="op">=</span> jahresgang_speicher_berechnen(data, speichergröße <span class="op">=</span> speichergröße_neu, einspeicherwirkungsgrad <span class="op">=</span> einspeicherwirkungsgrad, ausspeicherwirkungsgrad <span class="op">=</span> ausspeicherwirkungsgrad, output <span class="op">=</span> <span class="va">False</span>)</span>
<span id="cb68-59"><a href="#cb68-59" aria-hidden="true" tabindex="-1"></a>    jahresgang_speicher_jahr1 <span class="op">=</span> ergebnis[<span class="dv">1</span>]</span>
<span id="cb68-60"><a href="#cb68-60" aria-hidden="true" tabindex="-1"></a>    jahresgang_speicher_jahr2 <span class="op">=</span> ergebnis[<span class="dv">2</span>]</span>
<span id="cb68-61"><a href="#cb68-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-62"><a href="#cb68-62" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Jahresgang Jahr 1 eine Null voranstellen, Jahresgang Jahr 2 den letzten Wert aus Jahr 1</span></span>
<span id="cb68-63"><a href="#cb68-63" aria-hidden="true" tabindex="-1"></a>    jahresgang_speicher_jahr1 <span class="op">=</span> pd.concat([pd.Series([<span class="dv">0</span>]), jahresgang_speicher_jahr1])</span>
<span id="cb68-64"><a href="#cb68-64" aria-hidden="true" tabindex="-1"></a>    jahresgang_speicher_jahr2 <span class="op">=</span> pd.concat([jahresgang_speicher_jahr1[ <span class="op">-</span> <span class="dv">1</span>: ], jahresgang_speicher_jahr2])</span>
<span id="cb68-65"><a href="#cb68-65" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-66"><a href="#cb68-66" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Jahresgang der ausgespeicherten Strommenge, erster Wert ist NaN und entfällt</span></span>
<span id="cb68-67"><a href="#cb68-67" aria-hidden="true" tabindex="-1"></a>    ausspeicherung_jahr1 <span class="op">=</span> jahresgang_speicher_jahr1.diff().clip(upper <span class="op">=</span> <span class="dv">0</span>)[<span class="dv">1</span>: ].reset_index(drop <span class="op">=</span> <span class="va">True</span>)</span>
<span id="cb68-68"><a href="#cb68-68" aria-hidden="true" tabindex="-1"></a>    ausspeicherung_jahr2 <span class="op">=</span> jahresgang_speicher_jahr2.diff().clip(upper <span class="op">=</span> <span class="dv">0</span>)[<span class="dv">1</span>: ].reset_index(drop <span class="op">=</span> <span class="va">True</span>)</span>
<span id="cb68-69"><a href="#cb68-69" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-70"><a href="#cb68-70" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Restlast nach Ausspeicherung berechnen, Werte in ausspeicherung_jahr1 und ausspeicherung_jahr2 sind negativ</span></span>
<span id="cb68-71"><a href="#cb68-71" aria-hidden="true" tabindex="-1"></a>    restlast_jahr1 <span class="op">=</span> data <span class="op">+</span> ausspeicherung_jahr1</span>
<span id="cb68-72"><a href="#cb68-72" aria-hidden="true" tabindex="-1"></a>    restlast_jahr2 <span class="op">=</span> data <span class="op">+</span> ausspeicherung_jahr2</span>
<span id="cb68-73"><a href="#cb68-73" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-74"><a href="#cb68-74" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Spalte in DataFrame restlast_nach_ausspeichern einfügen</span></span>
<span id="cb68-75"><a href="#cb68-75" aria-hidden="true" tabindex="-1"></a>    restlast_nach_ausspeichern[<span class="st">'Speichergröße '</span> <span class="op">+</span> <span class="bu">str</span>(speichergröße_neu)] <span class="op">=</span> [ <span class="bu">list</span>(restlast_jahr1), <span class="bu">list</span>(restlast_jahr2) ]</span>
<span id="cb68-76"><a href="#cb68-76" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-77"><a href="#cb68-77" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Anteil EE berechnen = 1 - Summe positive Restlast / Summe Netzlast </span></span>
<span id="cb68-78"><a href="#cb68-78" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">type</span>(netzlast) <span class="kw">is</span> <span class="kw">not</span> <span class="bu">int</span>:</span>
<span id="cb68-79"><a href="#cb68-79" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb68-80"><a href="#cb68-80" aria-hidden="true" tabindex="-1"></a>       <span class="co">## Jahr1</span></span>
<span id="cb68-81"><a href="#cb68-81" aria-hidden="true" tabindex="-1"></a>      anteil_ee_jahr1 <span class="op">=</span> <span class="dv">1</span> <span class="op">-</span> (restlast_jahr1.clip(lower <span class="op">=</span> <span class="dv">0</span>).<span class="bu">sum</span>() <span class="op">/</span> netzlast.<span class="bu">sum</span>() )</span>
<span id="cb68-82"><a href="#cb68-82" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-83"><a href="#cb68-83" aria-hidden="true" tabindex="-1"></a>      <span class="co">## Jahr2</span></span>
<span id="cb68-84"><a href="#cb68-84" aria-hidden="true" tabindex="-1"></a>      anteil_ee_jahr2 <span class="op">=</span> <span class="dv">1</span> <span class="op">-</span> (restlast_jahr2.clip(lower <span class="op">=</span> <span class="dv">0</span>).<span class="bu">sum</span>() <span class="op">/</span> netzlast.<span class="bu">sum</span>() )</span>
<span id="cb68-85"><a href="#cb68-85" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-86"><a href="#cb68-86" aria-hidden="true" tabindex="-1"></a>      <span class="co"># Anteil EE in DataFrame speichern, value assignment: df.loc[row_indexer, "col"] = values</span></span>
<span id="cb68-87"><a href="#cb68-87" aria-hidden="true" tabindex="-1"></a>      dataframe_anteil_ee.loc[count, <span class="st">'Anteil EE Jahr1'</span>] <span class="op">=</span> anteil_ee_jahr1</span>
<span id="cb68-88"><a href="#cb68-88" aria-hidden="true" tabindex="-1"></a>      dataframe_anteil_ee.loc[count, <span class="st">'Anteil EE Jahr2'</span>] <span class="op">=</span> anteil_ee_jahr2</span>
<span id="cb68-89"><a href="#cb68-89" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb68-90"><a href="#cb68-90" aria-hidden="true" tabindex="-1"></a>    count <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb68-91"><a href="#cb68-91" aria-hidden="true" tabindex="-1"></a>                          </span>
<span id="cb68-92"><a href="#cb68-92" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> output: <span class="co"># Anteil EE ausgeben</span></span>
<span id="cb68-93"><a href="#cb68-93" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-94"><a href="#cb68-94" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Summe Netzlast: </span><span class="sc">{</span>netzlast<span class="sc">.</span><span class="bu">sum</span>()<span class="sc">:,.2f}</span><span class="ch">\n</span><span class="ss">Summe positive Restlast: </span><span class="sc">{</span>data<span class="sc">.</span>clip(lower <span class="op">=</span> <span class="dv">0</span>)<span class="sc">.</span><span class="bu">sum</span>()<span class="sc">:,.2f}</span><span class="ch">\t</span><span class="ss">Summe negative Restlast: </span><span class="sc">{</span>data<span class="sc">.</span>clip(upper <span class="op">=</span> <span class="dv">0</span>)<span class="sc">.</span><span class="bu">sum</span>()<span class="sc">:,.2f}</span><span class="ch">\n</span><span class="ss">Speichergröße 1: </span><span class="sc">{</span>speichergr<span class="sc">öß</span>e0<span class="sc">:,.2f}</span><span class="ch">\t</span><span class="ss">Anteil EE ohne Speicher: </span><span class="sc">{</span><span class="dv">1</span> <span class="op">-</span> ( data.clip(lower <span class="op">=</span> <span class="dv">0</span>).<span class="bu">sum</span>() <span class="op">/</span> netzlast.<span class="bu">sum</span>() ) <span class="cf">if</span> <span class="bu">len</span>(netzlast) <span class="op">&gt;</span> <span class="dv">1</span> <span class="cf">else</span> <span class="st">'--'</span><span class="sc">:,.2f}</span><span class="ch">\n</span><span class="ss">"</span>)</span>
<span id="cb68-95"><a href="#cb68-95" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(dataframe_anteil_ee)</span>
<span id="cb68-96"><a href="#cb68-96" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb68-97"><a href="#cb68-97" aria-hidden="true" tabindex="-1"></a>  <span class="cf">else</span>: <span class="co"># Restlastkurven zurückgeben</span></span>
<span id="cb68-98"><a href="#cb68-98" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> restlast_nach_ausspeichern</span>
<span id="cb68-99"><a href="#cb68-99" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-100"><a href="#cb68-100" aria-hidden="true" tabindex="-1"></a>anteil_ee_berechnen(restlast, netzlast <span class="op">=</span> verbrauch[<span class="st">'Gesamt (Netzlast) [MWh]'</span>], einspeicherwirkungsgrad <span class="op">=</span> <span class="fl">0.9</span>, ausspeicherwirkungsgrad <span class="op">=</span> <span class="fl">0.9</span>, neue_speichergrößen <span class="op">=</span> [<span class="fl">0.9</span>, <span class="fl">0.8</span>, <span class="fl">0.7</span>, <span class="fl">0.6</span>, <span class="fl">0.5</span>], output <span class="op">=</span> <span class="va">True</span>)</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Summe Netzlast: 458,271,100.75
Summe positive Restlast: 207,842,228.25 Summe negative Restlast: -1,002,976.00
Speichergröße 1: 102,674.54 Anteil EE ohne Speicher: 0.55

   relative Speichergröße  Anteil EE Jahr1  Anteil EE Jahr2
0                     1.0             0.55             0.55
1                     0.9             0.55             0.55
2                     0.8             0.55             0.55
3                     0.7             0.55             0.55
4                     0.6             0.55             0.55
5                     0.5             0.55             0.55</code></pre>
</div>
</div>
</div>
</div>
</div>
<p>Für das Jahr 2023 ergäbe sich durch die Netzintegration eines Stromspeichers zur (teilweisen) Deckung der Restlast aus erneuerbarer Überschussproduktion eine nur unmerkliche Erhöhung des Anteils erneuerbarer Energien am Strommix. Das liegt daran, dass die einzuspeichernden erneuerbaren Überschüsse mit 1.002.976 MWh, also rund 1 TWh, erheblich kleiner als die zu deckende positive Restlast mit 207.842.228 MWh, also rund 208 TWh, sind. Die durch den Stromspeicher verschiebbare erneuerbare Überschussproduktion entspricht weniger als einem halben Prozent der zu deckenden Restlast.</p>
<p>Mit steigendem Anteil erneuerbarer Erzeugung wird die Speicherung überschüssiger Stromerzeugung jedoch immer relevanter werden. Die Dimension der erforderlichen Stromspeicher können mit den entwickelten Funktionen für den Ausbaupfad erneuerbarer Energien abgeschätzt werden.</p>
</section>
</section>
<section id="aufgabe-schließende-datenanalyse" class="level2" data-number="8.5">
<h2 data-number="8.5" class="anchored" data-anchor-id="aufgabe-schließende-datenanalyse"><span class="header-section-number">8.5</span> Aufgabe schließende Datenanalyse</h2>
<p><strong>Berechnen Sie entsprechend des von der Bundesregierung vorgegebenen Ausbaupfads den Anteil erneuerbarer Stromerzeugung für das Jahr 2030 und für das Jahr 2035 (siehe <a href="#lst-zubaufaktoren" class="quarto-xref">Listing&nbsp;1</a>).</strong></p>
<ul>
<li><p>Wie groß ist der maximal benötigte Speicher?</p></li>
<li><p>Welcher Anteil erneuerbarer Stromerzeugung wird erreicht, wenn der Speicher halb so groß, ein Zehntel so groß oder ein Hundertstel so groß dimensioniert wird?</p></li>
<li><p>Als Netzlast verwenden Sie die Projektionen des Stromverbrauchs für das Jahr 2030 und 2035 (siehe untenstehender Hinweis).</p></li>
<li><p>Für den Wirkungsgrad können die bestehenden Pumpspeicherkraftwerke als Orientierung dienen. Der Gesamtwirkungsgrad wurde mit 79.10 Prozent berechnet. Diesem Wirkungsgrad entspricht näherungsweise eine Aufteilung von Einspeicherwirkungsgrad = 0.9, Ausspeicherwirkungsgrad = 0.88.</p></li>
</ul>
<div class="callout callout-style-simple callout-warning callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Projektionen des Stromverbrauchs
</div>
</div>
<div class="callout-body-container callout-body">
<p>Der künftige Stromverbrauch wird wahrscheinlich nicht dem des Jahres 2023 entsprechen. Projektionen lassen einen Stromverbrauch von 658 TWh (Kemmler, Wünsch, und Burret 2021, S. 4) für das Jahr 2030 und von 670,4 TWh im Jahr 2034 (Szenario B nach Nahmmacher et al.&nbsp;2021, S. 54) erwarten. Die Steigerung des Stromverbrauchs gegenüber 2023 kann leicht berechnet werden:</p>
<div id="53c7acb0" class="cell" data-execution_count="67">
<div class="sourceCode cell-code" id="cb70"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true" tabindex="-1"></a>lastfaktor_2030_MWh <span class="op">=</span> (<span class="dv">658</span> <span class="op">*</span> <span class="dv">1000</span> <span class="op">*</span> <span class="dv">1000</span>) <span class="op">/</span> verbrauch[<span class="st">"Gesamt (Netzlast) [MWh]"</span>].<span class="bu">sum</span>()</span>
<span id="cb70-2"><a href="#cb70-2" aria-hidden="true" tabindex="-1"></a>lastfaktor_2035_MWh <span class="op">=</span> (<span class="fl">670.4</span> <span class="op">*</span> <span class="dv">1000</span> <span class="op">*</span> <span class="dv">1000</span>) <span class="op">/</span> verbrauch[<span class="st">"Gesamt (Netzlast) [MWh]"</span>].<span class="bu">sum</span>()</span>
<span id="cb70-3"><a href="#cb70-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb70-4"><a href="#cb70-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Steigerung des Stromverbrauchs 2030 gegenüber 2023 Faktor: </span><span class="sc">{</span>lastfaktor_2030_MWh<span class="sc">:,.2f}</span><span class="ch">\n</span><span class="ss">"</span></span>
<span id="cb70-5"><a href="#cb70-5" aria-hidden="true" tabindex="-1"></a>      <span class="ss">f"Steigerung des Stromverbrauchs 2035 gegenüber 2023 Faktor: </span><span class="sc">{</span>lastfaktor_2035_MWh<span class="sc">:,.2f}</span><span class="ss">"</span>)</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Steigerung des Stromverbrauchs 2030 gegenüber 2023 Faktor: 1.44
Steigerung des Stromverbrauchs 2035 gegenüber 2023 Faktor: 1.46</code></pre>
</div>
</div>
<p>Kemmler, Andreas, Aurel Wünsch, und Heiko Burret. 2021. “Entwicklung des Bruttostromverbrauchs bis 2030. Kurzstudie.” <a href="https://www.bmwk.de/Redaktion/DE/Downloads/E/prognos-bruttostromverbrauch-2018-2030.pdf?__blob=publicationFile&amp;v=2" class="uri">https://www.bmwk.de/Redaktion/DE/Downloads/E/prognos-bruttostromverbrauch-2018-2030.pdf?__blob=publicationFile&amp;v=2</a></p>
<p>Nahmmacher, Paul, Christian Paris, Martin Ruge, Sebastian Spieker, Thomas Anderski, Sebastian Bohlen, Robin Kaiser, Caroline Podewski, Jürgen Apfelbeck, Timo Kahl, Fabian Lukas, Sven Schäfer, Paul-Steven Ganer, Max Muller und Daniel Stützle. 2021. “Szenariorahmen zum Netzentwicklungsplan Strom 2035, Version 2021. Entwurf der Übertragungsnetzbetreiber.” <a href="https://www.netzausbau.de/SharedDocs/Downloads/DE/Bedarfsermittlung/2035/SR/Szenariorahmen_2035_Entwurf.pdf?__blob=publicationFile" class="uri">https://www.netzausbau.de/SharedDocs/Downloads/DE/Bedarfsermittlung/2035/SR/Szenariorahmen_2035_Entwurf.pdf?__blob=publicationFile</a></p>
</div>
</div>
<div id="tip-aufgabe-schließende-datenanalyse" class="callout callout-style-default callout-tip callout-titled" title="Musterlösung Aufgabe schließende Datenanalyse">
<div class="callout-header d-flex align-content-center" data-bs-toggle="collapse" data-bs-target=".callout-27-contents" aria-controls="callout-27" aria-expanded="false" aria-label="Toggle callout">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Tip&nbsp;12: Musterlösung Aufgabe schließende Datenanalyse
</div>
<div class="callout-btn-toggle d-inline-block border-0 py-1 ps-1 pe-0 float-end"><i class="callout-toggle"></i></div>
</div>
<div id="callout-27" class="callout-27-contents callout-collapse collapse">
<div class="callout-body-container callout-body">
<div class="tabset-margin-container"></div><div class="panel-tabset">
<ul class="nav nav-tabs" role="tablist"><li class="nav-item" role="presentation"><a class="nav-link active" id="tabset-15-1-tab" data-bs-toggle="tab" data-bs-target="#tabset-15-1" role="tab" aria-controls="tabset-15-1" aria-selected="true" href="">2030</a></li><li class="nav-item" role="presentation"><a class="nav-link" id="tabset-15-2-tab" data-bs-toggle="tab" data-bs-target="#tabset-15-2" role="tab" aria-controls="tabset-15-2" aria-selected="false" href="">2035</a></li></ul>
<div class="tab-content">
<div id="tabset-15-1" class="tab-pane active" role="tabpanel" aria-labelledby="tabset-15-1-tab">
<div id="64853419" class="cell" data-execution_count="68">
<div class="sourceCode cell-code" id="cb72"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true" tabindex="-1"></a>meine_speichergrößen <span class="op">=</span> [<span class="fl">0.9</span>, <span class="fl">0.8</span>, <span class="fl">0.7</span>, <span class="fl">0.6</span>, <span class="fl">0.5</span>, <span class="fl">0.4</span>, <span class="fl">0.3</span>, <span class="fl">0.2</span>, <span class="fl">0.1</span>, <span class="fl">0.08</span>, <span class="fl">0.06</span>, <span class="fl">0.04</span>, <span class="fl">0.02</span>, <span class="fl">0.01</span>]</span>
<span id="cb72-2"><a href="#cb72-2" aria-hidden="true" tabindex="-1"></a>mein_einspeicherwirkungsgrad <span class="op">=</span> <span class="fl">0.9</span></span>
<span id="cb72-3"><a href="#cb72-3" aria-hidden="true" tabindex="-1"></a>mein_ausspeicherwirkungsgrad <span class="op">=</span> <span class="fl">0.88</span></span>
<span id="cb72-4"><a href="#cb72-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb72-5"><a href="#cb72-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Datensatz 2030 erzeugen</span></span>
<span id="cb72-6"><a href="#cb72-6" aria-hidden="true" tabindex="-1"></a><span class="co">## zubaufaktor_windonshore_2030</span></span>
<span id="cb72-7"><a href="#cb72-7" aria-hidden="true" tabindex="-1"></a><span class="co">## zubaufaktor_windoffshore_2030</span></span>
<span id="cb72-8"><a href="#cb72-8" aria-hidden="true" tabindex="-1"></a><span class="co">## zubaufaktor_solar_2030</span></span>
<span id="cb72-9"><a href="#cb72-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb72-10"><a href="#cb72-10" aria-hidden="true" tabindex="-1"></a>erzeugung_2030 <span class="op">=</span> erzeugung.copy()</span>
<span id="cb72-11"><a href="#cb72-11" aria-hidden="true" tabindex="-1"></a>erzeugung_2030[<span class="st">'Wind Onshore [MWh]'</span>] <span class="op">*=</span> zubaufaktor_windonshore_2030</span>
<span id="cb72-12"><a href="#cb72-12" aria-hidden="true" tabindex="-1"></a>erzeugung_2030[<span class="st">'Wind Offshore [MWh]'</span>] <span class="op">*=</span> zubaufaktor_windoffshore_2030</span>
<span id="cb72-13"><a href="#cb72-13" aria-hidden="true" tabindex="-1"></a>erzeugung_2030[<span class="st">'Photovoltaik [MWh]'</span>] <span class="op">*=</span> zubaufaktor_solar_2030</span>
<span id="cb72-14"><a href="#cb72-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb72-15"><a href="#cb72-15" aria-hidden="true" tabindex="-1"></a>erneuerbare_2030 <span class="op">=</span> pd.Series()</span>
<span id="cb72-16"><a href="#cb72-16" aria-hidden="true" tabindex="-1"></a>erneuerbare <span class="op">=</span> [<span class="st">'Biomasse [MWh]'</span>, <span class="st">'Wasserkraft [MWh]'</span>, <span class="st">'Wind Offshore [MWh]'</span>, <span class="st">'Wind Onshore [MWh]'</span>, <span class="st">'Photovoltaik [MWh]'</span>,</span>
<span id="cb72-17"><a href="#cb72-17" aria-hidden="true" tabindex="-1"></a><span class="st">'Sonstige Erneuerbare [MWh]'</span>]</span>
<span id="cb72-18"><a href="#cb72-18" aria-hidden="true" tabindex="-1"></a>erneuerbare_2030 <span class="op">=</span> erzeugung_2030[erneuerbare].<span class="bu">sum</span>(axis <span class="op">=</span> <span class="st">"columns"</span>).copy()</span>
<span id="cb72-19"><a href="#cb72-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb72-20"><a href="#cb72-20" aria-hidden="true" tabindex="-1"></a>netzlast_2023 <span class="op">=</span> pd.Series()</span>
<span id="cb72-21"><a href="#cb72-21" aria-hidden="true" tabindex="-1"></a>netzlast_2023 <span class="op">=</span> verbrauch[<span class="st">"Gesamt (Netzlast) [MWh]"</span>].copy()</span>
<span id="cb72-22"><a href="#cb72-22" aria-hidden="true" tabindex="-1"></a>netzlast_2030 <span class="op">=</span> netzlast_2023 <span class="op">*</span> lastfaktor_2030_MWh</span>
<span id="cb72-23"><a href="#cb72-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb72-24"><a href="#cb72-24" aria-hidden="true" tabindex="-1"></a>restlast_2030 <span class="op">=</span> pd.Series()</span>
<span id="cb72-25"><a href="#cb72-25" aria-hidden="true" tabindex="-1"></a>restlast_2030 <span class="op">=</span> netzlast_2023 <span class="op">-</span> erneuerbare_2030</span>
<span id="cb72-26"><a href="#cb72-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb72-27"><a href="#cb72-27" aria-hidden="true" tabindex="-1"></a><span class="co"># Ausgabe</span></span>
<span id="cb72-28"><a href="#cb72-28" aria-hidden="true" tabindex="-1"></a>speicher_2030 <span class="op">=</span> berechne_speichergröße(restlast_2030, einspeicherwirkungsgrad <span class="op">=</span> mein_einspeicherwirkungsgrad, ausspeicherwirkungsgrad <span class="op">=</span> mein_ausspeicherwirkungsgrad, output <span class="op">=</span> <span class="va">False</span>)</span>
<span id="cb72-29"><a href="#cb72-29" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"maximal erforderliche Speichergröße 2030: </span><span class="sc">{</span>speicher_2030<span class="sc">:,.1f}</span><span class="ss"> MWh</span><span class="ch">\n</span><span class="ss">Dies entspricht </span><span class="sc">{</span>speicher_2030 <span class="op">/</span> pumpspeicherkapazit<span class="sc">ä</span>t_MWh<span class="sc">:,.1f}</span><span class="ss"> Pumpspeicheräquivalenten."</span>)</span>
<span id="cb72-30"><a href="#cb72-30" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">"</span>)</span>
<span id="cb72-31"><a href="#cb72-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb72-32"><a href="#cb72-32" aria-hidden="true" tabindex="-1"></a>effekt_kappung_berechnen(restlast_2030, einspeicherwirkungsgrad <span class="op">=</span> mein_einspeicherwirkungsgrad, ausspeicherwirkungsgrad <span class="op">=</span> mein_ausspeicherwirkungsgrad, neue_speichergrößen <span class="op">=</span> meine_speichergrößen, output <span class="op">=</span> <span class="va">True</span>)</span>
<span id="cb72-33"><a href="#cb72-33" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">"</span>)</span>
<span id="cb72-34"><a href="#cb72-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb72-35"><a href="#cb72-35" aria-hidden="true" tabindex="-1"></a>anteil_ee_berechnen(restlast_2030, netzlast <span class="op">=</span> netzlast_2030, einspeicherwirkungsgrad <span class="op">=</span> mein_einspeicherwirkungsgrad, ausspeicherwirkungsgrad <span class="op">=</span> mein_ausspeicherwirkungsgrad, neue_speichergrößen <span class="op">=</span> meine_speichergrößen, output <span class="op">=</span> <span class="va">True</span>)</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>maximal erforderliche Speichergröße 2030: 10,368,907.8 MWh
Dies entspricht 277.2 Pumpspeicheräquivalenten.


    Speichergröße  Einspeicherung Jahr1  Zyklen Jahr1  Einspeicherung Jahr2  \
0        1.04e+07              9.14e+07          8.32              8.20e+07   
1        9.33e+06              9.03e+07          9.17              8.09e+07   
2        8.30e+06              8.72e+07         10.01              7.89e+07   
3        7.26e+06              8.41e+07         11.08              7.68e+07   
4        6.22e+06              8.09e+07         12.51              7.47e+07   
5        5.18e+06              7.78e+07         14.51              7.27e+07   
6        4.15e+06              7.47e+07         17.52              7.06e+07   
7        3.11e+06              7.16e+07         22.52              6.85e+07   
8        2.07e+06              6.61e+07         31.39              6.41e+07   
9        1.04e+06              5.79e+07         55.33              5.69e+07   
10       8.30e+05              5.48e+07         65.62              5.40e+07   
11       6.22e+05              5.05e+07         80.59              4.98e+07   
12       4.15e+05              4.51e+07        108.35              4.47e+07   
13       2.07e+05              3.17e+07        152.53              3.15e+07   
14       1.04e+05              1.95e+07        187.86              1.94e+07   

    Zyklen Jahr2  
0           7.91  
1           8.67  
2           9.51  
3          10.58  
4          12.01  
5          14.01  
6          17.02  
7          22.02  
8          30.89  
9          54.83  
10         65.12  
11         80.09  
12        107.85  
13        152.03  
14        187.36  


    relative Speichergröße  gekappte Einspeicherung Jahr1  \
0                     0.90                       1.15e+06   
1                     0.80                       4.26e+06   
2                     0.70                       7.37e+06   
3                     0.60                       1.05e+07   
4                     0.50                       1.36e+07   
5                     0.40                       1.67e+07   
6                     0.30                       1.98e+07   
7                     0.20                       2.53e+07   
8                     0.10                       3.35e+07   
9                     0.08                       3.66e+07   
10                    0.06                       4.10e+07   
11                    0.04                       4.63e+07   
12                    0.02                       5.97e+07   
13                    0.01                       7.19e+07   

    gekappte Einspeicherung Jahr2  
0                        1.08e+06  
1                        3.16e+06  
2                        5.23e+06  
3                        7.31e+06  
4                        9.38e+06  
5                        1.15e+07  
6                        1.35e+07  
7                        1.80e+07  
8                        2.52e+07  
9                        2.80e+07  
10                       3.22e+07  
11                       3.73e+07  
12                       5.05e+07  
13                       6.26e+07  


Summe Netzlast: 658,000,000.00
Summe positive Restlast: 72,188,237.10  Summe negative Restlast: -181,270,542.87
Speichergröße 1: 10,368,907.77  Anteil EE ohne Speicher: 0.89

    relative Speichergröße  Anteil EE Jahr1  Anteil EE Jahr2
0                     1.00             1.00             1.00
1                     0.90             1.00             1.00
2                     0.80             1.00             1.00
3                     0.70             0.99             0.99
4                     0.60             0.99             0.99
5                     0.50             0.99             0.99
6                     0.40             0.98             0.98
7                     0.30             0.98             0.98
8                     0.20             0.98             0.98
9                     0.10             0.97             0.97
10                    0.08             0.96             0.96
11                    0.06             0.96             0.96
12                    0.04             0.95             0.95
13                    0.02             0.93             0.93
14                    0.01             0.92             0.92</code></pre>
</div>
</div>
</div>
<div id="tabset-15-2" class="tab-pane" role="tabpanel" aria-labelledby="tabset-15-2-tab">
<div id="301db0a9" class="cell" data-execution_count="69">
<div class="sourceCode cell-code" id="cb74"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true" tabindex="-1"></a><span class="co"># # Datensatz 2035 erzeugen</span></span>
<span id="cb74-2"><a href="#cb74-2" aria-hidden="true" tabindex="-1"></a><span class="co"># ## zubaufaktor_windonshore_2035</span></span>
<span id="cb74-3"><a href="#cb74-3" aria-hidden="true" tabindex="-1"></a><span class="co"># ## zubaufaktor_windonshore_2035</span></span>
<span id="cb74-4"><a href="#cb74-4" aria-hidden="true" tabindex="-1"></a><span class="co"># ## zubaufaktor_solar_2035</span></span>
<span id="cb74-5"><a href="#cb74-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-6"><a href="#cb74-6" aria-hidden="true" tabindex="-1"></a>erzeugung_2035 <span class="op">=</span> erzeugung.copy()</span>
<span id="cb74-7"><a href="#cb74-7" aria-hidden="true" tabindex="-1"></a>erzeugung_2035[<span class="st">'Wind Onshore [MWh]'</span>] <span class="op">*=</span> zubaufaktor_windonshore_2035</span>
<span id="cb74-8"><a href="#cb74-8" aria-hidden="true" tabindex="-1"></a>erzeugung_2035[<span class="st">'Wind Offshore [MWh]'</span>] <span class="op">*=</span> zubaufaktor_windoffshore_2035</span>
<span id="cb74-9"><a href="#cb74-9" aria-hidden="true" tabindex="-1"></a>erzeugung_2035[<span class="st">'Photovoltaik [MWh]'</span>] <span class="op">*=</span> zubaufaktor_solar_2035</span>
<span id="cb74-10"><a href="#cb74-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-11"><a href="#cb74-11" aria-hidden="true" tabindex="-1"></a>erneuerbare_2035 <span class="op">=</span> pd.Series()</span>
<span id="cb74-12"><a href="#cb74-12" aria-hidden="true" tabindex="-1"></a>erneuerbare <span class="op">=</span> [<span class="st">'Biomasse [MWh]'</span>, <span class="st">'Wasserkraft [MWh]'</span>, <span class="st">'Wind Offshore [MWh]'</span>, <span class="st">'Wind Onshore [MWh]'</span>, <span class="st">'Photovoltaik [MWh]'</span>,</span>
<span id="cb74-13"><a href="#cb74-13" aria-hidden="true" tabindex="-1"></a><span class="st">'Sonstige Erneuerbare [MWh]'</span>]</span>
<span id="cb74-14"><a href="#cb74-14" aria-hidden="true" tabindex="-1"></a>erneuerbare_2035 <span class="op">=</span> erzeugung_2035[erneuerbare].<span class="bu">sum</span>(axis <span class="op">=</span> <span class="st">"columns"</span>).copy()</span>
<span id="cb74-15"><a href="#cb74-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-16"><a href="#cb74-16" aria-hidden="true" tabindex="-1"></a>netzlast_2023 <span class="op">=</span> pd.Series()</span>
<span id="cb74-17"><a href="#cb74-17" aria-hidden="true" tabindex="-1"></a>netzlast_2023 <span class="op">=</span> verbrauch[<span class="st">"Gesamt (Netzlast) [MWh]"</span>].copy()</span>
<span id="cb74-18"><a href="#cb74-18" aria-hidden="true" tabindex="-1"></a>netzlast_2035 <span class="op">=</span> netzlast_2023 <span class="op">*</span> lastfaktor_2035_MWh</span>
<span id="cb74-19"><a href="#cb74-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-20"><a href="#cb74-20" aria-hidden="true" tabindex="-1"></a>restlast_2035 <span class="op">=</span> pd.Series()</span>
<span id="cb74-21"><a href="#cb74-21" aria-hidden="true" tabindex="-1"></a>restlast_2035 <span class="op">=</span> netzlast_2023 <span class="op">-</span> erneuerbare_2035</span>
<span id="cb74-22"><a href="#cb74-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-23"><a href="#cb74-23" aria-hidden="true" tabindex="-1"></a><span class="co"># Ausgabe</span></span>
<span id="cb74-24"><a href="#cb74-24" aria-hidden="true" tabindex="-1"></a>speicher_2035 <span class="op">=</span> berechne_speichergröße(restlast_2035, einspeicherwirkungsgrad <span class="op">=</span> mein_einspeicherwirkungsgrad, ausspeicherwirkungsgrad <span class="op">=</span> mein_ausspeicherwirkungsgrad, output <span class="op">=</span> <span class="va">False</span>)</span>
<span id="cb74-25"><a href="#cb74-25" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"maximal erforderliche Speichergröße 2035: </span><span class="sc">{</span>speicher_2035<span class="sc">:,.1f}</span><span class="ss"> MWh</span><span class="ch">\n</span><span class="ss">Dies entspricht </span><span class="sc">{</span>speicher_2035 <span class="op">/</span> pumpspeicherkapazit<span class="sc">ä</span>t_MWh<span class="sc">:,.1f}</span><span class="ss"> Pumpspeicheräquivalenten."</span>)</span>
<span id="cb74-26"><a href="#cb74-26" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">"</span>)</span>
<span id="cb74-27"><a href="#cb74-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-28"><a href="#cb74-28" aria-hidden="true" tabindex="-1"></a>effekt_kappung_berechnen(restlast_2035, einspeicherwirkungsgrad <span class="op">=</span> mein_einspeicherwirkungsgrad, ausspeicherwirkungsgrad <span class="op">=</span> mein_ausspeicherwirkungsgrad, neue_speichergrößen <span class="op">=</span> meine_speichergrößen, output <span class="op">=</span> <span class="va">True</span>)</span>
<span id="cb74-29"><a href="#cb74-29" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">"</span>)</span>
<span id="cb74-30"><a href="#cb74-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-31"><a href="#cb74-31" aria-hidden="true" tabindex="-1"></a>anteil_ee_berechnen(restlast_2035, netzlast <span class="op">=</span> netzlast_2035, einspeicherwirkungsgrad <span class="op">=</span> mein_einspeicherwirkungsgrad, ausspeicherwirkungsgrad <span class="op">=</span> mein_ausspeicherwirkungsgrad, neue_speichergrößen <span class="op">=</span> meine_speichergrößen, output <span class="op">=</span> <span class="va">True</span>)</span></code><button title="In die Zwischenablage kopieren" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>maximal erforderliche Speichergröße 2035: 6,297,298.2 MWh
Dies entspricht 168.4 Pumpspeicheräquivalenten.


    Speichergröße  Einspeicherung Jahr1  Zyklen Jahr1  Einspeicherung Jahr2  \
0        6.30e+06              6.13e+07          9.23              5.50e+07   
1        5.67e+06              6.00e+07         10.09              5.44e+07   
2        5.04e+06              5.88e+07         11.17              5.37e+07   
3        4.41e+06              5.70e+07         12.43              5.26e+07   
4        3.78e+06              5.51e+07         14.09              5.13e+07   
5        3.15e+06              5.32e+07         16.40              5.01e+07   
6        2.52e+06              5.13e+07         19.88              4.88e+07   
7        1.89e+06              4.93e+07         25.60              4.74e+07   
8        1.26e+06              4.66e+07         36.51              4.54e+07   
9        6.30e+05              4.21e+07         66.35              4.15e+07   
10       5.04e+05              4.04e+07         79.73              3.99e+07   
11       3.78e+05              3.72e+07         97.99              3.68e+07   
12       2.52e+05              3.06e+07        120.82              3.03e+07   
13       1.26e+05              1.92e+07        151.83              1.91e+07   
14       6.30e+04              1.12e+07        177.35              1.11e+07   

    Zyklen Jahr2  
0           8.73  
1           9.59  
2          10.67  
3          11.93  
4          13.59  
5          15.90  
6          19.38  
7          25.10  
8          36.01  
9          65.85  
10         79.23  
11         97.49  
12        120.32  
13        151.33  
14        176.85  


    relative Speichergröße  gekappte Einspeicherung Jahr1  \
0                     0.90                       1.26e+06   
1                     0.80                       2.52e+06   
2                     0.70                       4.29e+06   
3                     0.60                       6.17e+06   
4                     0.50                       8.06e+06   
5                     0.40                       9.95e+06   
6                     0.30                       1.20e+07   
7                     0.20                       1.47e+07   
8                     0.10                       1.92e+07   
9                     0.08                       2.09e+07   
10                    0.06                       2.41e+07   
11                    0.04                       3.07e+07   
12                    0.02                       4.21e+07   
13                    0.01                       5.01e+07   

    gekappte Einspeicherung Jahr2  
0                        6.30e+05  
1                        1.26e+06  
2                        2.40e+06  
3                        3.66e+06  
4                        4.92e+06  
5                        6.17e+06  
6                        7.57e+06  
7                        9.64e+06  
8                        1.35e+07  
9                        1.51e+07  
10                       1.82e+07  
11                       2.47e+07  
12                       3.59e+07  
13                       4.39e+07  


Summe Netzlast: 670,400,000.00
Summe positive Restlast: 48,392,288.08  Summe negative Restlast: -356,082,036.13
Speichergröße 1: 6,297,298.20   Anteil EE ohne Speicher: 0.93

    relative Speichergröße  Anteil EE Jahr1  Anteil EE Jahr2
0                     1.00             1.00             1.00
1                     0.90             1.00             1.00
2                     0.80             1.00             1.00
3                     0.70             1.00             1.00
4                     0.60             1.00             1.00
5                     0.50             0.99             0.99
6                     0.40             0.99             0.99
7                     0.30             0.99             0.99
8                     0.20             0.99             0.99
9                     0.10             0.98             0.98
10                    0.08             0.98             0.98
11                    0.06             0.98             0.98
12                    0.04             0.97             0.97
13                    0.02             0.95             0.95
14                    0.01             0.94             0.94</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<p>Eine grafische Darstellung des Jahresgangs des Speichers kann für verschiedene Auslegungen relativ zur maximal benötigten Speichergröße mit Hilfe der Funktion <code>jahresgang_speicher_berechnen(output = False)</code> erzeugt werden. <strong>To Do: fig-alt, fig-cap</strong></p>
<div class="tabset-margin-container"></div><div class="panel-tabset">
<ul class="nav nav-tabs" role="tablist"><li class="nav-item" role="presentation"><a class="nav-link active" id="tabset-16-1-tab" data-bs-toggle="tab" data-bs-target="#tabset-16-1" role="tab" aria-controls="tabset-16-1" aria-selected="true" href="">80 % 2030</a></li><li class="nav-item" role="presentation"><a class="nav-link" id="tabset-16-2-tab" data-bs-toggle="tab" data-bs-target="#tabset-16-2" role="tab" aria-controls="tabset-16-2" aria-selected="false" href="">80 % 2035</a></li><li class="nav-item" role="presentation"><a class="nav-link" id="tabset-16-3-tab" data-bs-toggle="tab" data-bs-target="#tabset-16-3" role="tab" aria-controls="tabset-16-3" aria-selected="false" href="">20 % 2030</a></li><li class="nav-item" role="presentation"><a class="nav-link" id="tabset-16-4-tab" data-bs-toggle="tab" data-bs-target="#tabset-16-4" role="tab" aria-controls="tabset-16-4" aria-selected="false" href="">20 % 2035</a></li><li class="nav-item" role="presentation"><a class="nav-link" id="tabset-16-5-tab" data-bs-toggle="tab" data-bs-target="#tabset-16-5" role="tab" aria-controls="tabset-16-5" aria-selected="false" href="">4 % 2030</a></li><li class="nav-item" role="presentation"><a class="nav-link" id="tabset-16-6-tab" data-bs-toggle="tab" data-bs-target="#tabset-16-6" role="tab" aria-controls="tabset-16-6" aria-selected="false" href="">4 % 2035</a></li></ul>
<div class="tab-content">
<div id="tabset-16-1" class="tab-pane active" role="tabpanel" aria-labelledby="tabset-16-1-tab">
<div id="18f5c932" class="cell" data-execution_count="70">
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="Energiedatenauswertung_files/figure-html/cell-71-output-1.png" width="710" height="569" class="figure-img"></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Zyklenzahl Jahr 1: 10.01
Zyklenzahl Jahr 2: 9.51
Summe Netzlast: 658,000,000.00
Summe positive Restlast: 72,188,237.10  Summe negative Restlast: -181,270,542.87
Speichergröße 1: 10,368,907.77  Anteil EE ohne Speicher: 0.89

   relative Speichergröße  Anteil EE Jahr1  Anteil EE Jahr2
0                     1.0              1.0              1.0
1                     0.8              1.0              1.0

Die Speichergröße beträgt 8,295,126.2 MWh
Dies entspricht 221.8 Pumpspeicheräquivalenten.</code></pre>
</div>
</div>
</div>
<div id="tabset-16-2" class="tab-pane" role="tabpanel" aria-labelledby="tabset-16-2-tab">
<div id="fd904c0f" class="cell" data-execution_count="71">
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="Energiedatenauswertung_files/figure-html/cell-72-output-1.png" width="710" height="569" class="figure-img"></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Zyklenzahl Jahr 1: 11.17
Zyklenzahl Jahr 2: 10.67
Summe Netzlast: 670,400,000.00
Summe positive Restlast: 48,392,288.08  Summe negative Restlast: -356,082,036.13
Speichergröße 1: 6,297,298.20   Anteil EE ohne Speicher: 0.93

   relative Speichergröße  Anteil EE Jahr1  Anteil EE Jahr2
0                     1.0              1.0              1.0
1                     0.8              1.0              1.0

Die Speichergröße beträgt 5,037,838.6 MWh
Dies entspricht 134.7 Pumpspeicheräquivalenten.</code></pre>
</div>
</div>
</div>
<div id="tabset-16-3" class="tab-pane" role="tabpanel" aria-labelledby="tabset-16-3-tab">
<div id="b0501bee" class="cell" data-execution_count="72">
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="Energiedatenauswertung_files/figure-html/cell-73-output-1.png" width="710" height="569" class="figure-img"></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Zyklenzahl Jahr 1: 31.39
Zyklenzahl Jahr 2: 30.89
Summe Netzlast: 658,000,000.00
Summe positive Restlast: 72,188,237.10  Summe negative Restlast: -181,270,542.87
Speichergröße 1: 10,368,907.77  Anteil EE ohne Speicher: 0.89

   relative Speichergröße  Anteil EE Jahr1  Anteil EE Jahr2
0                     1.0             1.00             1.00
1                     0.2             0.98             0.98

Die Speichergröße beträgt 2,073,781.6 MWh
Dies entspricht 55.4 Pumpspeicheräquivalenten.</code></pre>
</div>
</div>
</div>
<div id="tabset-16-4" class="tab-pane" role="tabpanel" aria-labelledby="tabset-16-4-tab">
<div id="390e122d" class="cell" data-execution_count="73">
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="Energiedatenauswertung_files/figure-html/cell-74-output-1.png" width="710" height="569" class="figure-img"></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Zyklenzahl Jahr 1: 36.51
Zyklenzahl Jahr 2: 36.01
Summe Netzlast: 670,400,000.00
Summe positive Restlast: 48,392,288.08  Summe negative Restlast: -356,082,036.13
Speichergröße 1: 6,297,298.20   Anteil EE ohne Speicher: 0.93

   relative Speichergröße  Anteil EE Jahr1  Anteil EE Jahr2
0                     1.0             1.00             1.00
1                     0.2             0.99             0.99

Die Speichergröße beträgt 1,259,459.6 MWh
Dies entspricht 33.7 Pumpspeicheräquivalenten.</code></pre>
</div>
</div>
</div>
<div id="tabset-16-5" class="tab-pane" role="tabpanel" aria-labelledby="tabset-16-5-tab">
<div id="5a550943" class="cell" data-execution_count="74">
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="Energiedatenauswertung_files/figure-html/cell-75-output-1.png" width="710" height="569" class="figure-img"></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Zyklenzahl Jahr 1: 108.35
Zyklenzahl Jahr 2: 107.85
Summe Netzlast: 658,000,000.00
Summe positive Restlast: 72,188,237.10  Summe negative Restlast: -181,270,542.87
Speichergröße 1: 10,368,907.77  Anteil EE ohne Speicher: 0.89

   relative Speichergröße  Anteil EE Jahr1  Anteil EE Jahr2
0                    1.00             1.00             1.00
1                    0.04             0.95             0.95

Die Speichergröße beträgt 414,756.3 MWh
Dies entspricht 11.1 Pumpspeicheräquivalenten.</code></pre>
</div>
</div>
</div>
<div id="tabset-16-6" class="tab-pane" role="tabpanel" aria-labelledby="tabset-16-6-tab">
<div id="8abef4b1" class="cell" data-execution_count="75">
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="Energiedatenauswertung_files/figure-html/cell-76-output-1.png" width="710" height="569" class="figure-img"></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>Zyklenzahl Jahr 1: 120.82
Zyklenzahl Jahr 2: 120.32
Summe Netzlast: 670,400,000.00
Summe positive Restlast: 48,392,288.08  Summe negative Restlast: -356,082,036.13
Speichergröße 1: 6,297,298.20   Anteil EE ohne Speicher: 0.93

   relative Speichergröße  Anteil EE Jahr1  Anteil EE Jahr2
0                    1.00             1.00             1.00
1                    0.04             0.97             0.97

Die Speichergröße beträgt 251,891.9 MWh
Dies entspricht 6.7 Pumpspeicheräquivalenten.</code></pre>
</div>
</div>
</div>
</div>
</div>
<p>Interessant: In allen Szenarien ist die Zyklenzahl praktisch identisch. Im ersten Jahr läuft der Speicher im Januar voll - je nach Szenario innerhalb von 2 Wochen (Speichergröße 80 %, Jahr 2030), innerhalb weniger Tage (Speichergröße 80 %, Jahr 2035 und Speichergröße 20 %, Jahr 2030) oder nahezu sofort (Speichergröße 20 %, Jahr 2035 und Speichergröße 4 %, Jahre 2030 &amp; 2035). Dadurch wird in allen Szenarien im ersten Jahr ein halber Vollzyklus zusätzlich erreicht.</p>
</section>
<section id="zusammenfassung" class="level2" data-number="8.6">
<h2 data-number="8.6" class="anchored" data-anchor-id="zusammenfassung"><span class="header-section-number">8.6</span> Zusammenfassung</h2>
<p>Zusammenfassung: Datenanalyse macht Spaß … (so etwas in der Richtung)</p>
<ul>
<li><p>Interessante Fragen ergeben sich fast von alleine, wenn man einen Datensatz gründlich untersucht (beschreiben, erkunden, auswerten)</p></li>
<li><p>komplexe Arbeitsschritte sollten in überschaubare Teilschritte unterteilt werden</p></li>
<li><p>Funktionen sollten mit überschaubaren Testdaten entwickelt und überprüft werden</p></li>
<li><p>Je mehr erneuerbare Überschusserzeugung zur Verfügung steht, desto kleiner kann ein Speicher dimensioniert werden. Dennoch ist eine 100-prozentige Versorung auf der Grundlage volatiler Erzeugung und Speicherung kaum zu realisieren, da die erforderliche Speichergröße für das Erreichen von 95 %, 98 %, 99 % bis 100 % erneuerbaren Anteils exponentiell steigt. Entsprechend dimensionierte Stromspeicher können mit einstelligen Vollzyklenzahlen im Jahr nicht wirtschaftlich betrieben werden (siehe Jahresgang der Pumpspeicherkraftwerke). Dies gilt jedoch nur in einem System, in dem erneuerbare Energien Einspeisevorrang genießen und keinen Anreiz haben, in Lastfolge zu arbeiten. <strong>Querverweis auf Kapitel Übungen einfügen</strong></p></li>
</ul>
<p>Für 80 Prozent:<br>
2030: Der Speicher weist die meiste Zeit des Jahrs Ladestände im Bereich der Ladekapzität auf. Eine hohe Entladetiefe wird nur von Ende November bis Ende März erreicht.</p>
<p>2035: Der Speicher ist die meiste Zeit des Jahres voll. Eine größere Entladung findet von Anfang Dezember bis Ende Februar statt.</p>
<p>Witzig ist, dass hier die 80-20-Regel (<a href="https://de.wikipedia.org/wiki/Paretoprinzip">Paretoprinzip</a>) gilt. Mit 20 Prozent des Aufwands erreicht man 80 Prozent des Weges. Daten für 2035:</p>
<ul>
<li><p>Anteil EE ohne Speicher: 0.89 –&gt; Weg bis 100 Prozent = 0.11</p></li>
<li><p>mit relativer Speichergröße 0.20 wird ein EE-Anteil von 0.98 erreicht</p></li>
<li><p>dies entspricht 55.4 Pumpspeicheräquivalenten bzw. 2073.8 GWh, was 41.5 Jahresproduktionen der Tesla Gigafactory Berlin-Brandenburg in der ersten Ausbaustufe mit 50 GWh/a entspricht. Die Fabrik könne bis zu 250 GWh/a produzieren. Dann reichen 8,3 Jahresproduktionen für die Zielerreichung von 98 Prozent EE bis 2035. (<a href="https://de.wikipedia.org/wiki/Liste_von_Batteriezellfabriken_in_Deutschlandhttps://de.wikipedia.org/wiki/Liste_von_Batteriezellfabriken_in_Deutschland" class="uri">https://de.wikipedia.org/wiki/Liste_von_Batteriezellfabriken_in_Deutschlandhttps://de.wikipedia.org/wiki/Liste_von_Batteriezellfabriken_in_Deutschland</a>)</p></li>
<li><p>mit einer relativen Speichergröße von 0.04 (20 Prozent von 0.20) wird ein EE-Anteil von 0.95 erreicht</p></li>
<li><p>Dies entspricht 11,1 Pumpspeicheräquivalenten bzw. 415 GWh, was 8,3 Jahresproduktionen der Tesla Gigafactory Berlin-Brandenburg in der ersten Ausbaustufe bzw. 1,7 Jahresprdouktionen im Vollausbau entspricht.</p></li>
</ul>
</section>
</section>
<section id="informationen-zu-speichern" class="level1" data-number="9">
<h1 data-number="9"><span class="header-section-number">9</span> Informationen zu Speichern</h1>
<p>Viele Zahlen in diesem Artikel: https://www.msn.com/de-de/finanzen/top-stories/energiewende-das-riesige-potenzial-der-e-autos-f%C3%BCr-die-energiewende/ar-BB1mErcB?ocid=entnewsntp&amp;pc=U531&amp;cvid=3d61906f85914af89a3255239a2138f0&amp;ei=23</p>
<ul>
<li><p>dort Referenz auf <a href="https://www.ise.fraunhofer.de/de/veroeffentlichungen/studien/wege-zu-einem-klimaneutralen-energiesystem.html">Fraunhofer ISE Studie 2021: Wege zu einem klimaneutralen Energiesystem</a></p>
<ul>
<li><p>Szenario Referenz: ohne weitere, die Zielerreichung fördernde oder erschwerende Randbedingungen. Bedarf Speicherkapazität 2045: 514,6 GWh <strong>Das ist ja “nur” rund ein Tausendstel der aktuellen Jahresproduktion. Das heißt neben jedes Kraftwerk käme ein Speicher mit einer Kapazität von einem Drittel der Tagesproduktion.</strong></p></li>
<li><p>Link zur Grafik mit verschiedenen Szenarien: <a href="https://energy-charts.info/charts/remod_installed_power/chart.htm?l=de&amp;c=DE&amp;source=storage#scenarios" class="uri">https://energy-charts.info/charts/remod_installed_power/chart.htm?l=de&amp;c=DE&amp;source=storage#scenarios</a></p></li>
</ul></li>
</ul>
<p>Wirkungsgrade verschiedener Speichertypen:</p>
<ul>
<li><p><a href="https://de.statista.com/statistik/daten/studie/1302470/umfrage/wirkungsgrad-von-stromspeichern/" class="uri">https://de.statista.com/statistik/daten/studie/1302470/umfrage/wirkungsgrad-von-stromspeichern/</a></p></li>
<li><p>Das Wichtigste (vielleicht als Video)</p></li>
<li><p>Lernzielkontrolle</p>
<ul>
<li><p>Kompetenzquiz (ggf. aufklappbarer Callout Block, Textverweis für PDF, polierte Lösungen evntl. via Lumi später entscheiden)</p></li>
<li><p>Übungsaufgaben (kleine Projekte)</p></li>
</ul></li>
<li><p>Prüfungsaufgaben (ohne Lösungen)</p></li>
</ul>
</section>
<section id="das-wichtigste" class="level1" data-number="10">
<h1 data-number="10"><span class="header-section-number">10</span> Das Wichtigste</h1>
<p>Datensätze kontrollieren, plausibilisieren und visualisieren –&gt; das meiste erkennt man visuell, die Quantifizierung mit Kennzahlen ist eine wichtige Ergänzung (kann alleine aber irreführen [Beispiel: Abschaltung KKW]) –&gt; Am Beispiel der Pumpspeicher hat man gesehen, das Datensätze unerwartet zusammengestellt sein können. (Berücksichtigung von Einspeisung aus Pumpspeicherkraftwerken im Datensatz Stromerzeugung.) –&gt; deskritive und explorative Statistik sowie Visualisierungstechniken sind wichtige Instrumente, um Datensätze “zu verstehen” und ggf. Fehler oder Eigenheiten zu bereinigen.</p>
<p>–&gt; Erzeugung und Verbrauch durch Pumpspeicher müssten für eine weitergehende Erzeugungsanalyse bereinigt werden: Realisierte Einspeisung ist anderen Energieträgern zuzuschreiben; Verbrauch = Realisierter Verbrauch - Realisierte Einspeisung.</p>
<p><strong>Die Grundlast ist tot.</strong> Berechnung der Jahresvolllaststunden und Visualisierung der Jahresgänge zeigen, dass es durch den hohen Anteil volatiler erneuerbarer Stromerzeugung im deutschen Stromsystem keine Grundlast mehr gibt. Dies bedeutet, dass alle nicht erneuerbaren Erzeuger im Lastfolgebetrieb arbeiten.</p>
<p><strong>Steinkohle ist das neue Erdgas.</strong></p>
<p>Resterrampe von der Planung: Grenzstrom: 2 (3) Regime (EE-Überschuss, fossile Lastfolgebetrieb.)</p>
<pre><code>- Vorbereitung 1: Restlast bestimmen

  - Herkunft Pumpspeicherenergie grob abschätzen: in wie vielen Intervallen war die Restlast negativ

  - Herkunft Pumpspeicherenergie genauer bestimmen: Abgleich Null oder negative Restlast mit Verbrauch der Pumpspeicher (Befüllen)

    - Wenn Restlast 0 oder negativ = Befüllung mit EE, wenn Restlast &gt; 0 = Befüllung mit Lastfolgeerzeugern

- Vorbereitung 2: Welche Erzeuger laufen in Grundlast, welche in Lastfolgebetrieb? **Grundlast ist tot.**

  - Quantifizierung mit Jahresvolllaststunden

  - Erzeugung im Jahresverlauf plotten --&gt; Abschaltung der AKW erkennen.
  
  - die Erzeuger werden in drei Gruppen eingeteilt (Grundlast, Lastfolge, EE)</code></pre>
<p>Welche Erzeuger die Einspeicherung geleistet haben, lässt sich empirisch überprüfen. <em>Befüllung der Pumpspeicher und die Restlast im Jahresgang anzeigen und anschließend nur die Werte zeigen, zu denen der Verbrauch der Pumpspeicher &gt; 0 ist</em></p>
</section>
<section id="übungen" class="level1" data-number="11">
<h1 data-number="11"><span class="header-section-number">11</span> Übungen</h1>
<p>Wir haben gesehen, dass durch die Kappung von Erzeugungsspitzen in einem von erneuerbarer Überschussproduktion geprägtem Stromsystem der erforderliche Stromspeicher um Größenordnungen kleiner dimensioniert werden kann. Allerdings verbleiben dann wenige Prozent der Jahresstromnachfrage, die nicht erneuerbar aus der laufenden Produktion oder durch Ausspeicherung gedeckt werden können. Eine Option bestünde darin, die Biomassekraftwerke in Lastfolge zu betreiben.</p>
<p>Berechnen Sie die erforderliche Speichergröße, wenn der Anteil erneuerbarer Energien 2030 und 2035 100 Prozent betragen soll und Biomassekraftwerke in Lastfolge betrieben werden. Der Einspeicherwirkungsgrad betrage 0.9, der Ausspeicherwirkungsgrad = 0.88. <strong>vorher kurz mal den Jahresgang Biomasse plotten.</strong></p>
<!-- # Resterampe -->

</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">Literatur</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-Arnold-2023-Strommarktdatenanalyse" class="csl-entry" role="listitem">
Arnold, Simone. 2023. <span>„Datenanalyse mit Python. Das Modul Pandas.“</span> Fachhochschule Dortmund.
</div>
<div id="ref-energy-charts-strom" class="csl-entry" role="listitem">
Fraunhofer Institut für Solare Energiesysteme ISE. o.&nbsp;J. <span>„Öffentliche Nettostromerzeugung in Deutschland“</span>. Zugegriffen 3. Juni 2024. <a href="https://energy-charts.info/charts/energy/chart.htm?l=de&amp;c=DE&amp;chartColumnSorting=default&amp;year=-1&amp;interval=year&amp;legendItems=lz1zb&amp;source=public">https://energy-charts.info/charts/energy/chart.htm?l=de&amp;c=DE&amp;chartColumnSorting=default&amp;year=-1&amp;interval=year&amp;legendItems=lz1zb&amp;source=public</a>.
</div>
<div id="ref-Heimerl-Kohler-2017-Pumpspeicher-in-Deutschland" class="csl-entry" role="listitem">
Heimerl, Stephan, und Beate Kohler. 2017. <span>„Aktueller Stand der Pumpspeicherkraftwerke in Deutschland“</span>. WasserWirtschaft. 2017. <a href="https://www.fwt.fichtner.de/userfiles/fileadmin-fwt/Publikationen/WaWi_2017_10_Heimerl_Kohler_PSKW.pdf">https://www.fwt.fichtner.de/userfiles/fileadmin-fwt/Publikationen/WaWi_2017_10_Heimerl_Kohler_PSKW.pdf</a>.
</div>
<div id="ref-R-for-Data-Science" class="csl-entry" role="listitem">
Wickham, Hadley, Mine Çetinkaya-Rundel, und Garrett Grolemund. 2023. <span>„R for data science: Import, tidy, transform, visualize, and model data“</span>. Beijing; Boston; Farnham; Sebastopol; Tokyo: O’Reilly. 2023. <a href="https://r4ds.hadley.nz/">https://r4ds.hadley.nz/</a>.
</div>
</div></section></div></main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Kopiert");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Kopiert");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>